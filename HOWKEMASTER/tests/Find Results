Searching 5941 files for "Route"

/home/dila/Videos/HOWKEMASTER/app/Console/Kernel.php:
   36      protected function commands()
   37      {
   38:         require base_path('routes/console.php');
   39      }
   40  }

/home/dila/Videos/HOWKEMASTER/app/Exceptions/Handler.php:
   61          }
   62  
   63:         return redirect()->guest(route('login'));
   64      }
   65  }

/home/dila/Videos/HOWKEMASTER/app/Http/Kernel.php:
   22  
   23      /**
   24:      * The application's route middleware groups.
   25       *
   26       * @var array
   ..
   44  
   45      /**
   46:      * The application's route middleware.
   47       *
   48       * These middleware may be assigned to groups or used individually.
   ..
   50       * @var array
   51       */
   52:     protected $routeMiddleware = [
   53          'auth' => \Illuminate\Auth\Middleware\Authenticate::class,
   54          'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,

/home/dila/Videos/HOWKEMASTER/app/Http/routes.php:
    1  <?
    2  
    3: Route::get('/',function (){
    4  	return "Hi";
    5  

/home/dila/Videos/HOWKEMASTER/app/Providers/BroadcastServiceProvider.php:
   15      public function boot()
   16      {
   17:         Broadcast::routes();
   18  
   19:         require base_path('routes/channels.php');
   20      }
   21  }

/home/dila/Videos/HOWKEMASTER/app/Providers/RouteServiceProvider.php:
    3  namespace App\Providers;
    4  
    5: use Illuminate\Support\Facades\Route;
    6: use Illuminate\Foundation\Support\Providers\RouteServiceProvider as ServiceProvider;
    7  
    8: class RouteServiceProvider extends ServiceProvider
    9  {
   10      /**
   11:      * This namespace is applied to your controller routes.
   12       *
   13       * In addition, it is set as the URL generator's root namespace.
   ..
   18  
   19      /**
   20:      * Define your route model bindings, pattern filters, etc.
   21       *
   22       * @return void
   ..
   30  
   31      /**
   32:      * Define the routes for the application.
   33       *
   34       * @return void
   ..
   36      public function map()
   37      {
   38:         $this->mapApiRoutes();
   39  
   40:         $this->mapWebRoutes();
   41  
   42          //
   ..
   44  
   45      /**
   46:      * Define the "web" routes for the application.
   47       *
   48:      * These routes all receive session state, CSRF protection, etc.
   49       *
   50       * @return void
   51       */
   52:     protected function mapWebRoutes()
   53      {
   54:         Route::middleware('web')
   55               ->namespace($this->namespace)
   56:              ->group(base_path('routes/web.php'));
   57      }
   58  
   59      /**
   60:      * Define the "api" routes for the application.
   61       *
   62:      * These routes are typically stateless.
   63       *
   64       * @return void
   65       */
   66:     protected function mapApiRoutes()
   67      {
   68:         Route::prefix('api')
   69               ->middleware('api')
   70               ->namespace($this->namespace)
   71:              ->group(base_path('routes/api.php'));
   72      }
   73  }

/home/dila/Videos/HOWKEMASTER/bootstrap/cache/services.php:
   28      24 => 'App\\Providers\\AuthServiceProvider',
   29      25 => 'App\\Providers\\EventServiceProvider',
   30:     26 => 'App\\Providers\\RouteServiceProvider',
   31    ),
   32    'eager' => 
   ..
   45      11 => 'App\\Providers\\AuthServiceProvider',
   46      12 => 'App\\Providers\\EventServiceProvider',
   47:     13 => 'App\\Providers\\RouteServiceProvider',
   48    ),
   49    'deferred' => 
   ..
   81      'command.queue.retry' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
   82      'command.queue.work' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
   83:     'command.route.cache' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
   84:     'command.route.clear' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
   85:     'command.route.list' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
   86      'command.seed' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',
   87      'Illuminate\\Console\\Scheduling\\ScheduleFinishCommand' => 'Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider',

/home/dila/Videos/HOWKEMASTER/composer.lock:
 1613              "suggest": {
 1614                  "doctrine/annotations": "For using the annotation loader",
 1615:                 "symfony/config": "For using the all-in-one router or any loader",
 1616:                 "symfony/dependency-injection": "For loading routes from a service",
 1617                  "symfony/expression-language": "For using expression matching",
 1618                  "symfony/http-foundation": "For using a Symfony Request object",
 ....
 1650              "homepage": "https://symfony.com",
 1651              "keywords": [
 1652:                 "router",
 1653                  "routing",
 1654                  "uri",

/home/dila/Videos/HOWKEMASTER/config/app.php:
  176          // App\Providers\BroadcastServiceProvider::class,
  177          App\Providers\EventServiceProvider::class,
  178:         App\Providers\RouteServiceProvider::class,
  179  
  180      ],
  ...
  219          'Request' => Illuminate\Support\Facades\Request::class,
  220          'Response' => Illuminate\Support\Facades\Response::class,
  221:         'Route' => Illuminate\Support\Facades\Route::class,
  222          'Schema' => Illuminate\Support\Facades\Schema::class,
  223          'Session' => Illuminate\Support\Facades\Session::class,

/home/dila/Videos/HOWKEMASTER/resources/views/welcome.blade.php:
   67      <body>
   68          <div class="flex-center position-ref full-height">
   69:             @if (Route::has('login'))
   70                  <div class="top-right links">
   71                      @if (Auth::check())

/home/dila/Videos/HOWKEMASTER/routes/api.php:
    5  /*
    6  |--------------------------------------------------------------------------
    7: | API Routes
    8  |--------------------------------------------------------------------------
    9  |
   10: | Here is where you can register API routes for your application. These
   11: | routes are loaded by the RouteServiceProvider within a group which
   12  | is assigned the "api" middleware group. Enjoy building your API!
   13  |
   14  */
   15  
   16: Route::middleware('auth:api')->get('/user', function (Request $request) {
   17      return $request->user();
   18  });

/home/dila/Videos/HOWKEMASTER/routes/console.php:
    5  /*
    6  |--------------------------------------------------------------------------
    7: | Console Routes
    8  |--------------------------------------------------------------------------
    9  |

/home/dila/Videos/HOWKEMASTER/routes/web.php:
    3  /*
    4  |--------------------------------------------------------------------------
    5: | Web Routes
    6  |--------------------------------------------------------------------------
    7  |
    8: | Here is where you can register web routes for your application. These
    9: | routes are loaded by the RouteServiceProvider within a group which
   10  | contains the "web" middleware group. Now create something great!
   11  |
   12  */
   13  
   14: Route::get('/', function () {
   15      return view('welcome');
   16  });

/home/dila/Videos/HOWKEMASTER/storage/framework/.gitignore:
    1  config.php
    2: routes.php
    3  schedule-*
    4  compiled.php
    5  services.json
    6  events.scanned.php
    7: routes.scanned.php
    8  down
    9  

/home/dila/Videos/HOWKEMASTER/storage/framework/views/3c5449a7eb74f0ac6db5fdfd5525f8e5a8ac76c2.php:
   67      <body>
   68          <div class="flex-center position-ref full-height">
   69:             <?php if(Route::has('login')): ?>
   70                  <div class="top-right links">
   71                      <?php if(Auth::check()): ?>

/home/dila/Videos/HOWKEMASTER/storage/framework/views/def769b9c10dff002f5711ca32c0fb91ba137f03.php:
   67      <body>
   68          <div class="flex-center position-ref full-height">
   69:             <?php if(Route::has('login')): ?>
   70                  <div class="top-right links">
   71                      <?php if(Auth::check()): ?>

/home/dila/Videos/HOWKEMASTER/storage/logs/laravel.log:
    1: [2017-08-08 03:31:37] local.ERROR: Symfony\Component\Console\Exception\CommandNotFoundException: Command "make:router" is not defined.
    2  
    3  Did you mean one of these?
    .
   19      make:test in /home/dila/Videos/HOWKEMASTER/vendor/symfony/console/Application.php:579
   20  Stack trace:
   21: #0 /home/dila/Videos/HOWKEMASTER/vendor/symfony/console/Application.php(204): Symfony\Component\Console\Application->find('make:router')
   22  #1 /home/dila/Videos/HOWKEMASTER/vendor/symfony/console/Application.php(130): Symfony\Component\Console\Application->doRun(Object(Symfony\Component\Console\Input\ArgvInput), Object(Symfony\Component\Console\Output\ConsoleOutput))
   23  #2 /home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/Console/Kernel.php(122): Symfony\Component\Console\Application->run(Object(Symfony\Component\Console\Input\ArgvInput), Object(Symfony\Component\Console\Output\ConsoleOutput))

/home/dila/Videos/HOWKEMASTER/vendor/composer/autoload_classmap.php:
   23      'App\\Providers\\BroadcastServiceProvider' => $baseDir . '/app/Providers/BroadcastServiceProvider.php',
   24      'App\\Providers\\EventServiceProvider' => $baseDir . '/app/Providers/EventServiceProvider.php',
   25:     'App\\Providers\\RouteServiceProvider' => $baseDir . '/app/Providers/RouteServiceProvider.php',
   26      'App\\User' => $baseDir . '/app/User.php',
   27      'Carbon\\Carbon' => $vendorDir . '/nesbot/carbon/src/Carbon/Carbon.php',
   ..
  893      'Illuminate\\Foundation\\Console\\QueuedCommand' => $vendorDir . '/laravel/framework/src/Illuminate/Foundation/Console/QueuedCommand.php',
  894      'Illuminate\\Foundation\\Console\\RequestMakeCommand' => $vendorDir . '/laravel/framework/src/Illuminate/Foundation/Console/RequestMakeCommand.php',
  895:     'Illuminate\\Foundation\\Console\\RouteCacheCommand' => $vendorDir . '/laravel/framework/src/Illuminate/Foundation/Console/RouteCacheCommand.php',
  896:     'Illuminate\\Foundation\\Console\\RouteClearCommand' => $vendorDir . '/laravel/framework/src/Illuminate/Foundation/Console/RouteClearCommand.php',
  897:     'Illuminate\\Foundation\\Console\\RouteListCommand' => $vendorDir . '/laravel/framework/src/Illuminate/Foundation/Console/RouteListCommand.php',
  898      'Illuminate\\Foundation\\Console\\ServeCommand' => $vendorDir . '/laravel/framework/src/Illuminate/Foundation/Console/ServeCommand.php',
  899      'Illuminate\\Foundation\\Console\\StorageLinkCommand' => $vendorDir . '/laravel/framework/src/Illuminate/Foundation/Console/StorageLinkCommand.php',
  ...
  925      'Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider' => $vendorDir . '/laravel/framework/src/Illuminate/Foundation/Support/Providers/AuthServiceProvider.php',
  926      'Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider' => $vendorDir . '/laravel/framework/src/Illuminate/Foundation/Support/Providers/EventServiceProvider.php',
  927:     'Illuminate\\Foundation\\Support\\Providers\\RouteServiceProvider' => $vendorDir . '/laravel/framework/src/Illuminate/Foundation/Support/Providers/RouteServiceProvider.php',
  928      'Illuminate\\Foundation\\Testing\\Concerns\\InteractsWithAuthentication' => $vendorDir . '/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/InteractsWithAuthentication.php',
  929      'Illuminate\\Foundation\\Testing\\Concerns\\InteractsWithConsole' => $vendorDir . '/laravel/framework/src/Illuminate/Foundation/Testing/Concerns/InteractsWithConsole.php',
  ...
 1010      'Illuminate\\Notifications\\NotificationSender' => $vendorDir . '/laravel/framework/src/Illuminate/Notifications/NotificationSender.php',
 1011      'Illuminate\\Notifications\\NotificationServiceProvider' => $vendorDir . '/laravel/framework/src/Illuminate/Notifications/NotificationServiceProvider.php',
 1012:     'Illuminate\\Notifications\\RoutesNotifications' => $vendorDir . '/laravel/framework/src/Illuminate/Notifications/RoutesNotifications.php',
 1013      'Illuminate\\Notifications\\SendQueuedNotifications' => $vendorDir . '/laravel/framework/src/Illuminate/Notifications/SendQueuedNotifications.php',
 1014      'Illuminate\\Pagination\\AbstractPaginator' => $vendorDir . '/laravel/framework/src/Illuminate/Pagination/AbstractPaginator.php',
 ....
 1091      'Illuminate\\Routing\\ControllerDispatcher' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/ControllerDispatcher.php',
 1092      'Illuminate\\Routing\\ControllerMiddlewareOptions' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/ControllerMiddlewareOptions.php',
 1093:     'Illuminate\\Routing\\Events\\RouteMatched' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/Events/RouteMatched.php',
 1094      'Illuminate\\Routing\\Exceptions\\UrlGenerationException' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/Exceptions/UrlGenerationException.php',
 1095:     'Illuminate\\Routing\\ImplicitRouteBinding' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/ImplicitRouteBinding.php',
 1096      'Illuminate\\Routing\\Matching\\HostValidator' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/Matching/HostValidator.php',
 1097      'Illuminate\\Routing\\Matching\\MethodValidator' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/Matching/MethodValidator.php',
 ....
 1106      'Illuminate\\Routing\\ResourceRegistrar' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/ResourceRegistrar.php',
 1107      'Illuminate\\Routing\\ResponseFactory' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/ResponseFactory.php',
 1108:     'Illuminate\\Routing\\Route' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/Route.php',
 1109:     'Illuminate\\Routing\\RouteAction' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/RouteAction.php',
 1110:     'Illuminate\\Routing\\RouteBinding' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/RouteBinding.php',
 1111:     'Illuminate\\Routing\\RouteCollection' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/RouteCollection.php',
 1112:     'Illuminate\\Routing\\RouteCompiler' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/RouteCompiler.php',
 1113:     'Illuminate\\Routing\\RouteDependencyResolverTrait' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/RouteDependencyResolverTrait.php',
 1114:     'Illuminate\\Routing\\RouteGroup' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/RouteGroup.php',
 1115:     'Illuminate\\Routing\\RouteParameterBinder' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/RouteParameterBinder.php',
 1116:     'Illuminate\\Routing\\RouteRegistrar' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/RouteRegistrar.php',
 1117:     'Illuminate\\Routing\\RouteSignatureParameters' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/RouteSignatureParameters.php',
 1118:     'Illuminate\\Routing\\RouteUrlGenerator' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/RouteUrlGenerator.php',
 1119:     'Illuminate\\Routing\\Router' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/Router.php',
 1120      'Illuminate\\Routing\\RoutingServiceProvider' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/RoutingServiceProvider.php',
 1121      'Illuminate\\Routing\\SortedMiddleware' => $vendorDir . '/laravel/framework/src/Illuminate/Routing/SortedMiddleware.php',
 ....
 1167      'Illuminate\\Support\\Facades\\Request' => $vendorDir . '/laravel/framework/src/Illuminate/Support/Facades/Request.php',
 1168      'Illuminate\\Support\\Facades\\Response' => $vendorDir . '/laravel/framework/src/Illuminate/Support/Facades/Response.php',
 1169:     'Illuminate\\Support\\Facades\\Route' => $vendorDir . '/laravel/framework/src/Illuminate/Support/Facades/Route.php',
 1170      'Illuminate\\Support\\Facades\\Schema' => $vendorDir . '/laravel/framework/src/Illuminate/Support/Facades/Schema.php',
 1171      'Illuminate\\Support\\Facades\\Session' => $vendorDir . '/laravel/framework/src/Illuminate/Support/Facades/Session.php',
 ....
 2668      'Symfony\\Component\\HttpKernel\\DataCollector\\MemoryDataCollector' => $vendorDir . '/symfony/http-kernel/DataCollector/MemoryDataCollector.php',
 2669      'Symfony\\Component\\HttpKernel\\DataCollector\\RequestDataCollector' => $vendorDir . '/symfony/http-kernel/DataCollector/RequestDataCollector.php',
 2670:     'Symfony\\Component\\HttpKernel\\DataCollector\\RouterDataCollector' => $vendorDir . '/symfony/http-kernel/DataCollector/RouterDataCollector.php',
 2671      'Symfony\\Component\\HttpKernel\\DataCollector\\TimeDataCollector' => $vendorDir . '/symfony/http-kernel/DataCollector/TimeDataCollector.php',
 2672      'Symfony\\Component\\HttpKernel\\DataCollector\\Util\\ValueExporter' => $vendorDir . '/symfony/http-kernel/DataCollector/Util/ValueExporter.php',
 ....
 2693      'Symfony\\Component\\HttpKernel\\EventListener\\ProfilerListener' => $vendorDir . '/symfony/http-kernel/EventListener/ProfilerListener.php',
 2694      'Symfony\\Component\\HttpKernel\\EventListener\\ResponseListener' => $vendorDir . '/symfony/http-kernel/EventListener/ResponseListener.php',
 2695:     'Symfony\\Component\\HttpKernel\\EventListener\\RouterListener' => $vendorDir . '/symfony/http-kernel/EventListener/RouterListener.php',
 2696      'Symfony\\Component\\HttpKernel\\EventListener\\SaveSessionListener' => $vendorDir . '/symfony/http-kernel/EventListener/SaveSessionListener.php',
 2697      'Symfony\\Component\\HttpKernel\\EventListener\\SessionListener' => $vendorDir . '/symfony/http-kernel/EventListener/SessionListener.php',
 ....
 2773      'Symfony\\Component\\Process\\ProcessBuilder' => $vendorDir . '/symfony/process/ProcessBuilder.php',
 2774      'Symfony\\Component\\Process\\ProcessUtils' => $vendorDir . '/symfony/process/ProcessUtils.php',
 2775:     'Symfony\\Component\\Routing\\Annotation\\Route' => $vendorDir . '/symfony/routing/Annotation/Route.php',
 2776:     'Symfony\\Component\\Routing\\CompiledRoute' => $vendorDir . '/symfony/routing/CompiledRoute.php',
 2777      'Symfony\\Component\\Routing\\DependencyInjection\\RoutingResolverPass' => $vendorDir . '/symfony/routing/DependencyInjection/RoutingResolverPass.php',
 2778      'Symfony\\Component\\Routing\\Exception\\ExceptionInterface' => $vendorDir . '/symfony/routing/Exception/ExceptionInterface.php',
 ....
 2781      'Symfony\\Component\\Routing\\Exception\\MissingMandatoryParametersException' => $vendorDir . '/symfony/routing/Exception/MissingMandatoryParametersException.php',
 2782      'Symfony\\Component\\Routing\\Exception\\ResourceNotFoundException' => $vendorDir . '/symfony/routing/Exception/ResourceNotFoundException.php',
 2783:     'Symfony\\Component\\Routing\\Exception\\RouteNotFoundException' => $vendorDir . '/symfony/routing/Exception/RouteNotFoundException.php',
 2784      'Symfony\\Component\\Routing\\Generator\\ConfigurableRequirementsInterface' => $vendorDir . '/symfony/routing/Generator/ConfigurableRequirementsInterface.php',
 2785      'Symfony\\Component\\Routing\\Generator\\Dumper\\GeneratorDumper' => $vendorDir . '/symfony/routing/Generator/Dumper/GeneratorDumper.php',
 ....
 2792      'Symfony\\Component\\Routing\\Loader\\AnnotationFileLoader' => $vendorDir . '/symfony/routing/Loader/AnnotationFileLoader.php',
 2793      'Symfony\\Component\\Routing\\Loader\\ClosureLoader' => $vendorDir . '/symfony/routing/Loader/ClosureLoader.php',
 2794:     'Symfony\\Component\\Routing\\Loader\\DependencyInjection\\ServiceRouterLoader' => $vendorDir . '/symfony/routing/Loader/DependencyInjection/ServiceRouterLoader.php',
 2795      'Symfony\\Component\\Routing\\Loader\\DirectoryLoader' => $vendorDir . '/symfony/routing/Loader/DirectoryLoader.php',
 2796:     'Symfony\\Component\\Routing\\Loader\\ObjectRouteLoader' => $vendorDir . '/symfony/routing/Loader/ObjectRouteLoader.php',
 2797      'Symfony\\Component\\Routing\\Loader\\PhpFileLoader' => $vendorDir . '/symfony/routing/Loader/PhpFileLoader.php',
 2798      'Symfony\\Component\\Routing\\Loader\\XmlFileLoader' => $vendorDir . '/symfony/routing/Loader/XmlFileLoader.php',
 2799      'Symfony\\Component\\Routing\\Loader\\YamlFileLoader' => $vendorDir . '/symfony/routing/Loader/YamlFileLoader.php',
 2800      'Symfony\\Component\\Routing\\Matcher\\Dumper\\DumperCollection' => $vendorDir . '/symfony/routing/Matcher/Dumper/DumperCollection.php',
 2801:     'Symfony\\Component\\Routing\\Matcher\\Dumper\\DumperRoute' => $vendorDir . '/symfony/routing/Matcher/Dumper/DumperRoute.php',
 2802      'Symfony\\Component\\Routing\\Matcher\\Dumper\\MatcherDumper' => $vendorDir . '/symfony/routing/Matcher/Dumper/MatcherDumper.php',
 2803      'Symfony\\Component\\Routing\\Matcher\\Dumper\\MatcherDumperInterface' => $vendorDir . '/symfony/routing/Matcher/Dumper/MatcherDumperInterface.php',
 ....
 2812      'Symfony\\Component\\Routing\\RequestContext' => $vendorDir . '/symfony/routing/RequestContext.php',
 2813      'Symfony\\Component\\Routing\\RequestContextAwareInterface' => $vendorDir . '/symfony/routing/RequestContextAwareInterface.php',
 2814:     'Symfony\\Component\\Routing\\Route' => $vendorDir . '/symfony/routing/Route.php',
 2815:     'Symfony\\Component\\Routing\\RouteCollection' => $vendorDir . '/symfony/routing/RouteCollection.php',
 2816:     'Symfony\\Component\\Routing\\RouteCollectionBuilder' => $vendorDir . '/symfony/routing/RouteCollectionBuilder.php',
 2817:     'Symfony\\Component\\Routing\\RouteCompiler' => $vendorDir . '/symfony/routing/RouteCompiler.php',
 2818:     'Symfony\\Component\\Routing\\RouteCompilerInterface' => $vendorDir . '/symfony/routing/RouteCompilerInterface.php',
 2819:     'Symfony\\Component\\Routing\\Router' => $vendorDir . '/symfony/routing/Router.php',
 2820:     'Symfony\\Component\\Routing\\RouterInterface' => $vendorDir . '/symfony/routing/RouterInterface.php',
 2821      'Symfony\\Component\\Translation\\Catalogue\\AbstractOperation' => $vendorDir . '/symfony/translation/Catalogue/AbstractOperation.php',
 2822      'Symfony\\Component\\Translation\\Catalogue\\MergeOperation' => $vendorDir . '/symfony/translation/Catalogue/MergeOperation.php',

/home/dila/Videos/HOWKEMASTER/vendor/composer/installed.json:
  754          "suggest": {
  755              "doctrine/annotations": "For using the annotation loader",
  756:             "symfony/config": "For using the all-in-one router or any loader",
  757:             "symfony/dependency-injection": "For loading routes from a service",
  758              "symfony/expression-language": "For using expression matching",
  759              "symfony/http-foundation": "For using a Symfony Request object",
  ...
  793          "homepage": "https://symfony.com",
  794          "keywords": [
  795:             "router",
  796              "routing",
  797              "uri",

/home/dila/Videos/HOWKEMASTER/vendor/fzaninotto/faker/src/Faker/Provider/File.php:
  198          'application/vnd.rn-realmedia'                                              => 'rm',
  199          'application/vnd.rn-realmedia-vbr'                                          => 'rmvb',
  200:         'application/vnd.route66.link66+xml'                                        => 'link66',
  201          'application/vnd.sailingtracker.track'                                      => 'st',
  202          'application/vnd.seemail'                                                   => 'see',

/home/dila/Videos/HOWKEMASTER/vendor/fzaninotto/faker/src/Faker/Provider/en_AU/Address.php:
   17  
   18      protected static $streetSuffix = array(
   19:         'Access', 'Alley', 'Alleyway', 'Amble', 'Anchorage', 'Approach', 'Arcade', 'Artery', 'Avenue', 'Basin', 'Beach', 'Bend', 'Block', 'Boulevard', 'Brace', 'Brae', 'Break', 'Bridge', 'Broadway', 'Brow', 'Bypass', 'Byway', 'Causeway', 'Centre', 'Centreway', 'Chase', 'Circle', 'Circlet', 'Circuit', 'Circus', 'Close', 'Colonnade', 'Common', 'Concourse', 'Copse', 'Corner', 'Corso', 'Court', 'Courtyard', 'Cove', 'Crescent', 'Crest', 'Cross', 'Crossing', 'Crossroad', 'Crossway', 'Cruiseway', 'Cul-de-sac', 'Cutting', 'Dale', 'Dell', 'Deviation', 'Dip', 'Distributor', 'Drive', 'Driveway', 'Edge', 'Elbow', 'End', 'Entrance', 'Esplanade', 'Estate', 'Expressway', 'Extension', 'Fairway', 'Fire Track', 'Firetrail', 'Flat', 'Follow', 'Footway', 'Foreshore', 'Formation', 'Freeway', 'Front', 'Frontage', 'Gap', 'Garden', 'Gardens', 'Gate', 'Gates', 'Glade', 'Glen', 'Grange', 'Green', 'Ground', 'Grove', 'Gully', 'Heights', 'Highroad', 'Highway', 'Hill', 'Interchange', 'Intersection', 'Junction', 'Key', 'Landing', 'Lane', 'Laneway', 'Lees', 'Line', 'Link', 'Little', 'Lookout', 'Loop', 'Lower', 'Mall', 'Meander', 'Mew', 'Mews', 'Motorway', 'Mount', 'Nook', 'Outlook', 'Parade', 'Park', 'Parklands', 'Parkway', 'Part', 'Pass', 'Path', 'Pathway', 'Piazza', 'Place', 'Plateau', 'Plaza', 'Pocket', 'Point', 'Port', 'Promenade', 'Quad', 'Quadrangle', 'Quadrant', 'Quay', 'Quays', 'Ramble', 'Ramp', 'Range', 'Reach', 'Reserve', 'Rest', 'Retreat', 'Ride', 'Ridge', 'Ridgeway', 'Right Of Way', 'Ring', 'Rise', 'River', 'Riverway', 'Riviera', 'Road', 'Roads', 'Roadside', 'Roadway', 'Ronde', 'Rosebowl', 'Rotary', 'Round', 'Route', 'Row', 'Rue', 'Run', 'Service Way', 'Siding', 'Slope', 'Sound', 'Spur', 'Square', 'Stairs', 'State Highway', 'Steps', 'Strand', 'Street', 'Strip', 'Subway', 'Tarn', 'Terrace', 'Thoroughfare', 'Tollway', 'Top', 'Tor', 'Towers', 'Track', 'Trail', 'Trailer', 'Triangle', 'Trunkway', 'Turn', 'Underpass', 'Upper', 'Vale', 'Viaduct', 'View', 'Villas', 'Vista', 'Wade', 'Walk', 'Walkway', 'Way', 'Wynd'
   20      );
   21  

/home/dila/Videos/HOWKEMASTER/vendor/fzaninotto/faker/src/Faker/Provider/en_GB/Address.php:
    9      protected static $buildingNumber = array('###', '##', '#');
   10      protected static $streetSuffix = array(
   11:         'Alley', 'Avenue', 'Branch', 'Bridge', 'Brook', 'Brooks', 'Burg', 'Burgs', 'Bypass', 'Camp', 'Canyon', 'Cape', 'Causeway', 'Center', 'Centers', 'Circle', 'Circles', 'Cliff', 'Cliffs', 'Club', 'Common', 'Corner', 'Corners', 'Course', 'Court', 'Courts', 'Cove', 'Coves', 'Creek', 'Crescent', 'Crest', 'Crossing', 'Crossroad', 'Curve', 'Dale', 'Dam', 'Divide', 'Drive', 'Drive', 'Drives', 'Estate', 'Estates', 'Expressway', 'Extension', 'Extensions', 'Fall', 'Falls', 'Ferry', 'Field', 'Fields', 'Flat', 'Flats', 'Ford', 'Fords', 'Forest', 'Forge', 'Forges', 'Fork', 'Forks', 'Fort', 'Garden', 'Gardens', 'Gateway', 'Glen', 'Glens', 'Green', 'Greens', 'Grove', 'Groves', 'Harbour', 'Harbours', 'Haven', 'Heights', 'Highway', 'Hill', 'Hills', 'Hollow', 'Inlet', 'Island', 'Islands', 'Isle', 'Junction', 'Junctions', 'Key', 'Keys', 'Knoll', 'Knolls', 'Lake', 'Lakes', 'Land', 'Landing', 'Lane', 'Light', 'Lights', 'Loaf', 'Lock', 'Locks', 'Locks', 'Lodge', 'Lodge', 'Loop', 'Manor', 'Manors', 'Meadow', 'Meadows', 'Mews', 'Mill', 'Mills', 'Motorway', 'Mount', 'Mountain', 'Mountains', 'Neck', 'Orchard', 'Oval', 'Overpass', 'Park', 'Parks', 'Parkway', 'Parkways', 'Pass', 'Passage', 'Path', 'Pike', 'Pine', 'Pines', 'Place', 'Plain', 'Plains', 'Plaza', 'Point', 'Points', 'Port', 'Ports', 'Radial', 'Ramp', 'Ranch', 'Rapid', 'Rapids', 'Rest', 'Ridge', 'Ridges', 'River', 'Road', 'Road', 'Roads', 'Roads', 'Route', 'Row', 'Rue', 'Run', 'Shoal', 'Shoals', 'Shore', 'Shores', 'Spring', 'Springs', 'Springs', 'Spur', 'Spurs', 'Square', 'Square', 'Squares', 'Squares', 'Station', 'Station', 'Stream', 'Stream', 'Street', 'Streets', 'Summit', 'Terrace', 'Throughway', 'Trace', 'Track', 'Trafficway', 'Trail', 'Tunnel', 'Turnpike', 'Underpass', 'Union', 'Unions', 'Valley', 'Valleys', 'Via', 'Viaduct', 'View', 'Views', 'Village', 'Villages', 'Ville', 'Vista', 'Vista', 'Walk', 'Walks', 'Wall', 'Way', 'Ways', 'Well', 'Wells'
   12      );
   13      protected static $postcode = array('?# #??', '?## #??', '??# #??', '??## #??', '?#? #??', '??#? #??');

/home/dila/Videos/HOWKEMASTER/vendor/fzaninotto/faker/src/Faker/Provider/en_US/Address.php:
    9      protected static $buildingNumber = array('%####', '%###', '%##');
   10      protected static $streetSuffix = array(
   11:         'Alley', 'Avenue', 'Branch', 'Bridge', 'Brook', 'Brooks', 'Burg', 'Burgs', 'Bypass', 'Camp', 'Canyon', 'Cape', 'Causeway', 'Center', 'Centers', 'Circle', 'Circles', 'Cliff', 'Cliffs', 'Club', 'Common', 'Corner', 'Corners', 'Course', 'Court', 'Courts', 'Cove', 'Coves', 'Creek', 'Crescent', 'Crest', 'Crossing', 'Crossroad', 'Curve', 'Dale', 'Dam', 'Divide', 'Drive', 'Drive', 'Drives', 'Estate', 'Estates', 'Expressway', 'Extension', 'Extensions', 'Fall', 'Falls', 'Ferry', 'Field', 'Fields', 'Flat', 'Flats', 'Ford', 'Fords', 'Forest', 'Forge', 'Forges', 'Fork', 'Forks', 'Fort', 'Freeway', 'Garden', 'Gardens', 'Gateway', 'Glen', 'Glens', 'Green', 'Greens', 'Grove', 'Groves', 'Harbor', 'Harbors', 'Haven', 'Heights', 'Highway', 'Hill', 'Hills', 'Hollow', 'Inlet', 'Inlet', 'Island', 'Island', 'Islands', 'Islands', 'Isle', 'Isle', 'Junction', 'Junctions', 'Key', 'Keys', 'Knoll', 'Knolls', 'Lake', 'Lakes', 'Land', 'Landing', 'Lane', 'Light', 'Lights', 'Loaf', 'Lock', 'Locks', 'Locks', 'Lodge', 'Lodge', 'Loop', 'Mall', 'Manor', 'Manors', 'Meadow', 'Meadows', 'Mews', 'Mill', 'Mills', 'Mission', 'Mission', 'Motorway', 'Mount', 'Mountain', 'Mountain', 'Mountains', 'Mountains', 'Neck', 'Orchard', 'Oval', 'Overpass', 'Park', 'Parks', 'Parkway', 'Parkways', 'Pass', 'Passage', 'Path', 'Pike', 'Pine', 'Pines', 'Place', 'Plain', 'Plains', 'Plains', 'Plaza', 'Plaza', 'Point', 'Points', 'Port', 'Port', 'Ports', 'Ports', 'Prairie', 'Prairie', 'Radial', 'Ramp', 'Ranch', 'Rapid', 'Rapids', 'Rest', 'Ridge', 'Ridges', 'River', 'Road', 'Road', 'Roads', 'Roads', 'Route', 'Row', 'Rue', 'Run', 'Shoal', 'Shoals', 'Shore', 'Shores', 'Skyway', 'Spring', 'Springs', 'Springs', 'Spur', 'Spurs', 'Square', 'Square', 'Squares', 'Squares', 'Station', 'Station', 'Stravenue', 'Stravenue', 'Stream', 'Stream', 'Street', 'Street', 'Streets', 'Summit', 'Summit', 'Terrace', 'Throughway', 'Trace', 'Track', 'Trafficway', 'Trail', 'Trail', 'Tunnel', 'Tunnel', 'Turnpike', 'Turnpike', 'Underpass', 'Union', 'Unions', 'Valley', 'Valleys', 'Via', 'Viaduct', 'View', 'Views', 'Village', 'Village', 'Villages', 'Ville', 'Vista', 'Vista', 'Walk', 'Walks', 'Wall', 'Way', 'Ways', 'Well', 'Wells'
   12      );
   13      protected static $postcode = array('#####', '#####-####');

/home/dila/Videos/HOWKEMASTER/vendor/fzaninotto/faker/src/Faker/Provider/en_ZA/Address.php:
    9      protected static $buildingNumber = array('#####', '####', '###');
   10      protected static $streetSuffix = array(
   11:         'Alley', 'Avenue', 'Branch', 'Bridge', 'Brook', 'Brooks', 'Burg', 'Burgs', 'Bypass', 'Camp', 'Canyon', 'Cape', 'Causeway', 'Center', 'Centers', 'Circle', 'Circles', 'Cliff', 'Cliffs', 'Club', 'Common', 'Corner', 'Corners', 'Course', 'Court', 'Courts', 'Cove', 'Coves', 'Creek', 'Crescent', 'Crest', 'Crossing', 'Crossroad', 'Curve', 'Dale', 'Dam', 'Divide', 'Drive', 'Drive', 'Drives', 'Estate', 'Estates', 'Expressway', 'Extension', 'Extensions', 'Fall', 'Falls', 'Ferry', 'Field', 'Fields', 'Flat', 'Flats', 'Ford', 'Fords', 'Forest', 'Forge', 'Forges', 'Fork', 'Forks', 'Fort', 'Freeway', 'Garden', 'Gardens', 'Gateway', 'Glen', 'Glens', 'Green', 'Greens', 'Grove', 'Groves', 'Harbor', 'Harbors', 'Haven', 'Heights', 'Highway', 'Hill', 'Hills', 'Hollow', 'Inlet', 'Inlet', 'Island', 'Island', 'Islands', 'Islands', 'Isle', 'Isle', 'Junction', 'Junctions', 'Key', 'Keys', 'Knoll', 'Knolls', 'Lake', 'Lakes', 'Land', 'Landing', 'Lane', 'Light', 'Lights', 'Loaf', 'Lock', 'Locks', 'Locks', 'Lodge', 'Lodge', 'Loop', 'Mall', 'Manor', 'Manors', 'Meadow', 'Meadows', 'Mews', 'Mill', 'Mills', 'Mission', 'Mission', 'Motorway', 'Mount', 'Mountain', 'Mountain', 'Mountains', 'Mountains', 'Neck', 'Orchard', 'Oval', 'Overpass', 'Park', 'Parks', 'Parkway', 'Parkways', 'Pass', 'Passage', 'Path', 'Pike', 'Pine', 'Pines', 'Place', 'Plain', 'Plains', 'Plains', 'Plaza', 'Plaza', 'Point', 'Points', 'Port', 'Port', 'Ports', 'Ports', 'Prairie', 'Prairie', 'Radial', 'Ramp', 'Ranch', 'Rapid', 'Rapids', 'Rest', 'Ridge', 'Ridges', 'River', 'Road', 'Road', 'Roads', 'Roads', 'Route', 'Row', 'Rue', 'Run', 'Shoal', 'Shoals', 'Shore', 'Shores', 'Skyway', 'Spring', 'Springs', 'Springs', 'Spur', 'Spurs', 'Square', 'Square', 'Squares', 'Squares', 'Station', 'Station', 'Stravenue', 'Stravenue', 'Stream', 'Stream', 'Street', 'Street', 'Streets', 'Summit', 'Summit', 'Terrace', 'Throughway', 'Trace', 'Track', 'Trafficway', 'Trail', 'Trail', 'Tunnel', 'Tunnel', 'Turnpike', 'Turnpike', 'Underpass', 'Union', 'Unions', 'Valley', 'Valleys', 'Via', 'Viaduct', 'View', 'Views', 'Village', 'Village', 'Villages', 'Ville', 'Vista', 'Vista', 'Walk', 'Walks', 'Wall', 'Way', 'Ways', 'Well', 'Wells',
   12      );
   13      protected static $postcode = array('####');

/home/dila/Videos/HOWKEMASTER/vendor/fzaninotto/faker/src/Faker/Provider/fr_CA/Address.php:
   52  
   53      protected static $streetSuffix = array(
   54:         'Autoroute', 'Avenue', 'Boulevard', 'Chemin', 'Route', 'Rue', 'Pont'
   55      );
   56  

/home/dila/Videos/HOWKEMASTER/vendor/fzaninotto/faker/src/Faker/Provider/fr_FR/Text.php:
  455  
  456  Vers quatre heures du matin, Charles, bien enveloppé dans son
  457: manteau, se mit en route pour les Bertaux. Encore endormi par la
  458  chaleur du sommeil, il se laissait bercer au trot pacifique de sa
  459  bête. Quand elle s'arrêtait d'elle-même devant ces trous entourés
  ...
 1019  avaient des balafres en diagonale sous le nez, ou, le long des
 1020  mâchoires, des pelures d'épiderme larges comme des écus de trois
 1021: francs, et qu'avait enflammées le grand air pendant la route, ce
 1022  qui marbrait un peu de plaques roses toutes ces grosses faces
 1023  blanches épanouies.
 ....
 1092  brancards; ils ruaient, se cabraient, les harnais se cassaient,
 1093  leurs maîtres juraient ou riaient; et toute la nuit, au clair de
 1094: la lune, par les routes du pays, il y eut des carrioles emportées
 1095  qui couraient au grand galop, bondissant dans les saignées,
 1096  sautant par-dessus les mètres de cailloux, s'accrochant aux talus,
 ....
 1144  père Rouault les fit reconduire dans sa carriole et les accompagna
 1145  lui-même jusqu'à Vassonville. Là, il embrassa sa fille une
 1146: dernière fois, mit pied à terre et reprit sa route. Lorsqu'il eut
 1147  fait cent pas environ, il s'arrêta, et, comme il vit la carriole
 1148  s'éloignant, dont les roues tournaient dans la poussière, il
 ....
 1160  lui mettait, de temps en temps, dans la poitrine. Comme c'était
 1161  vieux tout cela! Leur fils, à présent, aurait trente ans! Alors il
 1162: regarda derrière lui, il n'aperçut rien sur la route. Il se sentit
 1163  triste comme une maison démeublée; et, les souvenirs tendres se
 1164  mêlant aux pensées noires dans sa cervelle obscurcie par les
 ....
 1180  
 1181  La façade de briques était juste à l'alignement de la rue, ou de
 1182: la route plutôt. Derrière la porte se trouvaient accrochés un
 1183  manteau à petit collet, une bride, une casquette de cuir noir, et,
 1184  dans un coin, à terre, une paire de houseaux encore couverts de
 ....
 1239  
 1240  Il était donc heureux et sans souci de rien au monde. Un repas en
 1241: tête-à-tête, une promenade le soir sur la grande route, un geste
 1242  de sa main sur ses bandeaux, la vue de son chapeau de paille
 1243  accroché à l'espagnolette d'une fenêtre, et bien d'autres choses
 ....
 1265  porte. Charles, à cheval, lui envoyait un baiser; elle répondait
 1266  par un signe, elle refermait la fenêtre, il partait. Et alors, sur
 1267: la grande route qui étendait sans en finir son long ruban de
 1268  poussière, par les chemins creux où les arbres se courbaient en
 1269  berceaux, dans les sentiers dont les blés lui montaient jusqu'aux
 ....
 1511  noms sonores où les lendemains de mariage ont de plus suaves
 1512  paresses! Dans des chaises de poste, sous des stores de soie
 1513: bleue, on monte au pas des routes escarpées, écoutant la chanson
 1514  du postillon, qui se répète dans la montagne avec les clochettes
 1515  des chèvres et le bruit sourd de la cascade. Quand le soleil se
 ....
 1563  frisaient, s'entendait jusqu'au bout du village si la fenêtre
 1564  était ouverte, et souvent le clerc de l'huissier qui passait sur
 1565: la grande route, nu-tête et en chaussons, s'arrêtait à l'écouter,
 1566  sa feuille de papier à la main.
 1567  
 ....
 1657  pour se promener, car elle sortait quelquefois, afin d'être seule
 1658  un instant et de n'avoir plus sous les yeux l'éternel jardin avec
 1659: la route poudreuse.
 1660  
 1661  Elle allait jusqu'à la hêtraie de Banneville, près du pavillon
 ....
 1727  colonnade brune se détachant sur un fond d'or; une peur la
 1728  prenait, elle appelait Djali, s'en retournait vite à Tostes par la
 1729: grande route, s'affaissait dans un fauteuil, et de toute la soirée
 1730  ne parlait pas.
 1731  
 ....
 1738  candidature à la Chambre des députés. Il faisait, l'hiver, de
 1739  nombreuses distributions de fagots, et, au Conseil général,
 1740: réclamait avec exaltation toujours des routes pour son
 1741  arrondissement. Il avait eu, lors des grandes chaleurs, un abcès
 1742  dans la bouche, dont Charles l'avait soulagé comme par miracle, en
 ....
 2211  
 2212  Et elle les suivait dans sa pensée, montant et descendant les
 2213: côtes, traversant les villages, filant sur la grande route à la
 2214  clarté des étoiles. Au bout d'une distance indéterminée, il se
 2215  trouvait toujours une place confuse où expirait son rêve.
 ....
 2452  coups fêlés de la cloche. Quelque chat sur les toits, marchant
 2453  lentement, bombait son dos aux rayons pâles du soleil. Le vent,
 2454: sur la grande route, soufflait des traînées de poussière. Au loin,
 2455  parfois, un chien hurlait: et la cloche, à temps égaux, continuait
 2456  sa sonnerie monotone qui se perdait dans la campagne.
 ....
 2642  Yonville-l'Abbaye (ainsi nommé à cause d'une ancienne abbaye de
 2643  Capucins dont les ruines n'existent même plus) est un bourg à huit
 2644: lieues de Rouen, entre la route d'Abbeville et celle de Beauvais,
 2645  au fond d'une vallée qu'arrose la Rieule, petite rivière qui se
 2646  jette dans l'Andelle, après avoir fait tourner trois moulins vers
 ....
 2648  dimanche, s'amusent à pêcher à la ligne.
 2649  
 2650: On quitte la grande route à la Boissière et l'on continue à plat
 2651  jusqu'au haut de la côte des Leux, d'où l'on découvre la vallée.
 2652  La rivière qui la traverse en fait comme deux régions de
 ....
 2677  sable et de cailloux.
 2678  
 2679: Jusqu'en 1835, il n'y avait point de route praticable pour arriver
 2680  à Yonville; mais on a établi vers cette époque un chemin de grande
 2681: vicinalité qui relie la route d'Abbeville à celle d'Amiens, et
 2682  sert quelquefois aux rouliers allant de Rouen dans les Flandres.
 2683  Cependant, Yonville-l'Abbaye est demeuré stationnaire, malgré ses
 ....
 2708  balai; il y a la forge d'un maréchal et ensuite un charron avec
 2709  deux ou trois charrettes neuves, en dehors, qui empiètent sur la
 2710: route. Puis, à travers une claire-voie, apparaît une maison
 2711  blanche au delà d'un rond de gazon que décore un Amour, le doigt
 2712  posé sur la bouche; deux vases en fonte sont à chaque bout du
 ....
 2767  Il n'y a plus ensuite rien à voir dans Yonville. La rue (la
 2768  seule), longue d'une portée de fusil et bordée de quelques
 2769: boutiques, s'arrête court au tournant de la route. Si on la laisse
 2770  sur la droite et que l'on suive le bas de la côte Saint-Jean,
 2771  bientôt on arrive au cimetière.
 ....
 2999  C'était un coffre jaune porté par deux grandes roues qui, montant
 3000  jusqu'à la hauteur de la bâche, empêchaient les voyageurs de voir
 3001: la route et leur salissaient les épaules. Les petits carreaux de
 3002  ses vasistas étroits tremblaient dans leurs châssis quand la
 3003  voiture était fermée, et gardaient des taches de boue, çà et là,
 ....
 3014  cordonnier, de la ferraille au maréchal, un baril de harengs pour
 3015  sa maîtresse, des bonnets de chez la modiste, des toupets de chez
 3016: le coiffeur; et, le long de la route, en s'en revenant, il
 3017  distribuait ses paquets, qu'il jetait par-dessus les clôtures des
 3018  cours, debout sur son siège, et criant à pleine poitrine, pendant
 ....
 3023  d'heure. Hivert même était retourné d'une demi-lieue en arrière,
 3024  croyant l'apercevoir à chaque minute; mais il avait fallu
 3025: continuer la route. Emma avait pleuré, s'était emportée; elle
 3026  avait accusé Charles de ce malheur. M. Lheureux, marchand
 3027  d'étoffes, qui se trouvait avec elle dans la voiture, avait essayé
 ....
 3094  
 3095  -- Du reste, disait l'apothicaire, l'exercice de la médecine n'est
 3096: pas fort pénible en nos contrées; car l'état de nos routes permet
 3097  l'usage du cabriolet, et, généralement, l'on paye assez bien, les
 3098  cultivateurs étant aisés. Nous avons, sous le rapport médical, à
 ....
 3537  duraient encore, elle s'achemina vers la demeure de Rolet, qui se
 3538  trouvait à l'extrémité du village, au bas de la côte, entre la
 3539: grande route et les prairies.
 3540  
 3541  Il était midi; les maisons avaient leurs volets fermés, et les
 ....
 4823  se mit à courir.
 4824  
 4825: Il aperçut de loin, sur la route, le cabriolet de son patron, et à
 4826  côté un homme en serpillière qui tenait le cheval. Homais et
 4827  M. Guillaumin causaient ensemble. On l'attendait.
 ....
 5534  
 5535  Quand ils furent devant la maison du maréchal, au lieu de suivre
 5536: la route jusqu'à la barrière, Rodolphe, brusquement, prit un
 5537  sentier, entraînant madame Bovary; il cria:
 5538  
 ....
 6000  traînant après soi un long panache de poussière. C'était dans
 6001  cette voiture jaune que Léon, si souvent, était revenu vers elle;
 6002: et par cette route là-bas qu'il était parti pour toujours! Elle
 6003  crut le voir en face, à sa fenêtre; puis tout se confondit, des
 6004  nuages passèrent; il lui sembla qu'elle tournait encore dans la
 ....
 7186  l'amour; -- les perdant ainsi continuellement le long de sa vie,
 7187  comme un voyageur qui laisse quelque chose de sa richesse à toutes
 7188: les auberges de la route.
 7189  
 7190  Mais qui donc la rendait si malheureuse? où était la catastrophe
 ....
 7870  voyait comme autrefois parcourir le village, et quand Charles
 7871  entendait de loin, sur les pavés, le bruit sec de son bâton, il
 7872: prenait bien vite une autre route.
 7873  
 7874  C'était M. Lheureux, le marchand, qui s'était chargé de la
 ....
 7936  pour se faire un cache-nez, et enfin un porte-cigares tout pareil
 7937  à celui du Vicomte, que Charles avait autrefois ramassé sur la
 7938: route et qu'Emma conservait. Cependant ces cadeaux l'humiliaient.
 7939  Il en refusa plusieurs; elle insista, et Rodolphe finit par obéir,
 7940  la trouvant tyrannique et trop envahissante.
 ....
 8246  écrit à Paris, afin d'avoir la malle entière jusqu'à Marseille, où
 8247  ils achèteraient une calèche et, de là, continueraient sans
 8248: s'arrêter, par la route de Gênes. Elle aurait eu soin d'envoyer
 8249  chez Lheureux son bagage, qui serait directement porté à
 8250  l'Hirondelle, de manière que personne ainsi n'aurait de soupçons;
 ....
 8809  continuellement à lui tâter le pouls, à lui poser des sinapismes,
 8810  des compresses d'eau froide. Il envoyait Justin jusqu'à Neufchâtel
 8811: chercher de la glace; la glace se fondait en route; il le
 8812  renvoyait. Il appela M. Canivet en consultation; il fit venir de
 8813  Rouen le docteur Larivière, son ancien maître; il était désespéré.
 ....
 10303  -- Où vous voudrez! dit Léon poussant Emma dans la voiture.
 10304  
 10305: Et la lourde machine se mit en route
 10306  
 10307  Elle descendit la rue Grand-Pont, traversa la place des Arts, le
 .....
 11118  
 11119  Cependant les quatre banquettes se garnissaient, la voiture
 11120: roulait, les pommiers à la file se succédaient; et la route, entre
 11121  ses deux longs fossés pleins d'eau jaune, allait continuellement
 11122  se rétrécissant vers l'horizon.
 .....
 11164  chevaux galopaient, les pierres grinçaient dans la boue, la
 11165  diligence se balançait, et Hivert, de loin, hélait les carrioles
 11166: sur la route, tandis que les bourgeois qui avaient passé la nuit
 11167  au bois Guillaume descendaient la côte tranquillement, dans leur
 11168  petite voiture de famille.
 .....
 11760  tête, et la petite Berthe, ne voulant pas se coucher sans sa
 11761  maman, sanglotait à se rompre la poitrine. Justin était parti au
 11762: hasard sur la route. M. Homais en avait quitté sa pharmacie.
 11763  
 11764  Enfin, à onze heures, n'y tenant plus, Charles attela son boc,
 .....
 13080  
 13081  -- Quel misérable! quel goujat!... quelle infamie! se disait-elle,
 13082: en fuyant d'un pied nerveux sous les trembles de la route. Le
 13083  désappointement de l'insuccès renforçait l'indignation de sa
 13084  pudeur outragée; il lui semblait que la Providence s'acharnait à
 .....
 13258  tours de promenade dans le jardin, pas à pas; elle alla dans le
 13259  sentier le long de la haie, et s'en retourna vivement, espérant
 13260: que la bonne femme serait rentrée par une autre route. Enfin,
 13261  lasse d'attendre, assaillie de soupçons qu'elle repoussait, ne
 13262  sachant plus si elle était là depuis un siècle ou une minute, elle
 .....
 13464  
 13465  -- Mais, moi, je t'aurais tout donné, j'aurais tout vendu,
 13466: j'aurais travaillé de mes mains, j'aurais mendié sur les routes,
 13467  pour un sourire, pour un regard, pour t'entendre dire: «Merci!» Et
 13468  tu restes là tranquillement dans ton fauteuil, comme si déjà tu ne
 .....
 13601  jusqu'à six heures du soir. Enfin, n'y pouvant plus tenir, et
 13602  imaginant qu'elle était partie pour Rouen, il alla sur la grande
 13603: route, fit une demi-lieue, ne rencontra personne, attendit encore
 13604  et s'en revint.
 13605  
 .....
 14539  Enfin il avait passé sa blouse, pris son chapeau, accroché un
 14540  éperon à son soulier et était parti ventre à terre; et, tout le
 14541: long de la route, le père Rouault, haletant, se dévora
 14542  d'angoisses. Une fois même, il fut obligé de descendre. Il n'y
 14543  voyait plus, il entendait des voix autour de lui, il se sentait
 .....
 14560  
 14561  Puis elle lui apparaissait morte. Elle était là, devant lui,
 14562: étendue sur le dos, au milieu de la route. Il tirait la bride et
 14563  l'hallucination disparaissait.
 14564  
 .....
 14733  En rentrant, Charles se déshabilla, et le père Rouault repassa sa
 14734  blouse bleue. Elle était neuve, et, comme il s'était, pendant la
 14735: route, souvent essuyé les yeux avec les manches, elle avait
 14736  déteint sur sa figure; et la trace des pleurs y faisait des lignes
 14737  dans la couche de poussière qui la salissait.
 .....
 14765  mit sa main devant ses yeux; et il aperçut à l'horizon un enclos
 14766  de murs où des arbres, çà et là, faisaient des bouquets noirs
 14767: entre des pierres blanches, puis il continua sa route, au petit
 14768  trot, car son bidet boitait.
 14769  

/home/dila/Videos/HOWKEMASTER/vendor/fzaninotto/faker/src/Faker/Provider/sk_SK/Address.php:
  298      protected static $buildingNumber = array('#####', '####', '###');
  299      protected static $streetSuffix = array(
  300:         'Alley','Avenue','Branch','Bridge','Brook','Brooks','Burg','Burgs','Bypass','Camp','Canyon','Cape','Causeway','Center','Centers','Circle','Circles','Cliff','Cliffs','Club','Common','Corner','Corners','Course','Court','Courts','Cove','Coves','Creek','Crescent','Crest','Crossing','Crossroad','Curve','Dale','Dam','Divide','Drive','Drive','Drives','Estate','Estates','Expressway','Extension','Extensions','Fall','Falls','Ferry','Field','Fields','Flat','Flats','Ford','Fords','Forest','Forge','Forges','Fork','Forks','Fort','Freeway','Garden','Gardens','Gateway','Glen','Glens','Green','Greens','Grove','Groves','Harbor','Harbors','Haven','Heights','Highway','Hill','Hills','Hollow','Inlet','Inlet','Island','Island','Islands','Islands','Isle','Isle','Junction','Junctions','Key','Keys','Knoll','Knolls','Lake','Lakes','Land','Landing','Lane','Light','Lights','Loaf','Lock','Locks','Locks','Lodge','Lodge','Loop','Mall','Manor','Manors','Meadow','Meadows','Mews','Mill','Mills','Mission','Mission','Motorway','Mount','Mountain','Mountain','Mountains','Mountains','Neck','Orchard','Oval','Overpass','Park','Parks','Parkway','Parkways','Pass','Passage','Path','Pike','Pine','Pines','Place','Plain','Plains','Plains','Plaza','Plaza','Point','Points','Port','Port','Ports','Ports','Prairie','Prairie','Radial','Ramp','Ranch','Rapid','Rapids','Rest','Ridge','Ridges','River','Road','Road','Roads','Roads','Route','Row','Rue','Run','Shoal','Shoals','Shore','Shores','Skyway','Spring','Springs','Springs','Spur','Spurs','Square','Square','Squares','Squares','Station','Station','Stravenue','Stravenue','Stream','Stream','Street','Street','Streets','Summit','Summit','Terrace','Throughway','Trace','Track','Trafficway','Trail','Trail','Tunnel','Tunnel','Turnpike','Turnpike','Underpass','Union','Unions','Valley','Valleys','Via','Viaduct','View','Views','Village','Village','Villages','Ville','Vista','Vista','Walk','Walks','Wall','Way','Ways','Well','Wells'
  301      );
  302      protected static $postcode = array('### ##');

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Auth/Console/MakeAuthCommand.php:
   24       * @var string
   25       */
   26:     protected $description = 'Scaffold basic login and registration views and routes';
   27  
   28      /**
   ..
   58  
   59              file_put_contents(
   60:                 base_path('routes/web.php'),
   61:                 file_get_contents(__DIR__.'/stubs/make/routes.stub'),
   62                  FILE_APPEND
   63              );

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Auth/Console/stubs/make/routes.stub:
    1  
    2: Auth::routes();
    3  
    4: Route::get('/home', 'HomeController@index')->name('home');
    5  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Auth/Console/stubs/make/views/auth/login.stub:
    8                  <div class="panel-heading">Login</div>
    9                  <div class="panel-body">
   10:                     <form class="form-horizontal" method="POST" action="{{ route('login') }}">
   11                          {{ csrf_field() }}
   12  
   ..
   55                                  </button>
   56  
   57:                                 <a class="btn btn-link" href="{{ route('password.request') }}">
   58                                      Forgot Your Password?
   59                                  </a>

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Auth/Console/stubs/make/views/auth/passwords/email.stub:
   14                      @endif
   15  
   16:                     <form class="form-horizontal" method="POST" action="{{ route('password.email') }}">
   17                          {{ csrf_field() }}
   18  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Auth/Console/stubs/make/views/auth/passwords/reset.stub:
   15                      @endif
   16  
   17:                     <form class="form-horizontal" method="POST" action="{{ route('password.request') }}">
   18                          {{ csrf_field() }}
   19  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Auth/Console/stubs/make/views/auth/register.stub:
    8                  <div class="panel-heading">Register</div>
    9                  <div class="panel-body">
   10:                     <form class="form-horizontal" method="POST" action="{{ route('register') }}">
   11                          {{ csrf_field() }}
   12  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Auth/Console/stubs/make/views/layouts/app.stub:
   44                          <!-- Authentication Links -->
   45                          @if (Auth::guest())
   46:                             <li><a href="{{ route('login') }}">Login</a></li>
   47:                             <li><a href="{{ route('register') }}">Register</a></li>
   48                          @else
   49                              <li class="dropdown">
   ..
   54                                  <ul class="dropdown-menu" role="menu">
   55                                      <li>
   56:                                         <a href="{{ route('logout') }}"
   57                                              onclick="event.preventDefault();
   58                                                       document.getElementById('logout-form').submit();">
   ..
   60                                          </a>
   61  
   62:                                         <form id="logout-form" action="{{ route('logout') }}" method="POST" style="display: none;">
   63                                              {{ csrf_field() }}
   64                                          </form>

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Auth/Middleware/Authorize.php:
   85      protected function getModel($request, $model)
   86      {
   87:         return $this->isClassName($model) ? $model : $request->route($model);
   88      }
   89  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Auth/Notifications/ResetPassword.php:
   47          return (new MailMessage)
   48              ->line('You are receiving this email because we received a password reset request for your account.')
   49:             ->action('Reset Password', url(config('app.url').route('password.reset', $this->token, false)))
   50              ->line('If you did not request a password reset, no further action is required.');
   51      }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Broadcasting/BroadcastManager.php:
   50  
   51      /**
   52:      * Register the routes for handling broadcast authentication and sockets.
   53       *
   54       * @param  array|null  $attributes
   55       * @return void
   56       */
   57:     public function routes(array $attributes = null)
   58      {
   59:         if ($this->app->routesAreCached()) {
   60              return;
   61          }
   ..
   63          $attributes = $attributes ?: ['middleware' => ['web']];
   64  
   65:         $this->app['router']->group($attributes, function ($router) {
   66:             $router->post('/broadcasting/auth', BroadcastController::class.'@authenticate');
   67          });
   68      }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Broadcasting/Broadcasters/Broadcaster.php:
  151              $model = $parameter->getClass()->newInstance();
  152  
  153:             return $model->where($model->getRouteKeyName(), $value)->firstOr(function () {
  154                  throw new HttpException(403);
  155              });

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Contracts/Routing/BindingRegistrar.php:
    6  {
    7      /**
    8:      * Add a new route parameter binder.
    9       *
   10       * @param  string  $key

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Contracts/Routing/Registrar.php:
    6  {
    7      /**
    8:      * Register a new GET route with the router.
    9       *
   10       * @param  string  $uri
   11       * @param  \Closure|array|string  $action
   12:      * @return \Illuminate\Routing\Route
   13       */
   14      public function get($uri, $action);
   15  
   16      /**
   17:      * Register a new POST route with the router.
   18       *
   19       * @param  string  $uri
   20       * @param  \Closure|array|string  $action
   21:      * @return \Illuminate\Routing\Route
   22       */
   23      public function post($uri, $action);
   24  
   25      /**
   26:      * Register a new PUT route with the router.
   27       *
   28       * @param  string  $uri
   29       * @param  \Closure|array|string  $action
   30:      * @return \Illuminate\Routing\Route
   31       */
   32      public function put($uri, $action);
   33  
   34      /**
   35:      * Register a new DELETE route with the router.
   36       *
   37       * @param  string  $uri
   38       * @param  \Closure|array|string  $action
   39:      * @return \Illuminate\Routing\Route
   40       */
   41      public function delete($uri, $action);
   42  
   43      /**
   44:      * Register a new PATCH route with the router.
   45       *
   46       * @param  string  $uri
   47       * @param  \Closure|array|string  $action
   48:      * @return \Illuminate\Routing\Route
   49       */
   50      public function patch($uri, $action);
   51  
   52      /**
   53:      * Register a new OPTIONS route with the router.
   54       *
   55       * @param  string  $uri
   56       * @param  \Closure|array|string  $action
   57:      * @return \Illuminate\Routing\Route
   58       */
   59      public function options($uri, $action);
   60  
   61      /**
   62:      * Register a new route with the given verbs.
   63       *
   64       * @param  array|string  $methods
   65       * @param  string  $uri
   66       * @param  \Closure|array|string  $action
   67:      * @return \Illuminate\Routing\Route
   68       */
   69      public function match($methods, $uri, $action);
   70  
   71      /**
   72:      * Route a resource to a controller.
   73       *
   74       * @param  string  $name
   ..
   80  
   81      /**
   82:      * Create a route group with shared attributes.
   83       *
   84       * @param  array  $attributes
   85:      * @param  \Closure|string  $routes
   86       * @return void
   87       */
   88:     public function group(array $attributes, $routes);
   89  
   90      /**
   91:      * Substitute the route bindings onto the route.
   92       *
   93:      * @param  \Illuminate\Routing\Route  $route
   94:      * @return \Illuminate\Routing\Route
   95       */
   96:     public function substituteBindings($route);
   97  
   98      /**
   99:      * Substitute the implicit Eloquent model bindings for the route.
  100       *
  101:      * @param  \Illuminate\Routing\Route  $route
  102       * @return void
  103       */
  104:     public function substituteImplicitBindings($route);
  105  }
  106  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Contracts/Routing/ResponseFactory.php:
   82  
   83      /**
   84:      * Create a new redirect response to a named route.
   85       *
   86:      * @param  string  $route
   87       * @param  array  $parameters
   88       * @param  int  $status
   ..
   90       * @return \Illuminate\Http\RedirectResponse
   91       */
   92:     public function redirectToRoute($route, $parameters = [], $status = 302, $headers = []);
   93  
   94      /**

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Contracts/Routing/UrlGenerator.php:
   41  
   42      /**
   43:      * Get the URL to a named route.
   44       *
   45       * @param  string  $name
   ..
   50       * @throws \InvalidArgumentException
   51       */
   52:     public function route($name, $parameters = [], $absolute = true);
   53  
   54      /**

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Contracts/Routing/UrlRoutable.php:
    6  {
    7      /**
    8:      * Get the value of the model's route key.
    9       *
   10       * @return mixed
   11       */
   12:     public function getRouteKey();
   13  
   14      /**
   15:      * Get the route key for the model.
   16       *
   17       * @return string
   18       */
   19:     public function getRouteKeyName();
   20  }
   21  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php:
 1200  
 1201      /**
 1202:      * Get the value of the model's route key.
 1203       *
 1204       * @return mixed
 1205       */
 1206:     public function getRouteKey()
 1207      {
 1208:         return $this->getAttribute($this->getRouteKeyName());
 1209      }
 1210  
 1211      /**
 1212:      * Get the route key for the model.
 1213       *
 1214       * @return string
 1215       */
 1216:     public function getRouteKeyName()
 1217      {
 1218          return $this->getKeyName();

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/Application.php:
  879  
  880      /**
  881:      * Determine if the application routes are cached.
  882       *
  883       * @return bool
  884       */
  885:     public function routesAreCached()
  886      {
  887:         return $this['files']->exists($this->getCachedRoutesPath());
  888      }
  889  
  890      /**
  891:      * Get the path to the routes cache file.
  892       *
  893       * @return string
  894       */
  895:     public function getCachedRoutesPath()
  896      {
  897:         return $this->bootstrapPath().'/cache/routes.php';
  898      }
  899  
  ...
 1121              'redis'                => [\Illuminate\Redis\RedisManager::class, \Illuminate\Contracts\Redis\Factory::class],
 1122              'request'              => [\Illuminate\Http\Request::class, \Symfony\Component\HttpFoundation\Request::class],
 1123:             'router'               => [\Illuminate\Routing\Router::class, \Illuminate\Contracts\Routing\Registrar::class, \Illuminate\Contracts\Routing\BindingRegistrar::class],
 1124              'session'              => [\Illuminate\Session\SessionManager::class],
 1125              'session.store'        => [\Illuminate\Session\Store::class, \Illuminate\Contracts\Session\Session::class],

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/Console/RouteCacheCommand.php:
    5  use Illuminate\Console\Command;
    6  use Illuminate\Filesystem\Filesystem;
    7: use Illuminate\Routing\RouteCollection;
    8  use Illuminate\Contracts\Console\Kernel as ConsoleKernelContract;
    9  
   10: class RouteCacheCommand extends Command
   11  {
   12      /**
   ..
   15       * @var string
   16       */
   17:     protected $name = 'route:cache';
   18  
   19      /**
   ..
   22       * @var string
   23       */
   24:     protected $description = 'Create a route cache file for faster route registration';
   25  
   26      /**
   ..
   32  
   33      /**
   34:      * Create a new route command instance.
   35       *
   36       * @param  \Illuminate\Filesystem\Filesystem  $files
   ..
   51      public function fire()
   52      {
   53:         $this->call('route:clear');
   54  
   55:         $routes = $this->getFreshApplicationRoutes();
   56  
   57:         if (count($routes) == 0) {
   58:             return $this->error("Your application doesn't have any routes.");
   59          }
   60  
   61:         foreach ($routes as $route) {
   62:             $route->prepareForSerialization();
   63          }
   64  
   65          $this->files->put(
   66:             $this->laravel->getCachedRoutesPath(), $this->buildRouteCacheFile($routes)
   67          );
   68  
   69:         $this->info('Routes cached successfully!');
   70      }
   71  
   72      /**
   73:      * Boot a fresh copy of the application and get the routes.
   74       *
   75:      * @return \Illuminate\Routing\RouteCollection
   76       */
   77:     protected function getFreshApplicationRoutes()
   78      {
   79:         return tap($this->getFreshApplication()['router']->getRoutes(), function ($routes) {
   80:             $routes->refreshNameLookups();
   81:             $routes->refreshActionLookups();
   82          });
   83      }
   ..
   96  
   97      /**
   98:      * Build the route cache file.
   99       *
  100:      * @param  \Illuminate\Routing\RouteCollection  $routes
  101       * @return string
  102       */
  103:     protected function buildRouteCacheFile(RouteCollection $routes)
  104      {
  105:         $stub = $this->files->get(__DIR__.'/stubs/routes.stub');
  106  
  107:         return str_replace('{{routes}}', base64_encode(serialize($routes)), $stub);
  108      }
  109  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/Console/RouteClearCommand.php:
    6  use Illuminate\Filesystem\Filesystem;
    7  
    8: class RouteClearCommand extends Command
    9  {
   10      /**
   ..
   13       * @var string
   14       */
   15:     protected $name = 'route:clear';
   16  
   17      /**
   ..
   20       * @var string
   21       */
   22:     protected $description = 'Remove the route cache file';
   23  
   24      /**
   ..
   30  
   31      /**
   32:      * Create a new route clear command instance.
   33       *
   34       * @param  \Illuminate\Filesystem\Filesystem  $files
   ..
   49      public function fire()
   50      {
   51:         $this->files->delete($this->laravel->getCachedRoutesPath());
   52  
   53:         $this->info('Route cache cleared!');
   54      }
   55  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/Console/RouteListCommand.php:
    6  use Illuminate\Support\Arr;
    7  use Illuminate\Support\Str;
    8: use Illuminate\Routing\Route;
    9: use Illuminate\Routing\Router;
   10  use Illuminate\Console\Command;
   11  use Symfony\Component\Console\Input\InputOption;
   12  
   13: class RouteListCommand extends Command
   14  {
   15      /**
   ..
   18       * @var string
   19       */
   20:     protected $name = 'route:list';
   21  
   22      /**
   ..
   25       * @var string
   26       */
   27:     protected $description = 'List all registered routes';
   28  
   29      /**
   30:      * The router instance.
   31       *
   32:      * @var \Illuminate\Routing\Router
   33       */
   34:     protected $router;
   35  
   36      /**
   37:      * An array of all the registered routes.
   38       *
   39:      * @var \Illuminate\Routing\RouteCollection
   40       */
   41:     protected $routes;
   42  
   43      /**
   ..
   49  
   50      /**
   51:      * Create a new route command instance.
   52       *
   53:      * @param  \Illuminate\Routing\Router  $router
   54       * @return void
   55       */
   56:     public function __construct(Router $router)
   57      {
   58          parent::__construct();
   59  
   60:         $this->router = $router;
   61:         $this->routes = $router->getRoutes();
   62      }
   63  
   ..
   69      public function fire()
   70      {
   71:         if (count($this->routes) == 0) {
   72:             return $this->error("Your application doesn't have any routes.");
   73          }
   74  
   75:         $this->displayRoutes($this->getRoutes());
   76      }
   77  
   78      /**
   79:      * Compile the routes into a displayable format.
   80       *
   81       * @return array
   82       */
   83:     protected function getRoutes()
   84      {
   85:         $routes = collect($this->routes)->map(function ($route) {
   86:             return $this->getRouteInformation($route);
   87          })->all();
   88  
   89          if ($sort = $this->option('sort')) {
   90:             $routes = $this->sortRoutes($sort, $routes);
   91          }
   92  
   93          if ($this->option('reverse')) {
   94:             $routes = array_reverse($routes);
   95          }
   96  
   97:         return array_filter($routes);
   98      }
   99  
  100      /**
  101:      * Get the route information for a given route.
  102       *
  103:      * @param  \Illuminate\Routing\Route  $route
  104       * @return array
  105       */
  106:     protected function getRouteInformation(Route $route)
  107      {
  108:         return $this->filterRoute([
  109:             'host'   => $route->domain(),
  110:             'method' => implode('|', $route->methods()),
  111:             'uri'    => $route->uri(),
  112:             'name'   => $route->getName(),
  113:             'action' => $route->getActionName(),
  114:             'middleware' => $this->getMiddleware($route),
  115          ]);
  116      }
  117  
  118      /**
  119:      * Sort the routes by a given element.
  120       *
  121       * @param  string  $sort
  122:      * @param  array  $routes
  123       * @return array
  124       */
  125:     protected function sortRoutes($sort, $routes)
  126      {
  127:         return Arr::sort($routes, function ($route) use ($sort) {
  128:             return $route[$sort];
  129          });
  130      }
  131  
  132      /**
  133:      * Display the route information on the console.
  134       *
  135:      * @param  array  $routes
  136       * @return void
  137       */
  138:     protected function displayRoutes(array $routes)
  139      {
  140:         $this->table($this->headers, $routes);
  141      }
  142  
  ...
  144       * Get before filters.
  145       *
  146:      * @param  \Illuminate\Routing\Route  $route
  147       * @return string
  148       */
  149:     protected function getMiddleware($route)
  150      {
  151:         return collect($route->gatherMiddleware())->map(function ($middleware) {
  152              return $middleware instanceof Closure ? 'Closure' : $middleware;
  153          })->implode(',');
  ...
  155  
  156      /**
  157:      * Filter the route by URI and / or name.
  158       *
  159:      * @param  array  $route
  160       * @return array|null
  161       */
  162:     protected function filterRoute(array $route)
  163      {
  164:         if (($this->option('name') && ! Str::contains($route['name'], $this->option('name'))) ||
  165:              $this->option('path') && ! Str::contains($route['uri'], $this->option('path')) ||
  166:              $this->option('method') && ! Str::contains($route['method'], $this->option('method'))) {
  167              return;
  168          }
  169  
  170:         return $route;
  171      }
  172  
  ...
  179      {
  180          return [
  181:             ['method', null, InputOption::VALUE_OPTIONAL, 'Filter the routes by method.'],
  182  
  183:             ['name', null, InputOption::VALUE_OPTIONAL, 'Filter the routes by name.'],
  184  
  185:             ['path', null, InputOption::VALUE_OPTIONAL, 'Filter the routes by path.'],
  186  
  187:             ['reverse', 'r', InputOption::VALUE_NONE, 'Reverse the ordering of the routes.'],
  188  
  189              ['sort', null, InputOption::VALUE_OPTIONAL, 'The column (host, method, uri, name, action, middleware) to sort by.', 'uri'],

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/Console/stubs/routes.stub:
    3  /*
    4  |--------------------------------------------------------------------------
    5: | Load The Cached Routes
    6  |--------------------------------------------------------------------------
    7  |
    8: | Here we will decode and unserialize the RouteCollection instance that
    9: | holds all of the route information for an application. This allows
   10: | us to instantaneously load the entire route map into the router.
   11  |
   12  */
   13  
   14: app('router')->setRoutes(
   15:     unserialize(base64_decode('{{routes}}'))
   16  );
   17  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/Http/FormRequest.php:
   40  
   41      /**
   42:      * The route to redirect to if validation fails.
   43       *
   44       * @var string
   45       */
   46:     protected $redirectRoute;
   47  
   48      /**
   ..
  167          if ($this->redirect) {
  168              return $url->to($this->redirect);
  169:         } elseif ($this->redirectRoute) {
  170:             return $url->route($this->redirectRoute);
  171          } elseif ($this->redirectAction) {
  172              return $url->action($this->redirectAction);

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/Http/Kernel.php:
    5  use Exception;
    6  use Throwable;
    7: use Illuminate\Routing\Router;
    8  use Illuminate\Routing\Pipeline;
    9  use Illuminate\Support\Facades\Facade;
   ..
   23  
   24      /**
   25:      * The router instance.
   26       *
   27:      * @var \Illuminate\Routing\Router
   28       */
   29:     protected $router;
   30  
   31      /**
   ..
   51  
   52      /**
   53:      * The application's route middleware groups.
   54       *
   55       * @var array
   ..
   58  
   59      /**
   60:      * The application's route middleware.
   61       *
   62       * @var array
   63       */
   64:     protected $routeMiddleware = [];
   65  
   66      /**
   ..
   84       *
   85       * @param  \Illuminate\Contracts\Foundation\Application  $app
   86:      * @param  \Illuminate\Routing\Router  $router
   87       * @return void
   88       */
   89:     public function __construct(Application $app, Router $router)
   90      {
   91          $this->app = $app;
   92:         $this->router = $router;
   93  
   94:         $router->middlewarePriority = $this->middlewarePriority;
   95  
   96          foreach ($this->middlewareGroups as $key => $middleware) {
   97:             $router->middlewareGroup($key, $middleware);
   98          }
   99  
  100:         foreach ($this->routeMiddleware as $key => $middleware) {
  101:             $router->aliasMiddleware($key, $middleware);
  102          }
  103      }
  ...
  114              $request->enableHttpMethodParameterOverride();
  115  
  116:             $response = $this->sendRequestThroughRouter($request);
  117          } catch (Exception $e) {
  118              $this->reportException($e);
  ...
  133  
  134      /**
  135:      * Send the given request through the middleware / router.
  136       *
  137       * @param  \Illuminate\Http\Request  $request
  138       * @return \Illuminate\Http\Response
  139       */
  140:     protected function sendRequestThroughRouter($request)
  141      {
  142          $this->app->instance('request', $request);
  ...
  149                      ->send($request)
  150                      ->through($this->app->shouldSkipMiddleware() ? [] : $this->middleware)
  151:                     ->then($this->dispatchToRouter());
  152      }
  153  
  ...
  165  
  166      /**
  167:      * Get the route dispatcher callback.
  168       *
  169       * @return \Closure
  170       */
  171:     protected function dispatchToRouter()
  172      {
  173          return function ($request) {
  174              $this->app->instance('request', $request);
  175  
  176:             return $this->router->dispatch($request);
  177          };
  178      }
  ...
  202      {
  203          $middlewares = $this->app->shouldSkipMiddleware() ? [] : array_merge(
  204:             $this->gatherRouteMiddleware($request),
  205              $this->middleware
  206          );
  ...
  222  
  223      /**
  224:      * Gather the route middleware for the given request.
  225       *
  226       * @param  \Illuminate\Http\Request  $request
  227       * @return array
  228       */
  229:     protected function gatherRouteMiddleware($request)
  230      {
  231:         if ($route = $request->route()) {
  232:             return $this->router->gatherRouteMiddleware($route);
  233          }
  234  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/Providers/ArtisanServiceProvider.php:
   20  use Illuminate\Foundation\Console\EventMakeCommand;
   21  use Illuminate\Foundation\Console\ModelMakeCommand;
   22: use Illuminate\Foundation\Console\RouteListCommand;
   23  use Illuminate\Foundation\Console\ViewClearCommand;
   24  use Illuminate\Session\Console\SessionTableCommand;
   25  use Illuminate\Foundation\Console\PolicyMakeCommand;
   26: use Illuminate\Foundation\Console\RouteCacheCommand;
   27: use Illuminate\Foundation\Console\RouteClearCommand;
   28  use Illuminate\Console\Scheduling\ScheduleRunCommand;
   29  use Illuminate\Foundation\Console\ConfigCacheCommand;
   ..
  100          'QueueRetry' => 'command.queue.retry',
  101          'QueueWork' => 'command.queue.work',
  102:         'RouteCache' => 'command.route.cache',
  103:         'RouteClear' => 'command.route.clear',
  104:         'RouteList' => 'command.route.list',
  105          'Seed' => 'command.seed',
  106          'ScheduleFinish' => ScheduleFinishCommand::class,
  ...
  711       * @return void
  712       */
  713:     protected function registerRouteCacheCommand()
  714      {
  715:         $this->app->singleton('command.route.cache', function ($app) {
  716:             return new RouteCacheCommand($app['files']);
  717          });
  718      }
  ...
  723       * @return void
  724       */
  725:     protected function registerRouteClearCommand()
  726      {
  727:         $this->app->singleton('command.route.clear', function ($app) {
  728:             return new RouteClearCommand($app['files']);
  729          });
  730      }
  ...
  735       * @return void
  736       */
  737:     protected function registerRouteListCommand()
  738      {
  739:         $this->app->singleton('command.route.list', function ($app) {
  740:             return new RouteListCommand($app['router']);
  741          });
  742      }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/Providers/FormRequestServiceProvider.php:
   65          $form->setUserResolver($current->getUserResolver());
   66  
   67:         $form->setRouteResolver($current->getRouteResolver());
   68      }
   69  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/Support/Providers/RouteServiceProvider.php:
    3  namespace Illuminate\Foundation\Support\Providers;
    4  
    5: use Illuminate\Routing\Router;
    6  use Illuminate\Support\ServiceProvider;
    7  use Illuminate\Contracts\Routing\UrlGenerator;
    8  
    9: class RouteServiceProvider extends ServiceProvider
   10  {
   11      /**
   ..
   25          $this->setRootControllerNamespace();
   26  
   27:         if ($this->app->routesAreCached()) {
   28:             $this->loadCachedRoutes();
   29          } else {
   30:             $this->loadRoutes();
   31  
   32              $this->app->booted(function () {
   33:                 $this->app['router']->getRoutes()->refreshNameLookups();
   34:                 $this->app['router']->getRoutes()->refreshActionLookups();
   35              });
   36          }
   ..
   50  
   51      /**
   52:      * Load the cached routes for the application.
   53       *
   54       * @return void
   55       */
   56:     protected function loadCachedRoutes()
   57      {
   58          $this->app->booted(function () {
   59:             require $this->app->getCachedRoutesPath();
   60          });
   61      }
   62  
   63      /**
   64:      * Load the application routes.
   65       *
   66       * @return void
   67       */
   68:     protected function loadRoutes()
   69      {
   70          if (method_exists($this, 'map')) {
   ..
   84  
   85      /**
   86:      * Pass dynamic methods onto the router instance.
   87       *
   88       * @param  string  $method
   ..
   93      {
   94          return call_user_func_array(
   95:             [$this->app->make(Router::class), $method], $parameters
   96          );
   97      }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/Testing/TestResponse.php:
  389                  throw $this->exception;
  390              } else {
  391:                 PHPUnit::fail('Invalid JSON was returned from the route.');
  392              }
  393          }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Foundation/helpers.php:
  698  }
  699  
  700: if (! function_exists('route')) {
  701      /**
  702:      * Generate the URL to a named route.
  703       *
  704       * @param  string  $name
  ...
  707       * @return string
  708       */
  709:     function route($name, $parameters = [], $absolute = true)
  710      {
  711:         return app('url')->route($name, $parameters, $absolute);
  712      }
  713  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Http/Request.php:
   42  
   43      /**
   44:      * The route resolver callback.
   45       *
   46       * @var \Closure
   47       */
   48:     protected $routeResolver;
   49  
   50      /**
   ..
  194  
  195      /**
  196:      * Check if the route name matches the given string.
  197       *
  198       * @param  string  $name
  199       * @return bool
  200       */
  201:     public function routeIs($name)
  202      {
  203:         return $this->route() && $this->route()->named($name);
  204      }
  205  
  ...
  426  
  427      /**
  428:      * Get the route handling the request.
  429       *
  430       * @param  string|null  $param
  431       *
  432:      * @return \Illuminate\Routing\Route|object|string
  433       */
  434:     public function route($param = null)
  435      {
  436:         $route = call_user_func($this->getRouteResolver());
  437  
  438:         if (is_null($route) || is_null($param)) {
  439:             return $route;
  440          } else {
  441:             return $route->parameter($param);
  442          }
  443      }
  444  
  445      /**
  446:      * Get a unique fingerprint for the request / route / IP address.
  447       *
  448       * @return string
  ...
  452      public function fingerprint()
  453      {
  454:         if (! $route = $this->route()) {
  455:             throw new RuntimeException('Unable to generate fingerprint. Route unavailable.');
  456          }
  457  
  458          return sha1(implode('|', array_merge(
  459:             $route->methods(), [$route->domain(), $route->uri(), $this->ip()]
  460          )));
  461      }
  ...
  500  
  501      /**
  502:      * Get the route resolver callback.
  503       *
  504       * @return \Closure
  505       */
  506:     public function getRouteResolver()
  507      {
  508:         return $this->routeResolver ?: function () {
  509              //
  510          };
  ...
  512  
  513      /**
  514:      * Set the route resolver callback.
  515       *
  516       * @param  \Closure  $callback
  517       * @return $this
  518       */
  519:     public function setRouteResolver(Closure $callback)
  520      {
  521:         $this->routeResolver = $callback;
  522  
  523          return $this;
  ...
  602          }
  603  
  604:         return $this->route($key);
  605      }
  606  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Http/Response.php:
   25          // If the content is "JSONable" we will set the appropriate header and convert
   26          // the content to JSON. This is useful when returning something like models
   27:         // from routes that will be automatically transformed to their JSON form.
   28          if ($this->shouldBeJson($content)) {
   29              $this->header('Content-Type', 'application/json');

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Http/Testing/MimeType.php:
  400          'rm' => 'application/vnd.rn-realmedia',
  401          'rmvb' => 'application/vnd.rn-realmedia-vbr',
  402:         'link66' => 'application/vnd.route66.link66+xml',
  403          'st' => 'application/vnd.sailingtracker.track',
  404          'see' => 'application/vnd.seemail',

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Notifications/Channels/DatabaseChannel.php:
   17      public function send($notifiable, Notification $notification)
   18      {
   19:         return $notifiable->routeNotificationFor('database')->create([
   20              'id' => $notification->id,
   21              'type' => get_class($notification),

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Notifications/Channels/MailChannel.php:
   46      public function send($notifiable, Notification $notification)
   47      {
   48:         if (! $notifiable->routeNotificationFor('mail')) {
   49              return;
   50          }
   ..
  147      protected function getRecipients($notifiable, $message)
  148      {
  149:         if (is_string($recipients = $notifiable->routeNotificationFor('mail'))) {
  150              $recipients = [$recipients];
  151          }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Notifications/Channels/NexmoSmsChannel.php:
   45      public function send($notifiable, Notification $notification)
   46      {
   47:         if (! $to = $notifiable->routeNotificationFor('nexmo')) {
   48              return;
   49          }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Notifications/Channels/SlackWebhookChannel.php:
   38      public function send($notifiable, Notification $notification)
   39      {
   40:         if (! $url = $notifiable->routeNotificationFor('slack')) {
   41              return;
   42          }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Notifications/Notifiable.php:
    5  trait Notifiable
    6  {
    7:     use HasDatabaseNotifications, RoutesNotifications;
    8  }
    9  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Notifications/RoutesNotifications.php:
    6  use Illuminate\Contracts\Notifications\Dispatcher;
    7  
    8: trait RoutesNotifications
    9  {
   10      /**
   ..
   25       * @return mixed
   26       */
   27:     public function routeNotificationFor($driver)
   28      {
   29:         if (method_exists($this, $method = 'routeNotificationFor'.Str::studly($driver))) {
   30              return $this->{$method}();
   31          }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/ControllerDispatcher.php:
    7  class ControllerDispatcher
    8  {
    9:     use RouteDependencyResolverTrait;
   10  
   11      /**
   ..
   30       * Dispatch a request to a given controller and method.
   31       *
   32:      * @param  \Illuminate\Routing\Route  $route
   33       * @param  mixed  $controller
   34       * @param  string  $method
   35       * @return mixed
   36       */
   37:     public function dispatch(Route $route, $controller, $method)
   38      {
   39          $parameters = $this->resolveClassMethodDependencies(
   40:             $route->parametersWithoutNulls(), $controller, $method
   41          );
   42  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/Events/RouteMatched.php:
    3  namespace Illuminate\Routing\Events;
    4  
    5: class RouteMatched
    6  {
    7      /**
    8:      * The route instance.
    9       *
   10:      * @var \Illuminate\Routing\Route
   11       */
   12:     public $route;
   13  
   14      /**
   ..
   22       * Create a new event instance.
   23       *
   24:      * @param  \Illuminate\Routing\Route  $route
   25       * @param  \Illuminate\Http\Request  $request
   26       * @return void
   27       */
   28:     public function __construct($route, $request)
   29      {
   30:         $this->route = $route;
   31          $this->request = $request;
   32      }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/Exceptions/UrlGenerationException.php:
    8  {
    9      /**
   10:      * Create a new exception for missing route parameters.
   11       *
   12:      * @param  \Illuminate\Routing\Route  $route
   13       * @return static
   14       */
   15:     public static function forMissingParameters($route)
   16      {
   17:         return new static("Missing required parameters for [Route: {$route->getName()}] [URI: {$route->uri()}].");
   18      }
   19  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/ImplicitRouteBinding.php:
    5  use Illuminate\Database\Eloquent\Model;
    6  
    7: class ImplicitRouteBinding
    8  {
    9      /**
   10:      * Resolve the implicit route bindings for the given route.
   11       *
   12       * @param  \Illuminate\Container\Container  $container
   13:      * @param  \Illuminate\Routing\Route  $route
   14       * @return void
   15       */
   16:     public static function resolveForRoute($container, $route)
   17      {
   18:         $parameters = $route->parameters();
   19  
   20:         foreach ($route->signatureParameters(Model::class) as $parameter) {
   21              if (! $parameterName = static::getParameterName($parameter->name, $parameters)) {
   22                  continue;
   ..
   31              $model = $container->make($parameter->getClass()->name);
   32  
   33:             $route->setParameter($parameterName, $model->where(
   34:                 $model->getRouteKeyName(), $parameterValue
   35              )->firstOrFail());
   36          }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/Matching/HostValidator.php:
    4  
    5  use Illuminate\Http\Request;
    6: use Illuminate\Routing\Route;
    7  
    8  class HostValidator implements ValidatorInterface
    9  {
   10      /**
   11:      * Validate a given rule against a route and request.
   12       *
   13:      * @param  \Illuminate\Routing\Route  $route
   14       * @param  \Illuminate\Http\Request  $request
   15       * @return bool
   16       */
   17:     public function matches(Route $route, Request $request)
   18      {
   19:         if (is_null($route->getCompiled()->getHostRegex())) {
   20              return true;
   21          }
   22  
   23:         return preg_match($route->getCompiled()->getHostRegex(), $request->getHost());
   24      }
   25  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/Matching/MethodValidator.php:
    4  
    5  use Illuminate\Http\Request;
    6: use Illuminate\Routing\Route;
    7  
    8  class MethodValidator implements ValidatorInterface
    9  {
   10      /**
   11:      * Validate a given rule against a route and request.
   12       *
   13:      * @param  \Illuminate\Routing\Route  $route
   14       * @param  \Illuminate\Http\Request  $request
   15       * @return bool
   16       */
   17:     public function matches(Route $route, Request $request)
   18      {
   19:         return in_array($request->getMethod(), $route->methods());
   20      }
   21  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/Matching/SchemeValidator.php:
    4  
    5  use Illuminate\Http\Request;
    6: use Illuminate\Routing\Route;
    7  
    8  class SchemeValidator implements ValidatorInterface
    9  {
   10      /**
   11:      * Validate a given rule against a route and request.
   12       *
   13:      * @param  \Illuminate\Routing\Route  $route
   14       * @param  \Illuminate\Http\Request  $request
   15       * @return bool
   16       */
   17:     public function matches(Route $route, Request $request)
   18      {
   19:         if ($route->httpOnly()) {
   20              return ! $request->secure();
   21:         } elseif ($route->secure()) {
   22              return $request->secure();
   23          }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/Matching/UriValidator.php:
    4  
    5  use Illuminate\Http\Request;
    6: use Illuminate\Routing\Route;
    7  
    8  class UriValidator implements ValidatorInterface
    9  {
   10      /**
   11:      * Validate a given rule against a route and request.
   12       *
   13:      * @param  \Illuminate\Routing\Route  $route
   14       * @param  \Illuminate\Http\Request  $request
   15       * @return bool
   16       */
   17:     public function matches(Route $route, Request $request)
   18      {
   19          $path = $request->path() == '/' ? '/' : '/'.$request->path();
   20  
   21:         return preg_match($route->getCompiled()->getRegex(), rawurldecode($path));
   22      }
   23  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/Matching/ValidatorInterface.php:
    4  
    5  use Illuminate\Http\Request;
    6: use Illuminate\Routing\Route;
    7  
    8  interface ValidatorInterface
    9  {
   10      /**
   11:      * Validate a given rule against a route and request.
   12       *
   13:      * @param  \Illuminate\Routing\Route  $route
   14       * @param  \Illuminate\Http\Request  $request
   15       * @return bool
   16       */
   17:     public function matches(Route $route, Request $request);
   18  }
   19  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/Middleware/SubstituteBindings.php:
    9  {
   10      /**
   11:      * The router instance.
   12       *
   13       * @var \Illuminate\Contracts\Routing\Registrar
   14       */
   15:     protected $router;
   16  
   17      /**
   18       * Create a new bindings substitutor.
   19       *
   20:      * @param  \Illuminate\Contracts\Routing\Registrar  $router
   21       * @return void
   22       */
   23:     public function __construct(Registrar $router)
   24      {
   25:         $this->router = $router;
   26      }
   27  
   ..
   35      public function handle($request, Closure $next)
   36      {
   37:         $this->router->substituteBindings($route = $request->route());
   38  
   39:         $this->router->substituteImplicitBindings($route);
   40  
   41          return $next($request);

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/MiddlewareNameResolver.php:
   72              );
   73  
   74:             // If this middleware is actually a route middleware, we will extract the full
   75              // class name out of the middleware list now. Then we'll add the parameters
   76              // back onto this class' name so the pipeline will properly extract them.

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/Redirector.php:
   34  
   35      /**
   36:      * Create a new redirect response to the "home" route.
   37       *
   38       * @param  int  $status
   ..
   41      public function home($status = 302)
   42      {
   43:         return $this->to($this->generator->route('home'), $status);
   44      }
   45  
   ..
  142  
  143      /**
  144:      * Create a new redirect response to a named route.
  145       *
  146:      * @param  string  $route
  147       * @param  array   $parameters
  148       * @param  int     $status
  ...
  150       * @return \Illuminate\Http\RedirectResponse
  151       */
  152:     public function route($route, $parameters = [], $status = 302, $headers = [])
  153      {
  154:         return $this->to($this->generator->route($route, $parameters), $status, $headers);
  155      }
  156  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/ResourceRegistrar.php:
    8  {
    9      /**
   10:      * The router instance.
   11       *
   12:      * @var \Illuminate\Routing\Router
   13       */
   14:     protected $router;
   15  
   16      /**
   ..
   55       * Create a new resource registrar instance.
   56       *
   57:      * @param  \Illuminate\Routing\Router  $router
   58       * @return void
   59       */
   60:     public function __construct(Router $router)
   61      {
   62:         $this->router = $router;
   63      }
   64  
   65      /**
   66:      * Route a resource to a controller.
   67       *
   68       * @param  string  $name
   ..
   78  
   79          // If the resource name contains a slash, we will assume the developer wishes to
   80:         // register these resource routes with a prefix so we will set that up out of
   81          // the box so they don't have to mess with it. Otherwise, we will continue.
   82          if (Str::contains($name, '/')) {
   ..
   88          // We need to extract the base resource from the resource name. Nested resources
   89          // are supported in the framework, but we need to know what name to use for a
   90:         // place-holder on the route parameters, which should be the base resources.
   91          $base = $this->getResourceWildcard(last(explode('.', $name)));
   92  
   ..
   99  
  100      /**
  101:      * Build a set of prefixed resource routes.
  102       *
  103       * @param  string  $name
  ...
  112          // We need to extract the base resource from the resource name. Nested resources
  113          // are supported in the framework, but we need to know what name to use for a
  114:         // place-holder on the route parameters, which should be the base resources.
  115          $callback = function ($me) use ($name, $controller, $options) {
  116              $me->resource($name, $controller, $options);
  117          };
  118  
  119:         return $this->router->group(compact('prefix'), $callback);
  120      }
  121  
  ...
  157  
  158      /**
  159:      * Add the index method for a resourceful route.
  160       *
  161       * @param  string  $name
  ...
  163       * @param  string  $controller
  164       * @param  array   $options
  165:      * @return \Illuminate\Routing\Route
  166       */
  167      protected function addResourceIndex($name, $base, $controller, $options)
  ...
  171          $action = $this->getResourceAction($name, $controller, 'index', $options);
  172  
  173:         return $this->router->get($uri, $action);
  174      }
  175  
  176      /**
  177:      * Add the create method for a resourceful route.
  178       *
  179       * @param  string  $name
  ...
  181       * @param  string  $controller
  182       * @param  array   $options
  183:      * @return \Illuminate\Routing\Route
  184       */
  185      protected function addResourceCreate($name, $base, $controller, $options)
  ...
  189          $action = $this->getResourceAction($name, $controller, 'create', $options);
  190  
  191:         return $this->router->get($uri, $action);
  192      }
  193  
  194      /**
  195:      * Add the store method for a resourceful route.
  196       *
  197       * @param  string  $name
  ...
  199       * @param  string  $controller
  200       * @param  array   $options
  201:      * @return \Illuminate\Routing\Route
  202       */
  203      protected function addResourceStore($name, $base, $controller, $options)
  ...
  207          $action = $this->getResourceAction($name, $controller, 'store', $options);
  208  
  209:         return $this->router->post($uri, $action);
  210      }
  211  
  212      /**
  213:      * Add the show method for a resourceful route.
  214       *
  215       * @param  string  $name
  ...
  217       * @param  string  $controller
  218       * @param  array   $options
  219:      * @return \Illuminate\Routing\Route
  220       */
  221      protected function addResourceShow($name, $base, $controller, $options)
  ...
  225          $action = $this->getResourceAction($name, $controller, 'show', $options);
  226  
  227:         return $this->router->get($uri, $action);
  228      }
  229  
  230      /**
  231:      * Add the edit method for a resourceful route.
  232       *
  233       * @param  string  $name
  ...
  235       * @param  string  $controller
  236       * @param  array   $options
  237:      * @return \Illuminate\Routing\Route
  238       */
  239      protected function addResourceEdit($name, $base, $controller, $options)
  ...
  243          $action = $this->getResourceAction($name, $controller, 'edit', $options);
  244  
  245:         return $this->router->get($uri, $action);
  246      }
  247  
  248      /**
  249:      * Add the update method for a resourceful route.
  250       *
  251       * @param  string  $name
  ...
  253       * @param  string  $controller
  254       * @param  array   $options
  255:      * @return \Illuminate\Routing\Route
  256       */
  257      protected function addResourceUpdate($name, $base, $controller, $options)
  ...
  261          $action = $this->getResourceAction($name, $controller, 'update', $options);
  262  
  263:         return $this->router->match(['PUT', 'PATCH'], $uri, $action);
  264      }
  265  
  266      /**
  267:      * Add the destroy method for a resourceful route.
  268       *
  269       * @param  string  $name
  ...
  271       * @param  string  $controller
  272       * @param  array   $options
  273:      * @return \Illuminate\Routing\Route
  274       */
  275      protected function addResourceDestroy($name, $base, $controller, $options)
  ...
  279          $action = $this->getResourceAction($name, $controller, 'destroy', $options);
  280  
  281:         return $this->router->delete($uri, $action);
  282      }
  283  
  ...
  295  
  296          // Once we have built the base URI, we'll remove the parameter holder for this
  297:         // base resource name so that the individual route adders can suffix these
  298          // paths however they need to, as some do not have any parameters at all.
  299          $segments = explode('.', $resource);
  ...
  340  
  341      /**
  342:      * Get the action array for a resource route.
  343       *
  344       * @param  string  $resource
  ...
  350      protected function getResourceAction($resource, $controller, $method, $options)
  351      {
  352:         $name = $this->getResourceRouteName($resource, $method, $options);
  353  
  354          $action = ['as' => $name, 'uses' => $controller.'@'.$method];
  ...
  369       * @return string
  370       */
  371:     protected function getResourceRouteName($resource, $method, $options)
  372      {
  373          $name = $resource;

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/ResponseFactory.php:
  159  
  160      /**
  161:      * Create a new redirect response to a named route.
  162       *
  163:      * @param  string  $route
  164       * @param  array  $parameters
  165       * @param  int  $status
  ...
  167       * @return \Illuminate\Http\RedirectResponse
  168       */
  169:     public function redirectToRoute($route, $parameters = [], $status = 302, $headers = [])
  170      {
  171:         return $this->redirector->route($route, $parameters, $status, $headers);
  172      }
  173  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/Route.php:
   16  use Illuminate\Http\Exceptions\HttpResponseException;
   17  
   18: class Route
   19  {
   20:     use RouteDependencyResolverTrait;
   21  
   22      /**
   23:      * The URI pattern the route responds to.
   24       *
   25       * @var string
   ..
   28  
   29      /**
   30:      * The HTTP methods the route responds to.
   31       *
   32       * @var array
   ..
   35  
   36      /**
   37:      * The route action array.
   38       *
   39       * @var array
   ..
   49  
   50      /**
   51:      * The default values for the route.
   52       *
   53       * @var array
   ..
   70  
   71      /**
   72:      * The parameter names for the route.
   73       *
   74       * @var array|null
   ..
   84  
   85      /**
   86:      * The compiled version of the route.
   87       *
   88:      * @var \Symfony\Component\Routing\CompiledRoute
   89       */
   90      public $compiled;
   91  
   92      /**
   93:      * The router instance used by the route.
   94       *
   95:      * @var \Illuminate\Routing\Router
   96       */
   97:     protected $router;
   98  
   99      /**
  100:      * The container instance used by the route.
  101       *
  102       * @var \Illuminate\Container\Container
  ...
  105  
  106      /**
  107:      * The validators used by the routes.
  108       *
  109       * @var array
  ...
  112  
  113      /**
  114:      * Create a new Route instance.
  115       *
  116       * @param  array|string  $methods
  ...
  135  
  136      /**
  137:      * Parse the route action into a standard array.
  138       *
  139       * @param  callable|array|null  $action
  ...
  144      protected function parseAction($action)
  145      {
  146:         return RouteAction::parse($this->uri, $action);
  147      }
  148  
  149      /**
  150:      * Run the route action and return the response.
  151       *
  152       * @return mixed
  ...
  168  
  169      /**
  170:      * Checks whether the route's action is a controller.
  171       *
  172       * @return bool
  ...
  178  
  179      /**
  180:      * Run the route action and return the response.
  181       *
  182       * @return mixed
  ...
  192  
  193      /**
  194:      * Run the route action and return the response.
  195       *
  196       * @return mixed
  ...
  206  
  207      /**
  208:      * Get the controller instance for the route.
  209       *
  210       * @return mixed
  ...
  222  
  223      /**
  224:      * Get the controller method used for the route.
  225       *
  226       * @return string
  ...
  242  
  243      /**
  244:      * Determine if the route matches given request.
  245       *
  246       * @param  \Illuminate\Http\Request  $request
  ...
  250      public function matches(Request $request, $includingMethod = true)
  251      {
  252:         $this->compileRoute();
  253  
  254          foreach ($this->getValidators() as $validator) {
  ...
  266  
  267      /**
  268:      * Compile the route into a Symfony CompiledRoute instance.
  269       *
  270       * @return void
  271       */
  272:     protected function compileRoute()
  273      {
  274          if (! $this->compiled) {
  275:             $this->compiled = (new RouteCompiler($this))->compile();
  276          }
  277  
  ...
  280  
  281      /**
  282:      * Bind the route to a given request for execution.
  283       *
  284       * @param  \Illuminate\Http\Request  $request
  ...
  287      public function bind(Request $request)
  288      {
  289:         $this->compileRoute();
  290  
  291:         $this->parameters = (new RouteParameterBinder($this))
  292                          ->parameters($request);
  293  
  ...
  296  
  297      /**
  298:      * Determine if the route has parameters.
  299       *
  300       * @return bool
  ...
  306  
  307      /**
  308:      * Determine a given parameter exists from the route.
  309       *
  310       * @param  string $name
  ...
  321  
  322      /**
  323:      * Get a given parameter from the route.
  324       *
  325       * @param  string  $name
  ...
  347  
  348      /**
  349:      * Unset a parameter on the route if it is set.
  350       *
  351       * @param  string  $name
  ...
  360  
  361      /**
  362:      * Get the key / value list of parameters for the route.
  363       *
  364       * @return array
  ...
  372          }
  373  
  374:         throw new LogicException('Route is not bound.');
  375      }
  376  
  ...
  388  
  389      /**
  390:      * Get all of the parameter names for the route.
  391       *
  392       * @return array
  ...
  402  
  403      /**
  404:      * Get the parameter names for the route.
  405       *
  406       * @return array
  ...
  416  
  417      /**
  418:      * Get the parameters that are listed in the route / controller signature.
  419       *
  420       * @param  string|null  $subClass
  ...
  423      public function signatureParameters($subClass = null)
  424      {
  425:         return RouteSignatureParameters::fromAction($this->action, $subClass);
  426      }
  427  
  428      /**
  429:      * Set a default value for the route.
  430       *
  431       * @param  string  $key
  ...
  441  
  442      /**
  443:      * Set a regular expression requirement on the route.
  444       *
  445       * @param  array|string  $name
  ...
  469  
  470      /**
  471:      * Set a list of regular expression requirements on the route.
  472       *
  473       * @param  array  $wheres
  ...
  484  
  485      /**
  486:      * Get the HTTP verbs the route responds to.
  487       *
  488       * @return array
  ...
  494  
  495      /**
  496:      * Determine if the route only responds to HTTP requests.
  497       *
  498       * @return bool
  ...
  504  
  505      /**
  506:      * Determine if the route only responds to HTTPS requests.
  507       *
  508       * @return bool
  ...
  514  
  515      /**
  516:      * Determine if the route only responds to HTTPS requests.
  517       *
  518       * @return bool
  ...
  524  
  525      /**
  526:      * Get the domain defined for the route.
  527       *
  528       * @return string|null
  ...
  535  
  536      /**
  537:      * Get the prefix of the route instance.
  538       *
  539       * @return string
  ...
  545  
  546      /**
  547:      * Add a prefix to the route URI.
  548       *
  549       * @param  string  $prefix
  ...
  560  
  561      /**
  562:      * Get the URI associated with the route.
  563       *
  564       * @return string
  ...
  570  
  571      /**
  572:      * Set the URI that the route responds to.
  573       *
  574       * @param  string  $uri
  ...
  583  
  584      /**
  585:      * Get the name of the route instance.
  586       *
  587       * @return string
  ...
  593  
  594      /**
  595:      * Add or change the route name.
  596       *
  597       * @param  string  $name
  ...
  606  
  607      /**
  608:      * Determine whether the route's name matches the given name.
  609       *
  610       * @param  string  $name
  ...
  617  
  618      /**
  619:      * Set the handler for the route.
  620       *
  621       * @param  \Closure|string  $action
  ...
  640      protected function addGroupNamespaceToStringUses($action)
  641      {
  642:         $groupStack = last($this->router->getGroupStack());
  643  
  644          if (isset($groupStack['namespace']) && strpos($action, '\\') !== 0) {
  ...
  650  
  651      /**
  652:      * Get the action name for the route.
  653       *
  654       * @return string
  ...
  660  
  661      /**
  662:      * Get the method name of the route action.
  663       *
  664       * @return string
  ...
  670  
  671      /**
  672:      * Get the action array for the route.
  673       *
  674       * @return array
  ...
  680  
  681      /**
  682:      * Set the action array for the route.
  683       *
  684       * @param  array  $action
  ...
  711  
  712      /**
  713:      * Get or set the middlewares attached to the route.
  714       *
  715       * @param  array|string|null $middleware
  ...
  734  
  735      /**
  736:      * Get the middleware for the route's controller.
  737       *
  738       * @return array
  ...
  750  
  751      /**
  752:      * Get the route validators for the instance.
  753       *
  754       * @return array
  ...
  760          }
  761  
  762:         // To match the route, we will use a chain of responsibility pattern with the
  763          // validator implementations. We will spin through each one making sure it
  764:         // passes and then we will know if the route as a whole matches request.
  765          return static::$validators = [
  766              new UriValidator, new MethodValidator,
  ...
  770  
  771      /**
  772:      * Get the compiled version of the route.
  773       *
  774:      * @return \Symfony\Component\Routing\CompiledRoute
  775       */
  776      public function getCompiled()
  ...
  780  
  781      /**
  782:      * Set the router instance on the route.
  783       *
  784:      * @param  \Illuminate\Routing\Router  $router
  785       * @return $this
  786       */
  787:     public function setRouter(Router $router)
  788      {
  789:         $this->router = $router;
  790  
  791          return $this;
  ...
  793  
  794      /**
  795:      * Set the container instance on the route.
  796       *
  797       * @param  \Illuminate\Container\Container  $container
  ...
  806  
  807      /**
  808:      * Prepare the route instance for serialization.
  809       *
  810       * @return void
  ...
  815      {
  816          if ($this->action['uses'] instanceof Closure) {
  817:             throw new LogicException("Unable to prepare route [{$this->uri}] for serialization. Uses Closure.");
  818          }
  819  
  820:         $this->compileRoute();
  821  
  822:         unset($this->router, $this->container);
  823      }
  824  
  825      /**
  826:      * Dynamically access route parameters.
  827       *
  828       * @param  string  $key

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/RouteAction.php:
    8  use UnexpectedValueException;
    9  
   10: class RouteAction
   11  {
   12      /**
   ..
   35          // If no "uses" property has been set, we will dig through the array to find a
   36          // Closure instance within this list. We will set the first Closure we come
   37:         // across into the "uses" property that will get fired off by this route.
   38          elseif (! isset($action['uses'])) {
   39              $action['uses'] = static::findCallable($action);
   ..
   48  
   49      /**
   50:      * Get an action for a route that has no action.
   51       *
   52       * @param  string  $uri
   ..
   56      {
   57          return ['uses' => function () use ($uri) {
   58:             throw new LogicException("Route for [{$uri}] has no action.");
   59          }];
   60      }
   ..
   82      {
   83          if (! method_exists($action, '__invoke')) {
   84:             throw new UnexpectedValueException("Invalid route action: [{$action}].");
   85          }
   86  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/RouteBinding.php:
    7  use Illuminate\Database\Eloquent\ModelNotFoundException;
    8  
    9: class RouteBinding
   10  {
   11      /**
   12:      * Create a Route model binding for a given callback.
   13       *
   14       * @param  \Illuminate\Container\Container  $container
   ..
   34      protected static function createClassBinding($container, $binding)
   35      {
   36:         return function ($value, $route) use ($container, $binding) {
   37              // If the binding has an @ sign, we will assume it's being used to delimit
   38              // the class name from the bind method name. This allows for bindings
   ..
   42              $callable = [$container->make($class), $method];
   43  
   44:             return call_user_func($callable, $value, $route);
   45          };
   46      }
   47  
   48      /**
   49:      * Create a Route model binding for a model.
   50       *
   51       * @param  \Illuminate\Container\Container  $container
   ..
   66              $instance = $container->make($class);
   67  
   68:             if ($model = $instance->where($instance->getRouteKeyName(), $value)->first()) {
   69                  return $model;
   70              }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/RouteCollection.php:
   12  use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
   13  
   14: class RouteCollection implements Countable, IteratorAggregate
   15  {
   16      /**
   17:      * An array of the routes keyed by method.
   18       *
   19       * @var array
   20       */
   21:     protected $routes = [];
   22  
   23      /**
   24:      * An flattened array of all of the routes.
   25       *
   26       * @var array
   27       */
   28:     protected $allRoutes = [];
   29  
   30      /**
   31:      * A look-up table of routes by their names.
   32       *
   33       * @var array
   ..
   36  
   37      /**
   38:      * A look-up table of routes by controller action.
   39       *
   40       * @var array
   ..
   43  
   44      /**
   45:      * Add a Route instance to the collection.
   46       *
   47:      * @param  \Illuminate\Routing\Route  $route
   48:      * @return \Illuminate\Routing\Route
   49       */
   50:     public function add(Route $route)
   51      {
   52:         $this->addToCollections($route);
   53  
   54:         $this->addLookups($route);
   55  
   56:         return $route;
   57      }
   58  
   59      /**
   60:      * Add the given route to the arrays of routes.
   61       *
   62:      * @param  \Illuminate\Routing\Route  $route
   63       * @return void
   64       */
   65:     protected function addToCollections($route)
   66      {
   67:         $domainAndUri = $route->domain().$route->uri();
   68  
   69:         foreach ($route->methods() as $method) {
   70:             $this->routes[$method][$domainAndUri] = $route;
   71          }
   72  
   73:         $this->allRoutes[$method.$domainAndUri] = $route;
   74      }
   75  
   76      /**
   77:      * Add the route to any look-up tables if necessary.
   78       *
   79:      * @param  \Illuminate\Routing\Route  $route
   80       * @return void
   81       */
   82:     protected function addLookups($route)
   83      {
   84:         // If the route has a name, we will add it to the name look-up table so that we
   85:         // will quickly be able to find any route associate with a name and not have
   86:         // to iterate through every route every time we need to perform a look-up.
   87:         $action = $route->getAction();
   88  
   89          if (isset($action['as'])) {
   90:             $this->nameList[$action['as']] = $route;
   91          }
   92  
   93:         // When the route is routing to a controller we will also store the action that
   94:         // is used by the route. This will let us reverse route to controllers while
   95          // processing a request and easily generate URLs to the given controllers.
   96          if (isset($action['controller'])) {
   97:             $this->addToActionList($action, $route);
   98          }
   99      }
  100  
  101      /**
  102:      * Add a route to the controller action dictionary.
  103       *
  104       * @param  array  $action
  105:      * @param  \Illuminate\Routing\Route  $route
  106       * @return void
  107       */
  108:     protected function addToActionList($action, $route)
  109      {
  110:         $this->actionList[trim($action['controller'], '\\')] = $route;
  111      }
  112  
  ...
  114       * Refresh the name look-up table.
  115       *
  116:      * This is done in case any names are fluently defined or if routes are overwritten.
  117       *
  118       * @return void
  ...
  122          $this->nameList = [];
  123  
  124:         foreach ($this->allRoutes as $route) {
  125:             if ($route->getName()) {
  126:                 $this->nameList[$route->getName()] = $route;
  127              }
  128          }
  ...
  140          $this->actionList = [];
  141  
  142:         foreach ($this->allRoutes as $route) {
  143:             if (isset($route->getAction()['controller'])) {
  144:                 $this->addToActionList($route->getAction(), $route);
  145              }
  146          }
  ...
  148  
  149      /**
  150:      * Find the first route matching a given request.
  151       *
  152       * @param  \Illuminate\Http\Request  $request
  153:      * @return \Illuminate\Routing\Route
  154       *
  155       * @throws \Symfony\Component\HttpKernel\Exception\NotFoundHttpException
  ...
  157      public function match(Request $request)
  158      {
  159:         $routes = $this->get($request->getMethod());
  160  
  161:         // First, we will see if we can find a matching route for this current request
  162          // method. If we can, great, we can just return it so that it can be called
  163:         // by the consumer. Otherwise we will check for routes with another verb.
  164:         $route = $this->matchAgainstRoutes($routes, $request);
  165  
  166:         if (! is_null($route)) {
  167:             return $route->bind($request);
  168          }
  169  
  170:         // If no route was found we will now check if a matching route is specified by
  171          // another HTTP verb. If it is we will need to throw a MethodNotAllowed and
  172:         // inform the user agent of which HTTP verb it should use for this route.
  173          $others = $this->checkForAlternateVerbs($request);
  174  
  175          if (count($others) > 0) {
  176:             return $this->getRouteForMethods($request, $others);
  177          }
  178  
  ...
  181  
  182      /**
  183:      * Determine if a route in the array matches the request.
  184       *
  185:      * @param  array  $routes
  186       * @param  \Illuminate\http\Request  $request
  187       * @param  bool  $includingMethod
  188:      * @return \Illuminate\Routing\Route|null
  189       */
  190:     protected function matchAgainstRoutes(array $routes, $request, $includingMethod = true)
  191      {
  192:         return Arr::first($routes, function ($value) use ($request, $includingMethod) {
  193              return $value->matches($request, $includingMethod);
  194          });
  ...
  196  
  197      /**
  198:      * Determine if any routes match on another HTTP verb.
  199       *
  200       * @param  \Illuminate\Http\Request  $request
  ...
  203      protected function checkForAlternateVerbs($request)
  204      {
  205:         $methods = array_diff(Router::$verbs, [$request->getMethod()]);
  206  
  207          // Here we will spin through all verbs except for the current request verb and
  208:         // check to see if any routes respond to them. If they do, we will return a
  209          // proper error response with the correct headers on the response string.
  210          $others = [];
  211  
  212          foreach ($methods as $method) {
  213:             if (! is_null($this->matchAgainstRoutes($this->get($method), $request, false))) {
  214                  $others[] = $method;
  215              }
  ...
  220  
  221      /**
  222:      * Get a route (if necessary) that responds when other available methods are present.
  223       *
  224       * @param  \Illuminate\Http\Request  $request
  225       * @param  array  $methods
  226:      * @return \Illuminate\Routing\Route
  227       *
  228       * @throws \Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException
  229       */
  230:     protected function getRouteForMethods($request, array $methods)
  231      {
  232          if ($request->method() == 'OPTIONS') {
  233:             return (new Route('OPTIONS', $request->path(), function () use ($methods) {
  234                  return new Response('', 200, ['Allow' => implode(',', $methods)]);
  235              }))->bind($request);
  ...
  253  
  254      /**
  255:      * Get routes from the collection by method.
  256       *
  257       * @param  string|null  $method
  ...
  260      public function get($method = null)
  261      {
  262:         return is_null($method) ? $this->getRoutes() : Arr::get($this->routes, $method, []);
  263      }
  264  
  265      /**
  266:      * Determine if the route collection contains a given named route.
  267       *
  268       * @param  string  $name
  269       * @return bool
  270       */
  271:     public function hasNamedRoute($name)
  272      {
  273          return ! is_null($this->getByName($name));
  ...
  275  
  276      /**
  277:      * Get a route instance by its name.
  278       *
  279       * @param  string  $name
  280:      * @return \Illuminate\Routing\Route|null
  281       */
  282      public function getByName($name)
  ...
  286  
  287      /**
  288:      * Get a route instance by its controller action.
  289       *
  290       * @param  string  $action
  291:      * @return \Illuminate\Routing\Route|null
  292       */
  293      public function getByAction($action)
  ...
  297  
  298      /**
  299:      * Get all of the routes in the collection.
  300       *
  301       * @return array
  302       */
  303:     public function getRoutes()
  304      {
  305:         return array_values($this->allRoutes);
  306      }
  307  
  308      /**
  309:      * Get all of the routes keyed by their HTTP verb / method.
  310       *
  311       * @return array
  312       */
  313:     public function getRoutesByMethod()
  314      {
  315:         return $this->routes;
  316      }
  317  
  ...
  323      public function getIterator()
  324      {
  325:         return new ArrayIterator($this->getRoutes());
  326      }
  327  
  ...
  333      public function count()
  334      {
  335:         return count($this->getRoutes());
  336      }
  337  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/RouteCompiler.php:
    3  namespace Illuminate\Routing;
    4  
    5: use Symfony\Component\Routing\Route as SymfonyRoute;
    6  
    7: class RouteCompiler
    8  {
    9      /**
   10:      * The route instance.
   11       *
   12:      * @var \Illuminate\Routing\Route
   13       */
   14:     protected $route;
   15  
   16      /**
   17:      * Create a new Route compiler instance.
   18       *
   19:      * @param  \Illuminate\Routing\Route  $route
   20       * @return void
   21       */
   22:     public function __construct($route)
   23      {
   24:         $this->route = $route;
   25      }
   26  
   27      /**
   28:      * Compile the route.
   29       *
   30:      * @return \Symfony\Component\Routing\CompiledRoute
   31       */
   32      public function compile()
   ..
   34          $optionals = $this->getOptionalParameters();
   35  
   36:         $uri = preg_replace('/\{(\w+?)\?\}/', '{$1}', $this->route->uri());
   37  
   38          return (
   39:             new SymfonyRoute($uri, $optionals, $this->route->wheres, [], $this->route->domain() ?: '')
   40          )->compile();
   41      }
   42  
   43      /**
   44:      * Get the optional parameters for the route.
   45       *
   46       * @return array
   ..
   48      protected function getOptionalParameters()
   49      {
   50:         preg_match_all('/\{(\w+?)\?\}/', $this->route->uri(), $matches);
   51  
   52          return isset($matches[1]) ? array_fill_keys($matches[1], null) : [];

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/RouteDependencyResolverTrait.php:
    8  use ReflectionFunctionAbstract;
    9  
   10: trait RouteDependencyResolverTrait
   11  {
   12      /**

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/RouteGroup.php:
    5  use Illuminate\Support\Arr;
    6  
    7: class RouteGroup
    8  {
    9      /**
   10:      * Merge route groups into a new array.
   11       *
   12       * @param  array  $new

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/RouteParameterBinder.php:
    5  use Illuminate\Support\Arr;
    6  
    7: class RouteParameterBinder
    8  {
    9      /**
   10:      * The route instance.
   11       *
   12:      * @var \Illuminate\Routing\Route
   13       */
   14:     protected $route;
   15  
   16      /**
   17:      * Create a new Route parameter binder instance.
   18       *
   19:      * @param  \Illuminate\Routing\Route  $route
   20       * @return void
   21       */
   22:     public function __construct($route)
   23      {
   24:         $this->route = $route;
   25      }
   26  
   27      /**
   28:      * Get the parameters for the route.
   29       *
   30       * @param  \Illuminate\Http\Request  $request
   ..
   33      public function parameters($request)
   34      {
   35:         // If the route has a regular expression for the host part of the URI, we will
   36          // compile that and get the parameter matches for this domain. We will then
   37          // merge them into this parameters array so that this array is completed.
   38          $parameters = $this->bindPathParameters($request);
   39  
   40:         // If the route has a regular expression for the host part of the URI, we will
   41          // compile that and get the parameter matches for this domain. We will then
   42          // merge them into this parameters array so that this array is completed.
   43:         if (! is_null($this->route->compiled->getHostRegex())) {
   44              $parameters = $this->bindHostParameters(
   45                  $request, $parameters
   ..
   60          $path = '/'.ltrim($request->decodedPath(), '/');
   61  
   62:         preg_match($this->route->compiled->getRegex(), $path, $matches);
   63  
   64          return $this->matchToKeys(array_slice($matches, 1));
   ..
   74      protected function bindHostParameters($request, $parameters)
   75      {
   76:         preg_match($this->route->compiled->getHostRegex(), $request->getHost(), $matches);
   77  
   78          return array_merge($this->matchToKeys(array_slice($matches, 1)), $parameters);
   ..
   80  
   81      /**
   82:      * Combine a set of parameter matches with the route's keys.
   83       *
   84       * @param  array  $matches
   ..
   87      protected function matchToKeys(array $matches)
   88      {
   89:         if (empty($parameterNames = $this->route->parameterNames())) {
   90              return [];
   91          }
   ..
  107      {
  108          foreach ($parameters as $key => $value) {
  109:             $parameters[$key] = isset($value) ? $value : Arr::get($this->route->defaults, $key);
  110          }
  111  
  112:         foreach ($this->route->defaults as $key => $value) {
  113              if (! isset($parameters[$key])) {
  114                  $parameters[$key] = $value;

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/RouteRegistrar.php:
    7  use InvalidArgumentException;
    8  
    9: class RouteRegistrar
   10  {
   11      /**
   12:      * The router instance.
   13       *
   14:      * @var \Illuminate\Routing\Router
   15       */
   16:     protected $router;
   17  
   18      /**
   19:      * The attributes to pass on to the router.
   20       *
   21       * @var array
   ..
   24  
   25      /**
   26:      * The methods to dynamically pass through to the router.
   27       *
   28       * @var array
   ..
   51  
   52      /**
   53:      * Create a new route registrar instance.
   54       *
   55:      * @param  \Illuminate\Routing\Router  $router
   56       * @return void
   57       */
   58:     public function __construct(Router $router)
   59      {
   60:         $this->router = $router;
   61      }
   62  
   ..
   82  
   83      /**
   84:      * Route a resource to a controller.
   85       *
   86       * @param  string  $name
   ..
   91      public function resource($name, $controller, array $options = [])
   92      {
   93:         $this->router->resource($name, $controller, $this->attributes + $options);
   94      }
   95  
   96      /**
   97:      * Create a route group with shared attributes.
   98       *
   99       * @param  \Closure|string  $callback
  ...
  102      public function group($callback)
  103      {
  104:         $this->router->group($this->attributes, $callback);
  105      }
  106  
  107      /**
  108:      * Register a new route with the given verbs.
  109       *
  110       * @param  array|string  $methods
  111       * @param  string  $uri
  112       * @param  \Closure|array|string|null  $action
  113:      * @return \Illuminate\Routing\Route
  114       */
  115      public function match($methods, $uri, $action = null)
  116      {
  117:         return $this->router->match($methods, $uri, $this->compileAction($action));
  118      }
  119  
  120      /**
  121:      * Register a new route with the router.
  122       *
  123       * @param  string  $method
  124       * @param  string  $uri
  125       * @param  \Closure|array|string|null  $action
  126:      * @return \Illuminate\Routing\Route
  127       */
  128:     protected function registerRoute($method, $uri, $action = null)
  129      {
  130          if (! is_array($action)) {
  ...
  132          }
  133  
  134:         return $this->router->{$method}($uri, $this->compileAction($action));
  135      }
  136  
  ...
  155  
  156      /**
  157:      * Dynamically handle calls into the route registrar.
  158       *
  159       * @param  string  $method
  160       * @param  array  $parameters
  161:      * @return \Illuminate\Routing\Route|$this
  162       */
  163      public function __call($method, $parameters)
  164      {
  165          if (in_array($method, $this->passthru)) {
  166:             return $this->registerRoute($method, ...$parameters);
  167          }
  168  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/RouteSignatureParameters.php:
    7  use Illuminate\Support\Str;
    8  
    9: class RouteSignatureParameters
   10  {
   11      /**
   12:      * Extract the route action's signature parameters.
   13       *
   14       * @param  array  $action

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/RouteUrlGenerator.php:
    7  use Illuminate\Routing\Exceptions\UrlGenerationException;
    8  
    9: class RouteUrlGenerator
   10  {
   11      /**
   ..
   53  
   54      /**
   55:      * Create a new Route URL generator.
   56       *
   57       * @param  \Illuminate\Routing\UrlGenerator  $url
   ..
   66  
   67      /**
   68:      * Generate a URL for the given route.
   69       *
   70:      * @param  \Illuminate\Routing\Route  $route
   71       * @param  array  $parameters
   72       * @param  bool  $absolute
   ..
   75       * @throws \Illuminate\Routing\Exceptions\UrlGenerationException
   76       */
   77:     public function to($route, $parameters = [], $absolute = false)
   78      {
   79:         $domain = $this->getRouteDomain($route, $parameters);
   80  
   81          // First we will construct the entire URI including the root and query string. Once it
   ..
   83          // will need to throw the exception to let the developers know one was not given.
   84          $uri = $this->addQueryString($this->url->format(
   85:             $root = $this->replaceRootParameters($route, $domain, $parameters),
   86:             $this->replaceRouteParameters($route->uri(), $parameters)
   87          ), $parameters);
   88  
   89          if (preg_match('/\{.*?\}/', $uri)) {
   90:             throw UrlGenerationException::forMissingParameters($route);
   91          }
   92  
   ..
  104  
  105      /**
  106:      * Get the formatted domain for a given route.
  107       *
  108:      * @param  \Illuminate\Routing\Route  $route
  109       * @param  array  $parameters
  110       * @return string
  111       */
  112:     protected function getRouteDomain($route, &$parameters)
  113      {
  114:         return $route->domain() ? $this->formatDomain($route, $parameters) : null;
  115      }
  116  
  117      /**
  118:      * Format the domain and port for the route and request.
  119       *
  120:      * @param  \Illuminate\Routing\Route  $route
  121       * @param  array  $parameters
  122       * @return string
  123       */
  124:     protected function formatDomain($route, &$parameters)
  125      {
  126          return $this->addPortToDomain(
  127:             $this->getRouteScheme($route).$route->domain()
  128          );
  129      }
  130  
  131      /**
  132:      * Get the scheme for the given route.
  133       *
  134:      * @param  \Illuminate\Routing\Route  $route
  135       * @return string
  136       */
  137:     protected function getRouteScheme($route)
  138      {
  139:         if ($route->httpOnly()) {
  140              return 'http://';
  141:         } elseif ($route->httpsOnly()) {
  142              return 'https://';
  143          } else {
  ...
  165       * Replace the parameters on the root path.
  166       *
  167:      * @param  \Illuminate\Routing\Route  $route
  168       * @param  string  $domain
  169       * @param  array  $parameters
  170       * @return string
  171       */
  172:     protected function replaceRootParameters($route, $domain, &$parameters)
  173      {
  174:         $scheme = $this->getRouteScheme($route);
  175  
  176:         return $this->replaceRouteParameters(
  177              $this->url->formatRoot($scheme, $domain), $parameters
  178          );
  ...
  180  
  181      /**
  182:      * Replace all of the wildcard parameters for a route path.
  183       *
  184       * @param  string  $path
  ...
  186       * @return string
  187       */
  188:     protected function replaceRouteParameters($path, array &$parameters)
  189      {
  190          $path = $this->replaceNamedParameters($path, $parameters);
  ...
  235          }
  236  
  237:         $uri .= $this->getRouteQueryString($parameters);
  238  
  239          return is_null($fragment) ? $uri : $uri."#{$fragment}";
  ...
  241  
  242      /**
  243:      * Get the query string for a given route.
  244       *
  245       * @param  array  $parameters
  246       * @return string
  247       */
  248:     protected function getRouteQueryString(array $parameters)
  249      {
  250          // First we will get all of the string parameters that are remaining after we
  251:         // have replaced the route wildcards. We'll then build a query string from
  252          // these string parameters then use it as a starting point for the rest.
  253          if (count($parameters) == 0) {

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/Router.php:
   17  use Symfony\Component\HttpFoundation\Response as SymfonyResponse;
   18  
   19: class Router implements RegistrarContract, BindingRegistrar
   20  {
   21      use Macroable {
   ..
   38  
   39      /**
   40:      * The route collection instance.
   41       *
   42:      * @var \Illuminate\Routing\RouteCollection
   43       */
   44:     protected $routes;
   45  
   46      /**
   47:      * The currently dispatched route instance.
   48       *
   49:      * @var \Illuminate\Routing\Route
   50       */
   51      protected $current;
   ..
   82  
   83      /**
   84:      * The registered route value binders.
   85       *
   86       * @var array
   ..
   96  
   97      /**
   98:      * The route group attribute stack.
   99       *
  100       * @var array
  ...
  103  
  104      /**
  105:      * All of the verbs supported by the router.
  106       *
  107       * @var array
  ...
  110  
  111      /**
  112:      * Create a new Router instance.
  113       *
  114       * @param  \Illuminate\Contracts\Events\Dispatcher  $events
  ...
  119      {
  120          $this->events = $events;
  121:         $this->routes = new RouteCollection;
  122          $this->container = $container ?: new Container;
  123      }
  124  
  125      /**
  126:      * Register a new GET route with the router.
  127       *
  128       * @param  string  $uri
  129       * @param  \Closure|array|string|null  $action
  130:      * @return \Illuminate\Routing\Route
  131       */
  132      public function get($uri, $action = null)
  133      {
  134:         return $this->addRoute(['GET', 'HEAD'], $uri, $action);
  135      }
  136  
  137      /**
  138:      * Register a new POST route with the router.
  139       *
  140       * @param  string  $uri
  141       * @param  \Closure|array|string|null  $action
  142:      * @return \Illuminate\Routing\Route
  143       */
  144      public function post($uri, $action = null)
  145      {
  146:         return $this->addRoute('POST', $uri, $action);
  147      }
  148  
  149      /**
  150:      * Register a new PUT route with the router.
  151       *
  152       * @param  string  $uri
  153       * @param  \Closure|array|string|null  $action
  154:      * @return \Illuminate\Routing\Route
  155       */
  156      public function put($uri, $action = null)
  157      {
  158:         return $this->addRoute('PUT', $uri, $action);
  159      }
  160  
  161      /**
  162:      * Register a new PATCH route with the router.
  163       *
  164       * @param  string  $uri
  165       * @param  \Closure|array|string|null  $action
  166:      * @return \Illuminate\Routing\Route
  167       */
  168      public function patch($uri, $action = null)
  169      {
  170:         return $this->addRoute('PATCH', $uri, $action);
  171      }
  172  
  173      /**
  174:      * Register a new DELETE route with the router.
  175       *
  176       * @param  string  $uri
  177       * @param  \Closure|array|string|null  $action
  178:      * @return \Illuminate\Routing\Route
  179       */
  180      public function delete($uri, $action = null)
  181      {
  182:         return $this->addRoute('DELETE', $uri, $action);
  183      }
  184  
  185      /**
  186:      * Register a new OPTIONS route with the router.
  187       *
  188       * @param  string  $uri
  189       * @param  \Closure|array|string|null  $action
  190:      * @return \Illuminate\Routing\Route
  191       */
  192      public function options($uri, $action = null)
  193      {
  194:         return $this->addRoute('OPTIONS', $uri, $action);
  195      }
  196  
  197      /**
  198:      * Register a new route responding to all verbs.
  199       *
  200       * @param  string  $uri
  201       * @param  \Closure|array|string|null  $action
  202:      * @return \Illuminate\Routing\Route
  203       */
  204      public function any($uri, $action = null)
  ...
  206          $verbs = ['GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE'];
  207  
  208:         return $this->addRoute($verbs, $uri, $action);
  209      }
  210  
  211      /**
  212:      * Register a new route with the given verbs.
  213       *
  214       * @param  array|string  $methods
  215       * @param  string  $uri
  216       * @param  \Closure|array|string|null  $action
  217:      * @return \Illuminate\Routing\Route
  218       */
  219      public function match($methods, $uri, $action = null)
  220      {
  221:         return $this->addRoute(array_map('strtoupper', (array) $methods), $uri, $action);
  222      }
  223  
  ...
  236  
  237      /**
  238:      * Route a resource to a controller.
  239       *
  240       * @param  string  $name
  ...
  255  
  256      /**
  257:      * Route an api resource to a controller.
  258       *
  259       * @param  string  $name
  ...
  270  
  271      /**
  272:      * Create a route group with shared attributes.
  273       *
  274       * @param  array  $attributes
  275:      * @param  \Closure|string  $routes
  276       * @return void
  277       */
  278:     public function group(array $attributes, $routes)
  279      {
  280          $this->updateGroupStack($attributes);
  281  
  282:         // Once we have updated the group stack, we'll load the provided routes and
  283:         // merge in the group's attributes when the routes are created. After we
  284:         // have created the routes, we will pop the attributes off the stack.
  285:         $this->loadRoutes($routes);
  286  
  287          array_pop($this->groupStack);
  ...
  297      {
  298          if (! empty($this->groupStack)) {
  299:             $attributes = RouteGroup::merge($attributes, end($this->groupStack));
  300          }
  301  
  ...
  311      public function mergeWithLastGroup($new)
  312      {
  313:         return RouteGroup::merge($new, end($this->groupStack));
  314      }
  315  
  316      /**
  317:      * Load the provided routes.
  318       *
  319:      * @param  \Closure|string  $routes
  320       * @return void
  321       */
  322:     protected function loadRoutes($routes)
  323      {
  324:         if ($routes instanceof Closure) {
  325:             $routes($this);
  326          } else {
  327:             $router = $this;
  328  
  329:             require $routes;
  330          }
  331      }
  ...
  348  
  349      /**
  350:      * Add a route to the underlying route collection.
  351       *
  352       * @param  array|string  $methods
  353       * @param  string  $uri
  354       * @param  \Closure|array|string|null  $action
  355:      * @return \Illuminate\Routing\Route
  356       */
  357:     protected function addRoute($methods, $uri, $action)
  358      {
  359:         return $this->routes->add($this->createRoute($methods, $uri, $action));
  360      }
  361  
  362      /**
  363:      * Create a new route instance.
  364       *
  365       * @param  array|string  $methods
  366       * @param  string  $uri
  367       * @param  mixed  $action
  368:      * @return \Illuminate\Routing\Route
  369       */
  370:     protected function createRoute($methods, $uri, $action)
  371      {
  372:         // If the route is routing to a controller we will parse the route action into
  373:         // an acceptable array format before registering it and creating this route
  374          // instance itself. We need to build the Closure that will call this out.
  375          if ($this->actionReferencesController($action)) {
  ...
  377          }
  378  
  379:         $route = $this->newRoute(
  380              $methods, $this->prefix($uri), $action
  381          );
  382  
  383          // If we have groups that need to be merged, we will merge them now after this
  384:         // route has already been created and is ready to go. After we're done with
  385:         // the merge we will be ready to return the route back out to the caller.
  386          if ($this->hasGroupStack()) {
  387:             $this->mergeGroupAttributesIntoRoute($route);
  388          }
  389  
  390:         $this->addWhereClausesToRoute($route);
  391  
  392:         return $route;
  393      }
  394  
  ...
  409  
  410      /**
  411:      * Add a controller based route action to the action array.
  412       *
  413       * @param  array|string  $action
  ...
  450  
  451      /**
  452:      * Create a new Route object.
  453       *
  454       * @param  array|string  $methods
  455       * @param  string  $uri
  456       * @param  mixed  $action
  457:      * @return \Illuminate\Routing\Route
  458       */
  459:     protected function newRoute($methods, $uri, $action)
  460      {
  461:         return (new Route($methods, $uri, $action))
  462:                     ->setRouter($this)
  463                      ->setContainer($this->container);
  464      }
  ...
  476  
  477      /**
  478:      * Add the necessary where clauses to the route based on its initial registration.
  479       *
  480:      * @param  \Illuminate\Routing\Route  $route
  481:      * @return \Illuminate\Routing\Route
  482       */
  483:     protected function addWhereClausesToRoute($route)
  484      {
  485:         $route->where(array_merge(
  486:             $this->patterns, isset($route->getAction()['where']) ? $route->getAction()['where'] : []
  487          ));
  488  
  489:         return $route;
  490      }
  491  
  ...
  493       * Merge the group stack with the controller action.
  494       *
  495:      * @param  \Illuminate\Routing\Route  $route
  496       * @return void
  497       */
  498:     protected function mergeGroupAttributesIntoRoute($route)
  499      {
  500:         $route->setAction($this->mergeWithLastGroup($route->getAction()));
  501      }
  502  
  ...
  511          $this->currentRequest = $request;
  512  
  513:         return $this->dispatchToRoute($request);
  514      }
  515  
  516      /**
  517:      * Dispatch the request to a route and return the response.
  518       *
  519       * @param  \Illuminate\Http\Request  $request
  520       * @return mixed
  521       */
  522:     public function dispatchToRoute(Request $request)
  523      {
  524:         // First we will find a route that matches this request. We will also set the
  525:         // route resolver on the request so middlewares assigned to the route will
  526:         // receive access to this route instance for checking of the parameters.
  527:         $route = $this->findRoute($request);
  528  
  529:         $request->setRouteResolver(function () use ($route) {
  530:             return $route;
  531          });
  532  
  533:         $this->events->dispatch(new Events\RouteMatched($route, $request));
  534  
  535:         $response = $this->runRouteWithinStack($route, $request);
  536  
  537          return $this->prepareResponse($request, $response);
  ...
  539  
  540      /**
  541:      * Find the route matching a given request.
  542       *
  543       * @param  \Illuminate\Http\Request  $request
  544:      * @return \Illuminate\Routing\Route
  545       */
  546:     protected function findRoute($request)
  547      {
  548:         $this->current = $route = $this->routes->match($request);
  549  
  550:         $this->container->instance(Route::class, $route);
  551  
  552:         return $route;
  553      }
  554  
  555      /**
  556:      * Run the given route within a Stack "onion" instance.
  557       *
  558:      * @param  \Illuminate\Routing\Route  $route
  559       * @param  \Illuminate\Http\Request  $request
  560       * @return mixed
  561       */
  562:     protected function runRouteWithinStack(Route $route, Request $request)
  563      {
  564          $shouldSkipMiddleware = $this->container->bound('middleware.disable') &&
  565                                  $this->container->make('middleware.disable') === true;
  566  
  567:         $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddleware($route);
  568  
  569          return (new Pipeline($this->container))
  570                          ->send($request)
  571                          ->through($middleware)
  572:                         ->then(function ($request) use ($route) {
  573                              return $this->prepareResponse(
  574:                                 $request, $route->run()
  575                              );
  576                          });
  ...
  578  
  579      /**
  580:      * Gather the middleware for the given route with resolved class names.
  581       *
  582:      * @param  \Illuminate\Routing\Route  $route
  583       * @return array
  584       */
  585:     public function gatherRouteMiddleware(Route $route)
  586      {
  587:         $middleware = collect($route->gatherMiddleware())->map(function ($name) {
  588              return (array) MiddlewareNameResolver::resolve($name, $this->middleware, $this->middlewareGroups);
  589          })->flatten();
  ...
  622  
  623      /**
  624:      * Substitute the route bindings onto the route.
  625       *
  626:      * @param  \Illuminate\Routing\Route  $route
  627:      * @return \Illuminate\Routing\Route
  628       */
  629:     public function substituteBindings($route)
  630      {
  631:         foreach ($route->parameters() as $key => $value) {
  632              if (isset($this->binders[$key])) {
  633:                 $route->setParameter($key, $this->performBinding($key, $value, $route));
  634              }
  635          }
  636  
  637:         return $route;
  638      }
  639  
  640      /**
  641:      * Substitute the implicit Eloquent model bindings for the route.
  642       *
  643:      * @param  \Illuminate\Routing\Route  $route
  644       * @return void
  645       */
  646:     public function substituteImplicitBindings($route)
  647      {
  648:         ImplicitRouteBinding::resolveForRoute($this->container, $route);
  649      }
  650  
  ...
  654       * @param  string  $key
  655       * @param  string  $value
  656:      * @param  \Illuminate\Routing\Route  $route
  657       * @return mixed
  658       */
  659:     protected function performBinding($key, $value, $route)
  660      {
  661:         return call_user_func($this->binders[$key], $value, $route);
  662      }
  663  
  664      /**
  665:      * Register a route matched event listener.
  666       *
  667       * @param  string|callable  $callback
  ...
  670      public function matched($callback)
  671      {
  672:         $this->events->listen(Events\RouteMatched::class, $callback);
  673      }
  674  
  ...
  773  
  774      /**
  775:      * Add a new route parameter binder.
  776       *
  777       * @param  string  $key
  ...
  781      public function bind($key, $binder)
  782      {
  783:         $this->binders[str_replace('-', '_', $key)] = RouteBinding::forCallback(
  784              $this->container, $binder
  785          );
  ...
  798      public function model($key, $class, Closure $callback = null)
  799      {
  800:         $this->bind($key, RouteBinding::forModel($this->container, $class, $callback));
  801      }
  802  
  ...
  825  
  826      /**
  827:      * Set a global where pattern on all routes.
  828       *
  829       * @param  string  $key
  ...
  837  
  838      /**
  839:      * Set a group of global where patterns on all routes.
  840       *
  841       * @param  array  $patterns
  ...
  850  
  851      /**
  852:      * Determine if the router currently has a group stack.
  853       *
  854       * @return bool
  ...
  860  
  861      /**
  862:      * Get the current group stack for the router.
  863       *
  864       * @return array
  ...
  870  
  871      /**
  872:      * Get a route parameter for the current route.
  873       *
  874       * @param  string  $key
  ...
  892  
  893      /**
  894:      * Get the currently dispatched route instance.
  895       *
  896:      * @return \Illuminate\Routing\Route
  897       */
  898:     public function getCurrentRoute()
  899      {
  900          return $this->current();
  ...
  902  
  903      /**
  904:      * Get the currently dispatched route instance.
  905       *
  906:      * @return \Illuminate\Routing\Route
  907       */
  908      public function current()
  ...
  912  
  913      /**
  914:      * Check if a route with the given name exists.
  915       *
  916       * @param  string  $name
  ...
  919      public function has($name)
  920      {
  921:         return $this->routes->hasNamedRoute($name);
  922      }
  923  
  924      /**
  925:      * Get the current route name.
  926       *
  927       * @return string|null
  928       */
  929:     public function currentRouteName()
  930      {
  931          return $this->current() ? $this->current()->getName() : null;
  ...
  933  
  934      /**
  935:      * Alias for the "currentRouteNamed" method.
  936       *
  937       * @return bool
  ...
  940      {
  941          foreach (func_get_args() as $pattern) {
  942:             if (Str::is($pattern, $this->currentRouteName())) {
  943                  return true;
  944              }
  ...
  949  
  950      /**
  951:      * Determine if the current route matches a given name.
  952       *
  953       * @param  string  $name
  954       * @return bool
  955       */
  956:     public function currentRouteNamed($name)
  957      {
  958          return $this->current() ? $this->current()->named($name) : false;
  ...
  960  
  961      /**
  962:      * Get the current route action.
  963       *
  964       * @return string|null
  965       */
  966:     public function currentRouteAction()
  967      {
  968          if (! $this->current()) {
  ...
  976  
  977      /**
  978:      * Alias for the "currentRouteUses" method.
  979       *
  980       * @return bool
  ...
  983      {
  984          foreach (func_get_args() as $pattern) {
  985:             if (Str::is($pattern, $this->currentRouteAction())) {
  986                  return true;
  987              }
  ...
  992  
  993      /**
  994:      * Determine if the current route action matches a given action.
  995       *
  996       * @param  string  $action
  997       * @return bool
  998       */
  999:     public function currentRouteUses($action)
 1000      {
 1001:         return $this->currentRouteAction() == $action;
 1002      }
 1003  
 1004      /**
 1005:      * Register the typical authentication routes for an application.
 1006       *
 1007       * @return void
 ....
 1009      public function auth()
 1010      {
 1011:         // Authentication Routes...
 1012          $this->get('login', 'Auth\LoginController@showLoginForm')->name('login');
 1013          $this->post('login', 'Auth\LoginController@login');
 1014          $this->post('logout', 'Auth\LoginController@logout')->name('logout');
 1015  
 1016:         // Registration Routes...
 1017          $this->get('register', 'Auth\RegisterController@showRegistrationForm')->name('register');
 1018          $this->post('register', 'Auth\RegisterController@register');
 1019  
 1020:         // Password Reset Routes...
 1021          $this->get('password/reset', 'Auth\ForgotPasswordController@showLinkRequestForm')->name('password.request');
 1022          $this->post('password/email', 'Auth\ForgotPasswordController@sendResetLinkEmail')->name('password.email');
 ....
 1059  
 1060      /**
 1061:      * Get the underlying route collection.
 1062       *
 1063:      * @return \Illuminate\Routing\RouteCollection
 1064       */
 1065:     public function getRoutes()
 1066      {
 1067:         return $this->routes;
 1068      }
 1069  
 1070      /**
 1071:      * Set the route collection instance.
 1072       *
 1073:      * @param  \Illuminate\Routing\RouteCollection  $routes
 1074       * @return void
 1075       */
 1076:     public function setRoutes(RouteCollection $routes)
 1077      {
 1078:         foreach ($routes as $route) {
 1079:             $route->setRouter($this)->setContainer($this->container);
 1080          }
 1081  
 1082:         $this->routes = $routes;
 1083  
 1084:         $this->container->instance('routes', $this->routes);
 1085      }
 1086  
 1087      /**
 1088:      * Dynamically handle calls into the router instance.
 1089       *
 1090       * @param  string  $method
 ....
 1098          }
 1099  
 1100:         return (new RouteRegistrar($this))->attribute($method, $parameters[0]);
 1101      }
 1102  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/RoutingServiceProvider.php:
   20      public function register()
   21      {
   22:         $this->registerRouter();
   23  
   24          $this->registerUrlGenerator();
   ..
   34  
   35      /**
   36:      * Register the router instance.
   37       *
   38       * @return void
   39       */
   40:     protected function registerRouter()
   41      {
   42:         $this->app->singleton('router', function ($app) {
   43:             return new Router($app['events'], $app);
   44          });
   45      }
   ..
   53      {
   54          $this->app->singleton('url', function ($app) {
   55:             $routes = $app['router']->getRoutes();
   56  
   57:             // The URL generator needs the route collection that exists on the router.
   58              // Keep in mind this is an object, so we're passing by references here
   59:             // and all the registered routes will be available to the generator.
   60:             $app->instance('routes', $routes);
   61  
   62              $url = new UrlGenerator(
   63:                 $routes, $app->rebinding(
   64                      'request', $this->requestRebinder()
   65                  )
   ..
   70              });
   71  
   72:             // If the route collection is "rebound", for example, when the routes stay
   73:             // cached for the application, we will need to rebind the routes on the
   74:             // URL generator instance so it has the latest version of the routes.
   75:             $app->rebinding('routes', function ($app, $routes) {
   76:                 $app['url']->setRoutes($routes);
   77              });
   78  

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Routing/UrlGenerator.php:
   16  
   17      /**
   18:      * The route collection.
   19       *
   20:      * @var \Illuminate\Routing\RouteCollection
   21       */
   22:     protected $routes;
   23  
   24      /**
   ..
   86  
   87      /**
   88:      * The route URL generator instance.
   89       *
   90:      * @var \Illuminate\Routing\RouteUrlGenerator
   91       */
   92:     protected $routeGenerator;
   93  
   94      /**
   95       * Create a new URL Generator instance.
   96       *
   97:      * @param  \Illuminate\Routing\RouteCollection  $routes
   98       * @param  \Illuminate\Http\Request  $request
   99       * @return void
  100       */
  101:     public function __construct(RouteCollection $routes, Request $request)
  102      {
  103:         $this->routes = $routes;
  104  
  105          $this->setRequest($request);
  ...
  219          // Once we get the root URL, we will check to see if it contains an index.php
  220          // file in the paths. If it does, we will remove it since it is not needed
  221:         // for asset paths, but only for routes to endpoints in the application.
  222          $root = $this->formatRoot($this->formatScheme($secure));
  223  
  ...
  248          // Once we get the root URL, we will check to see if it contains an index.php
  249          // file in the paths. If it does, we will remove it since it is not needed
  250:         // for asset paths, but only for routes to endpoints in the application.
  251          $root = $this->formatRoot($this->formatScheme($secure), $root);
  252  
  ...
  287  
  288      /**
  289:      * Get the URL to a named route.
  290       *
  291       * @param  string  $name
  ...
  296       * @throws \InvalidArgumentException
  297       */
  298:     public function route($name, $parameters = [], $absolute = true)
  299      {
  300:         if (! is_null($route = $this->routes->getByName($name))) {
  301:             return $this->toRoute($route, $parameters, $absolute);
  302          }
  303  
  304:         throw new InvalidArgumentException("Route [{$name}] not defined.");
  305      }
  306  
  307      /**
  308:      * Get the URL for a given route instance.
  309       *
  310:      * @param  \Illuminate\Routing\Route  $route
  311       * @param  mixed  $parameters
  312       * @param  bool   $absolute
  ...
  315       * @throws \Illuminate\Routing\Exceptions\UrlGenerationException
  316       */
  317:     protected function toRoute($route, $parameters, $absolute)
  318      {
  319:         return $this->routeUrl()->to(
  320:             $route, $this->formatParameters($parameters), $absolute
  321          );
  322      }
  ...
  334      public function action($action, $parameters = [], $absolute = true)
  335      {
  336:         if (is_null($route = $this->routes->getByAction($action = $this->formatAction($action)))) {
  337              throw new InvalidArgumentException("Action {$action} not defined.");
  338          }
  339  
  340:         return $this->toRoute($route, $parameters, $absolute);
  341      }
  342  
  ...
  368          foreach ($parameters as $key => $parameter) {
  369              if ($parameter instanceof UrlRoutable) {
  370:                 $parameters[$key] = $parameter->getRouteKey();
  371              }
  372          }
  ...
  453  
  454      /**
  455:      * Get the Route URL generator instance.
  456       *
  457:      * @return \Illuminate\Routing\RouteUrlGenerator
  458       */
  459:     protected function routeUrl()
  460      {
  461:         if (! $this->routeGenerator) {
  462:             $this->routeGenerator = new RouteUrlGenerator($this, $this->request);
  463          }
  464  
  465:         return $this->routeGenerator;
  466      }
  467  
  ...
  474      public function defaults(array $defaults)
  475      {
  476:         $this->routeUrl()->defaults($defaults);
  477      }
  478  
  ...
  563          $this->cachedRoot = null;
  564          $this->cachedSchema = null;
  565:         $this->routeGenerator = null;
  566      }
  567  
  568      /**
  569:      * Set the route collection.
  570       *
  571:      * @param  \Illuminate\Routing\RouteCollection  $routes
  572       * @return $this
  573       */
  574:     public function setRoutes(RouteCollection $routes)
  575      {
  576:         $this->routes = $routes;
  577  
  578          return $this;

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Session/Middleware/StartSession.php:
  156      protected function storeCurrentUrl(Request $request, $session)
  157      {
  158:         if ($request->method() === 'GET' && $request->route() && ! $request->ajax()) {
  159              $session->setPreviousUrl($request->fullUrl());
  160          }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Support/Facades/Auth.php:
   38  
   39      /**
   40:      * Register the typical authentication routes for an application.
   41       *
   42       * @return void
   43       */
   44:     public static function routes()
   45      {
   46:         static::$app->make('router')->auth();
   47      }
   48  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Support/Facades/Route.php:
    4  
    5  /**
    6:  * @method static \Illuminate\Routing\Route get(string $uri, \Closure|array|string $action)
    7:  * @method static \Illuminate\Routing\Route post(string $uri, \Closure|array|string $action)
    8:  * @method static \Illuminate\Routing\Route put(string $uri, \Closure|array|string $action)
    9:  * @method static \Illuminate\Routing\Route delete(string $uri, \Closure|array|string $action)
   10:  * @method static \Illuminate\Routing\Route patch(string $uri, \Closure|array|string $action)
   11:  * @method static \Illuminate\Routing\Route options(string $uri, \Closure|array|string $action)
   12:  * @method static \Illuminate\Routing\Route any(string $uri, \Closure|array|string $action)
   13:  * @method static \Illuminate\Routing\Route match(array|string $methods, string $uri, \Closure|array|string $action)
   14   * @method static void resource(string $name, string $controller, array $options = [])
   15   * @method static void apiResource(string $name, string $controller, array $options = [])
   16   * @method static void group(array $attributes, \Closure $callback)
   17:  * @method static \Illuminate\Routing\Route middleware(array|string|null $middleware)
   18:  * @method static \Illuminate\Routing\Route substituteBindings(\Illuminate\Routing\Route $route)
   19:  * @method static void substituteImplicitBindings(\Illuminate\Routing\Route $route)
   20   *
   21:  * @see \Illuminate\Routing\Router
   22   */
   23: class Route extends Facade
   24  {
   25      /**
   ..
   30      protected static function getFacadeAccessor()
   31      {
   32:         return 'router';
   33      }
   34  }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/framework/src/Illuminate/Support/ServiceProvider.php:
   61  
   62      /**
   63:      * Load the given routes file if routes are not already cached.
   64       *
   65       * @param  string  $path
   66       * @return void
   67       */
   68:     protected function loadRoutesFrom($path)
   69      {
   70:         if (! $this->app->routesAreCached()) {
   71              require $path;
   72          }

/home/dila/Videos/HOWKEMASTER/vendor/laravel/tinker/src/TinkerCaster.php:
   18          'environmentFile',
   19          'isLocal',
   20:         'routesAreCached',
   21          'runningUnitTests',
   22          'version',

/home/dila/Videos/HOWKEMASTER/vendor/mockery/mockery/docs/reference/partial_mocks.rst:
   70      $mock = \Mockery::mock(new MyClass);
   71  
   72: Yes, the new mock is a Proxy. It intercepts calls and reroutes them to the
   73  proxied object (which you construct and pass in) for methods which are not
   74  subject to any expectations. Indirectly, this allows you to mock methods

/home/dila/Videos/HOWKEMASTER/vendor/monolog/monolog/doc/01-usage.md:
   38  
   39  You can create many `Logger`s, each defining a channel (e.g.: db, request,
   40: router, ..) and each of them combining various handlers, which can be shared
   41  or not. The channel is reflected in the logs and allows you to easily see or
   42  filter records.

/home/dila/Videos/HOWKEMASTER/vendor/swiftmailer/swiftmailer/lib/mime_types.php:
  402      'les' => 'application/vnd.hhe.lesson-player',
  403      'lha' => 'application/x-lzh-compressed',
  404:     'link66' => 'application/vnd.route66.link66+xml',
  405      'list' => 'text/plain',
  406      'list3820' => 'application/vnd.ibm.modcap',

/home/dila/Videos/HOWKEMASTER/vendor/swiftmailer/swiftmailer/tests/unit/Swift/Transport/AbstractSmtpTest.php:
  211              Path = "<" [ A-d-l ":" ] Mailbox ">"
  212              A-d-l = At-domain *( "," A-d-l )
  213:                         ; Note that this form, the so-called "source route",
  214                          ; MUST BE accepted, SHOULD NOT be generated, and SHOULD be
  215                          ; ignored.
  ...
  369          The forward-path normally consists of the required destination
  370          mailbox.  Sending systems SHOULD not generate the optional list of
  371:         hosts known as a source route.
  372  
  373          .......

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-foundation/File/MimeType/MimeTypeExtensionGuesser.php:
  418          'application/vnd.rn-realmedia' => 'rm',
  419          'application/vnd.rn-realmedia-vbr' => 'rmvb',
  420:         'application/vnd.route66.link66+xml' => 'link66',
  421          'application/vnd.sailingtracker.track' => 'st',
  422          'application/vnd.seemail' => 'see',

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-kernel/CHANGELOG.md:
   40   * removed `Symfony\Component\HttpKernel\EventListener\FragmentListener::getLocalIpAddresses()`
   41   * removed `Symfony\Component\HttpKernel\EventListener\LocaleListener::setRequest()`
   42:  * removed `Symfony\Component\HttpKernel\EventListener\RouterListener::setRequest()`
   43   * removed `Symfony\Component\HttpKernel\EventListener\ProfilerListener::onKernelRequest()`
   44   * removed `Symfony\Component\HttpKernel\Fragment\FragmentHandler::setRequest()`
   ..
  125   * added ContainerAwareTraceableEventDispatcher
  126   * moved TraceableEventDispatcherInterface to the EventDispatcher component
  127:  * added RouterListener, LocaleListener, and StreamedResponseListener
  128   * added CacheClearerInterface (and ChainCacheClearer)
  129   * added a kernel.terminate event (via TerminableInterface and PostResponseEvent)

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-kernel/DataCollector/RequestDataCollector.php:
   42          // attributes are serialized and as they can be anything, they need to be converted to strings.
   43          $attributes = array();
   44:         $route = '';
   45          foreach ($request->attributes->all() as $key => $value) {
   46:             if ('_route' === $key) {
   47:                 $route = is_object($value) ? $value->getPath() : $value;
   48:                 $attributes[$key] = $route;
   49              } else {
   50                  $attributes[$key] = $value;
   ..
   95              'request_cookies' => $request->cookies->all(),
   96              'request_attributes' => $attributes,
   97:             'route' => $route,
   98              'response_headers' => $response->headers->all(),
   99              'response_cookies' => $responseCookies,
  ...
  140                  $session->set('sf_redirect', array(
  141                      'token' => $response->headers->get('x-debug-token'),
  142:                     'route' => $request->attributes->get('_route', 'n/a'),
  143                      'method' => $request->getMethod(),
  144                      'controller' => $this->parseController($request->attributes->get('_controller')),
  ...
  149          }
  150  
  151:         $this->data['identifier'] = $this->data['route'] ?: (is_array($this->data['controller']) ? $this->data['controller']['class'].'::'.$this->data['controller']['method'].'()' : $this->data['controller']);
  152      }
  153  
  ...
  253  
  254      /**
  255:      * Gets the route name.
  256       *
  257:      * The _route request attributes is automatically set by the Router Matcher.
  258       *
  259:      * @return string The route
  260       */
  261:     public function getRoute()
  262      {
  263:         return $this->data['route'];
  264      }
  265  
  ...
  270  
  271      /**
  272:      * Gets the route parameters.
  273       *
  274:      * The _route_params request attributes is automatically set by the RouterListener.
  275       *
  276       * @return array The parameters
  277       */
  278:     public function getRouteParams()
  279      {
  280:         return isset($this->data['request_attributes']['_route_params']) ? $this->data['request_attributes']['_route_params']->getValue() : array();
  281      }
  282  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-kernel/DataCollector/RouterDataCollector.php:
   18  
   19  /**
   20:  * RouterDataCollector.
   21   *
   22   * @author Fabien Potencier <fabien@symfony.com>
   23   */
   24: class RouterDataCollector extends DataCollector
   25  {
   26      protected $controllers;
   ..
   33              'redirect' => false,
   34              'url' => null,
   35:             'route' => null,
   36          );
   37      }
   ..
   47  
   48              if ($this->controllers->contains($request)) {
   49:                 $this->data['route'] = $this->guessRoute($request, $this->controllers[$request]);
   50              }
   51          }
   ..
   54      }
   55  
   56:     protected function guessRoute(Request $request, $controller)
   57      {
   58          return 'n/a';
   ..
   86  
   87      /**
   88:      * @return string|null The target route
   89       */
   90:     public function getTargetRoute()
   91      {
   92:         return $this->data['route'];
   93      }
   94  
   ..
   98      public function getName()
   99      {
  100:         return 'router';
  101      }
  102  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-kernel/EventListener/FragmentListener.php:
   75          parse_str($request->query->get('_path', ''), $attributes);
   76          $request->attributes->add($attributes);
   77:         $request->attributes->set('_route_params', array_replace($request->attributes->get('_route_params', array()), $attributes));
   78          $request->query->remove('_path');
   79      }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-kernel/EventListener/LocaleListener.php:
   27  class LocaleListener implements EventSubscriberInterface
   28  {
   29:     private $router;
   30      private $defaultLocale;
   31      private $requestStack;
   ..
   36       * @param RequestStack                      $requestStack  A RequestStack instance
   37       * @param string                            $defaultLocale The default locale
   38:      * @param RequestContextAwareInterface|null $router        The router
   39       */
   40:     public function __construct(RequestStack $requestStack, $defaultLocale = 'en', RequestContextAwareInterface $router = null)
   41      {
   42          $this->defaultLocale = $defaultLocale;
   43          $this->requestStack = $requestStack;
   44:         $this->router = $router;
   45      }
   46  
   ..
   51  
   52          $this->setLocale($request);
   53:         $this->setRouterContext($request);
   54      }
   55  
   ..
   57      {
   58          if (null !== $parentRequest = $this->requestStack->getParentRequest()) {
   59:             $this->setRouterContext($parentRequest);
   60          }
   61      }
   ..
   68      }
   69  
   70:     private function setRouterContext(Request $request)
   71      {
   72:         if (null !== $this->router) {
   73:             $this->router->getContext()->setParameter('_locale', $request->getLocale());
   74          }
   75      }
   ..
   78      {
   79          return array(
   80:             // must be registered after the Router to have access to the _locale
   81              KernelEvents::REQUEST => array(array('onKernelRequest', 16)),
   82              KernelEvents::FINISH_REQUEST => array(array('onKernelFinishRequest', 0)),

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-kernel/EventListener/RouterListener.php:
   29  
   30  /**
   31:  * Initializes the context from the request and sets request attributes based on a matching route.
   32   *
   33   * @author Fabien Potencier <fabien@symfony.com>
   34   */
   35: class RouterListener implements EventSubscriberInterface
   36  {
   37      private $matcher;
   ..
  105  
  106              if (null !== $this->logger) {
  107:                 $this->logger->info('Matched route "{route}".', array(
  108:                     'route' => isset($parameters['_route']) ? $parameters['_route'] : 'n/a',
  109:                     'route_parameters' => $parameters,
  110                      'request_uri' => $request->getUri(),
  111                      'method' => $request->getMethod(),
  ...
  114  
  115              $request->attributes->add($parameters);
  116:             unset($parameters['_route'], $parameters['_controller']);
  117:             $request->attributes->set('_route_params', $parameters);
  118          } catch (ResourceNotFoundException $e) {
  119:             $message = sprintf('No route found for "%s %s"', $request->getMethod(), $request->getPathInfo());
  120  
  121              if ($referer = $request->headers->get('referer')) {
  ...
  125              throw new NotFoundHttpException($message, $e);
  126          } catch (MethodNotAllowedException $e) {
  127:             $message = sprintf('No route found for "%s %s": Method Not Allowed (Allow: %s)', $request->getMethod(), $request->getPathInfo(), implode(', ', $e->getAllowedMethods()));
  128  
  129              throw new MethodNotAllowedHttpException($e->getAllowedMethods(), $message, $e);

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-kernel/Fragment/RoutableFragmentRenderer.php:
   56          // a proper routing pattern to do the job for us.
   57          // This makes things inconsistent if you switch from rendering a controller
   58:         // to rendering a route if the route pattern does not contain the special
   59          // _format and _locale placeholders.
   60          if (!isset($reference->attributes['_format'])) {

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-kernel/HttpKernel.php:
  135          // load controller
  136          if (false === $controller = $this->resolver->getController($request)) {
  137:             throw new NotFoundHttpException(sprintf('Unable to find the controller for path "%s". The route is wrongly configured.', $request->getPathInfo()));
  138          }
  139  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-kernel/Tests/DataCollector/RequestDataCollectorTest.php:
   48          $this->assertInstanceOf(ParameterBag::class, $c->getResponseCookies());
   49          $this->assertSame('html', $c->getFormat());
   50:         $this->assertEquals('foobar', $c->getRoute());
   51:         $this->assertEquals(array('name' => 'foo'), $c->getRouteParams());
   52          $this->assertSame(array(), $c->getSessionAttributes());
   53          $this->assertSame('en', $c->getLocale());
   ..
   61      }
   62  
   63:     public function testCollectWithoutRouteParams()
   64      {
   65          $request = $this->createRequest(array());
   ..
   69          $c->lateCollect();
   70  
   71:         $this->assertEquals(array(), $c->getRouteParams());
   72      }
   73  
   ..
  211      }
  212  
  213:     protected function createRequest($routeParams = array('name' => 'foo'))
  214      {
  215          $request = Request::create('http://test.com/foo?bar=baz');
  216          $request->attributes->set('foo', 'bar');
  217:         $request->attributes->set('_route', 'foobar');
  218:         $request->attributes->set('_route_params', $routeParams);
  219          $request->attributes->set('resource', fopen(__FILE__, 'r'));
  220          $request->attributes->set('object', new \stdClass());

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-kernel/Tests/EventListener/FragmentListenerTest.php:
   21  class FragmentListenerTest extends TestCase
   22  {
   23:     public function testOnlyTriggeredOnFragmentRoute()
   24      {
   25          $request = Request::create('http://example.com/foo?_path=foo%3Dbar%26_controller%3Dfoo');
   ..
   87          $listener->onKernelRequest($event);
   88  
   89:         $this->assertEquals(array('foo' => 'bar', '_controller' => 'foo'), $request->attributes->get('_route_params'));
   90          $this->assertFalse($request->query->has('_path'));
   91      }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-kernel/Tests/EventListener/LocaleListenerTest.php:
   56          $context->expects($this->once())->method('setParameter')->with('_locale', 'es');
   57  
   58:         $router = $this->getMockBuilder('Symfony\Component\Routing\Router')->setMethods(array('getContext'))->disableOriginalConstructor()->getMock();
   59:         $router->expects($this->once())->method('getContext')->will($this->returnValue($context));
   60  
   61          $request = Request::create('/');
   62  
   63          $request->attributes->set('_locale', 'es');
   64:         $listener = new LocaleListener($this->requestStack, 'fr', $router);
   65          $listener->onKernelRequest($this->getEvent($request));
   66      }
   67  
   68:     public function testRouterResetWithParentRequestOnKernelFinishRequest()
   69      {
   70          // the request context is updated
   ..
   72          $context->expects($this->once())->method('setParameter')->with('_locale', 'es');
   73  
   74:         $router = $this->getMockBuilder('Symfony\Component\Routing\Router')->setMethods(array('getContext'))->disableOriginalConstructor()->getMock();
   75:         $router->expects($this->once())->method('getContext')->will($this->returnValue($context));
   76  
   77          $parentRequest = Request::create('/');
   ..
   82          $event = $this->getMockBuilder('Symfony\Component\HttpKernel\Event\FinishRequestEvent')->disableOriginalConstructor()->getMock();
   83  
   84:         $listener = new LocaleListener($this->requestStack, 'fr', $router);
   85          $listener->onKernelFinishRequest($event);
   86      }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/http-kernel/Tests/EventListener/RouterListenerTest.php:
   20  use Symfony\Component\HttpKernel\Controller\ControllerResolver;
   21  use Symfony\Component\HttpKernel\EventListener\ExceptionListener;
   22: use Symfony\Component\HttpKernel\EventListener\RouterListener;
   23  use Symfony\Component\HttpKernel\EventListener\ValidateRequestListener;
   24  use Symfony\Component\HttpKernel\HttpKernelInterface;
   ..
   27  use Symfony\Component\Routing\RequestContext;
   28  
   29: class RouterListenerTest extends TestCase
   30  {
   31      private $requestStack;
   ..
   51              ->will($this->returnValue($context));
   52  
   53:         $listener = new RouterListener($urlMatcher, $this->requestStack);
   54          $event = $this->createGetResponseEventForUri($uri);
   55          $listener->onKernelRequest($event);
   ..
   89      public function testInvalidMatcher()
   90      {
   91:         new RouterListener(new \stdClass(), $this->requestStack);
   92      }
   93  
   ..
  104                         ->will($this->returnValue(array()));
  105  
  106:         $listener = new RouterListener($requestMatcher, $this->requestStack, new RequestContext());
  107          $listener->onKernelRequest($event);
  108      }
  ...
  122          $context = new RequestContext();
  123  
  124:         $listener = new RouterListener($requestMatcher, $this->requestStack, new RequestContext());
  125          $listener->onKernelRequest($event);
  126  
  ...
  153          $request = Request::create('http://localhost/');
  154  
  155:         $listener = new RouterListener($requestMatcher, $this->requestStack, new RequestContext(), $logger);
  156          $listener->onKernelRequest(new GetResponseEvent($kernel, $request, HttpKernelInterface::MASTER_REQUEST));
  157      }
  ...
  160      {
  161          return array(
  162:             array(array('_route' => 'foo'), 'Matched route "{route}".', array('route' => 'foo', 'route_parameters' => array('_route' => 'foo'), 'request_uri' => 'http://localhost/', 'method' => 'GET')),
  163:             array(array(), 'Matched route "{route}".', array('route' => 'n/a', 'route_parameters' => array(), 'request_uri' => 'http://localhost/', 'method' => 'GET')),
  164          );
  165      }
  ...
  174          $dispatcher = new EventDispatcher();
  175          $dispatcher->addSubscriber(new ValidateRequestListener());
  176:         $dispatcher->addSubscriber(new RouterListener($requestMatcher, $requestStack, new RequestContext()));
  177          $dispatcher->addSubscriber(new ExceptionListener(function () {
  178              return new Response('Exception handled', 400);

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Annotation/Route.php:
   13  
   14  /**
   15:  * Annotation class for @Route().
   16   *
   17   * @Annotation
   ..
   20   * @author Fabien Potencier <fabien@symfony.com>
   21   */
   22: class Route
   23  {
   24      private $path;

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/CHANGELOG.md:
    6  
    7    * [DEPRECATION] Class parameters have been deprecated and will be removed in 4.0.
    8:     * router.options.generator_class
    9:     * router.options.generator_base_class
   10:     * router.options.generator_dumper_class
   11:     * router.options.matcher_class
   12:     * router.options.matcher_base_class
   13:     * router.options.matcher_dumper_class
   14:     * router.options.matcher.cache_class
   15:     * router.options.generator.cache_class
   16  
   17  3.2.0
   ..
   25  
   26   * allowed specifying a directory to recursively load all routing configuration files it contains
   27:  * Added ObjectRouteLoader and ServiceRouteLoader that allow routes to be loaded
   28     by calling a method on an object/service.
   29   * [DEPRECATION] Deprecated the hardcoded value for the `$referenceType` argument of the `UrlGeneratorInterface::generate` method.
   ..
   33  
   34     ```php
   35:    $router->generate('blog_show', array('slug' => 'my-blog-post'), true);
   36     ```
   37  
   ..
   41     use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
   42  
   43:    $router->generate('blog_show', array('slug' => 'my-blog-post'), UrlGeneratorInterface::ABSOLUTE_URL);
   44     ```
   45  
   ..
   59  -----
   60  
   61:  * [DEPRECATION] Several route settings have been renamed (the old ones will be removed in 3.0):
   62  
   63:     * The `pattern` setting for a route has been deprecated in favor of `path`
   64      * The `_scheme` and `_method` requirements have been moved to the `schemes` and `methods` settings
   65  
   ..
   73  
   74     ```xml
   75:    <route id="article_edit" pattern="/article/{id}">
   76         <requirement key="_method">POST|PUT</requirement>
   77         <requirement key="_scheme">https</requirement>
   78         <requirement key="id">\d+</requirement>
   79:    </route>
   80     ```
   81  
   82     ```php
   83:    $route = new Route();
   84:    $route->setPattern('/article/{id}');
   85:    $route->setRequirement('_method', 'POST|PUT');
   86:    $route->setRequirement('_scheme', 'https');
   87     ```
   88  
   ..
   98  
   99     ```xml
  100:    <route id="article_edit" pattern="/article/{id}" methods="POST PUT" schemes="https">
  101         <requirement key="id">\d+</requirement>
  102:    </route>
  103     ```
  104  
  105     ```php
  106:    $route = new Route();
  107:    $route->setPath('/article/{id}');
  108:    $route->setMethods(array('POST', 'PUT'));
  109:    $route->setSchemes('https');
  110     ```
  111  
  112:  * [BC BREAK] RouteCollection does not behave like a tree structure anymore but as
  113:    a flat array of Routes. So when using PHP to build the RouteCollection, you must
  114:    make sure to add routes to the sub-collection before adding it to the parent
  115:    collection (this is not relevant when using YAML or XML for Route definitions).
  116  
  117     Before:
  118  
  119     ```php
  120:    $rootCollection = new RouteCollection();
  121:    $subCollection = new RouteCollection();
  122     $rootCollection->addCollection($subCollection);
  123:    $subCollection->add('foo', new Route('/foo'));
  124     ```
  125  
  ...
  127  
  128     ```php
  129:    $rootCollection = new RouteCollection();
  130:    $subCollection = new RouteCollection();
  131:    $subCollection->add('foo', new Route('/foo'));
  132     $rootCollection->addCollection($subCollection);
  133     ```
  ...
  141     ```
  142  
  143:  * [DEPRECATION] The methods `RouteCollection::getParent()` and `RouteCollection::getRoot()`
  144     have been deprecated and will be removed in Symfony 2.3.
  145:  * [BC BREAK] Misusing the `RouteCollection::addPrefix` method to add defaults, requirements
  146     or options without adding a prefix is not supported anymore. So if you called `addPrefix`
  147     with an empty prefix or `/` only (both have no relevance), like
  ...
  149     you need to use the new dedicated methods `addDefaults($defaultsArray)`,
  150     `addRequirements($requirementsArray)` or `addOptions($optionsArray)` instead.
  151:  * [DEPRECATION] The `$options` parameter to `RouteCollection::addPrefix()` has been deprecated
  152     because adding options has nothing to do with adding a path prefix. If you want to add options
  153:    to all child routes of a RouteCollection, you can use `addOptions()`.
  154:  * [DEPRECATION] The method `RouteCollection::getPrefix()` has been deprecated
  155:    because it suggested that all routes in the collection would have this prefix, which is
  156     not necessarily true. On top of that, since there is no tree structure anymore, this method
  157     is also useless. Don't worry about performance, prefix optimization for matching is still done
  158     in the dumper, which was also improved in 2.2.0 to find even more grouping possibilities.
  159:  * [DEPRECATION] `RouteCollection::addCollection(RouteCollection $collection)` should now only be
  160     used with a single parameter. The other params `$prefix`, `$default`, `$requirements` and `$options`
  161     will still work, but have been deprecated. The `addPrefix` method should be used for this
  ...
  167     $parentCollection->addCollection($collection);
  168     ```
  169:  * added support for the method default argument values when defining a @Route
  170   * Adjacent placeholders without separator work now, e.g. `/{x}{y}{z}.{_format}`.
  171   * Characters that function as separator between placeholders are now whitelisted
  172:    to fix routes with normal text around a variable, e.g. `/prefix{var}suffix`.
  173   * [BC BREAK] The default requirement of a variable has been changed slightly.
  174     Previously it disallowed the previous and the next char around a variable. Now
  175     it disallows the slash (`/`) and the next char. Using the previous char added
  176:    no value and was problematic because the route `/index.{_format}` would be
  177     matched by `/index.ht/ml`.
  178   * The default requirement now uses possessive quantifiers when possible which
  ...
  183     improves performance in production environment as you should know that params always
  184     pass the requirements (otherwise it would break your link anyway).
  185:  * There is no restriction on the route name anymore. So non-alphanumeric characters
  186     are now also allowed.
  187:  * [BC BREAK] `RouteCompilerInterface::compile(Route $route)` was made static
  188:    (only relevant if you implemented your own RouteCompiler).
  189   * Added possibility to generate relative paths and network paths in the UrlGenerator, e.g.
  190     "../parent-file" and "//example.com/dir/file". The third parameter in
  ...
  203   * added TraceableUrlMatcher
  204   * added the possibility to define options, default values and requirements
  205:    for placeholders in prefix, including imported routes
  206:  * added RouterInterface::getRouteCollection
  207:  * [BC BREAK] the UrlMatcher urldecodes the route parameters only once, they
  208     were decoded twice before. Note that the `urldecode()` calls have been
  209     changed for a single `rawurldecode()` in order to support `+` for input
  210     paths.
  211:  * added RouteCollection::getRoot method to retrieve the root of a
  212:    RouteCollection tree
  213:  * [BC BREAK] made RouteCollection::setParent private which could not have
  214     been used anyway without creating inconsistencies
  215:  * [BC BREAK] RouteCollection::remove also removes a route from parent
  216     collections (not only from its children)
  217   * added ConfigurableRequirementsInterface that allows to disable exceptions
  218:    (and generate empty URLs instead) when generating a route with an invalid
  219     parameter value
  220  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/CompiledRoute.php:
   13  
   14  /**
   15:  * CompiledRoutes are returned by the RouteCompiler class.
   16   *
   17   * @author Fabien Potencier <fabien@symfony.com>
   18   */
   19: class CompiledRoute implements \Serializable
   20  {
   21      private $variables;
   ..
   31       * Constructor.
   32       *
   33:      * @param string      $staticPrefix  The static prefix of the compiled route
   34:      * @param string      $regex         The regular expression to use to match this route
   35:      * @param array       $tokens        An array of tokens to use to generate URL for this route
   36       * @param array       $pathVariables An array of path variables
   37       * @param string|null $hostRegex     Host regex

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Exception/MissingMandatoryParametersException.php:
   13  
   14  /**
   15:  * Exception thrown when a route cannot be generated because of missing
   16   * mandatory parameters.
   17   *

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Exception/RouteNotFoundException.php:
   13  
   14  /**
   15:  * Exception thrown when a route does not exist.
   16   *
   17   * @author Alexandre Salomé <alexandre.salome@gmail.com>
   18   */
   19: class RouteNotFoundException extends \InvalidArgumentException implements ExceptionInterface
   20  {
   21  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Generator/Dumper/GeneratorDumper.php:
   12  namespace Symfony\Component\Routing\Generator\Dumper;
   13  
   14: use Symfony\Component\Routing\RouteCollection;
   15  
   16  /**
   ..
   22  {
   23      /**
   24:      * @var RouteCollection
   25       */
   26:     private $routes;
   27  
   28      /**
   29       * Constructor.
   30       *
   31:      * @param RouteCollection $routes The RouteCollection to dump
   32       */
   33:     public function __construct(RouteCollection $routes)
   34      {
   35:         $this->routes = $routes;
   36      }
   37  
   ..
   39       * {@inheritdoc}
   40       */
   41:     public function getRoutes()
   42      {
   43:         return $this->routes;
   44      }
   45  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Generator/Dumper/GeneratorDumperInterface.php:
   12  namespace Symfony\Component\Routing\Generator\Dumper;
   13  
   14: use Symfony\Component\Routing\RouteCollection;
   15  
   16  /**
   ..
   22  {
   23      /**
   24:      * Dumps a set of routes to a string representation of executable code
   25:      * that can then be used to generate a URL of such a route.
   26       *
   27       * @param array $options An array of options
   ..
   32  
   33      /**
   34:      * Gets the routes to dump.
   35       *
   36:      * @return RouteCollection A RouteCollection instance
   37       */
   38:     public function getRoutes();
   39  }
   40  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Generator/Dumper/PhpGeneratorDumper.php:
   13  
   14  /**
   15:  * PhpGeneratorDumper creates a PHP class able to generate URLs for a given set of routes.
   16   *
   17   * @author Fabien Potencier <fabien@symfony.com>
   ..
   21  {
   22      /**
   23:      * Dumps a set of routes to a PHP class.
   24       *
   25       * Available options:
   ..
   43  
   44  use Symfony\Component\Routing\RequestContext;
   45: use Symfony\Component\Routing\Exception\RouteNotFoundException;
   46  use Psr\Log\LoggerInterface;
   47  
   ..
   54  class {$options['class']} extends {$options['base_class']}
   55  {
   56:     private static \$declaredRoutes;
   57  
   58      /**
   ..
   63          \$this->context = \$context;
   64          \$this->logger = \$logger;
   65:         if (null === self::\$declaredRoutes) {
   66:             self::\$declaredRoutes = {$this->generateDeclaredRoutes()};
   67          }
   68      }
   ..
   75  
   76      /**
   77:      * Generates PHP code representing an array of defined routes
   78:      * together with the routes properties (e.g. requirements).
   79       *
   80       * @return string PHP code
   81       */
   82:     private function generateDeclaredRoutes()
   83      {
   84:         $routes = "array(\n";
   85:         foreach ($this->getRoutes()->all() as $name => $route) {
   86:             $compiledRoute = $route->compile();
   87  
   88              $properties = array();
   89:             $properties[] = $compiledRoute->getVariables();
   90:             $properties[] = $route->getDefaults();
   91:             $properties[] = $route->getRequirements();
   92:             $properties[] = $compiledRoute->getTokens();
   93:             $properties[] = $compiledRoute->getHostTokens();
   94:             $properties[] = $route->getSchemes();
   95  
   96:             $routes .= sprintf("        '%s' => %s,\n", $name, str_replace("\n", '', var_export($properties, true)));
   97          }
   98:         $routes .= '    )';
   99  
  100:         return $routes;
  101      }
  102  
  ...
  111      public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH)
  112      {
  113:         if (!isset(self::$declaredRoutes[$name])) {
  114:             throw new RouteNotFoundException(sprintf('Unable to generate a URL for the named route "%s" as such route does not exist.', $name));
  115          }
  116  
  117:         list($variables, $defaults, $requirements, $tokens, $hostTokens, $requiredSchemes) = self::$declaredRoutes[$name];
  118  
  119          return $this->doGenerate($variables, $defaults, $requirements, $tokens, $parameters, $name, $referenceType, $hostTokens, $requiredSchemes);

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Generator/UrlGenerator.php:
   12  namespace Symfony\Component\Routing\Generator;
   13  
   14: use Symfony\Component\Routing\RouteCollection;
   15  use Symfony\Component\Routing\RequestContext;
   16  use Symfony\Component\Routing\Exception\InvalidParameterException;
   17: use Symfony\Component\Routing\Exception\RouteNotFoundException;
   18  use Symfony\Component\Routing\Exception\MissingMandatoryParametersException;
   19  use Psr\Log\LoggerInterface;
   20  
   21  /**
   22:  * UrlGenerator can generate a URL or a path for any route in the RouteCollection
   23   * based on the passed parameters.
   24   *
   ..
   29  {
   30      /**
   31:      * @var RouteCollection
   32       */
   33:     protected $routes;
   34  
   35      /**
   ..
   79       * Constructor.
   80       *
   81:      * @param RouteCollection      $routes  A RouteCollection instance
   82       * @param RequestContext       $context The context
   83       * @param LoggerInterface|null $logger  A logger instance
   84       */
   85:     public function __construct(RouteCollection $routes, RequestContext $context, LoggerInterface $logger = null)
   86      {
   87:         $this->routes = $routes;
   88          $this->context = $context;
   89          $this->logger = $logger;
   ..
  127      public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH)
  128      {
  129:         if (null === $route = $this->routes->get($name)) {
  130:             throw new RouteNotFoundException(sprintf('Unable to generate a URL for the named route "%s" as such route does not exist.', $name));
  131          }
  132  
  133:         // the Route has a cache of its own and is not recompiled as long as it does not get modified
  134:         $compiledRoute = $route->compile();
  135  
  136:         return $this->doGenerate($compiledRoute->getVariables(), $route->getDefaults(), $route->getRequirements(), $compiledRoute->getTokens(), $parameters, $name, $referenceType, $compiledRoute->getHostTokens(), $route->getSchemes());
  137      }
  138  
  139      /**
  140:      * @throws MissingMandatoryParametersException When some parameters are missing that are mandatory for the route
  141       * @throws InvalidParameterException           When a parameter value for a placeholder is not correct because
  142       *                                             it does not match the requirement
  ...
  149          // all params must be given
  150          if ($diff = array_diff_key($variables, $mergedParams)) {
  151:             throw new MissingMandatoryParametersException(sprintf('Some mandatory parameters are missing ("%s") to generate a URL for route "%s".', implode('", "', array_keys($diff)), $name));
  152          }
  153  
  154          $url = '';
  155          $optional = true;
  156:         $message = 'Parameter "{parameter}" for route "{route}" must match "{expected}" ("{given}" given) to generate a corresponding URL.';
  157          foreach ($tokens as $token) {
  158              if ('variable' === $token[0]) {
  ...
  161                      if (null !== $this->strictRequirements && !preg_match('#^'.$token[2].'$#'.(empty($token[4]) ? '' : 'u'), $mergedParams[$token[3]])) {
  162                          if ($this->strictRequirements) {
  163:                             throw new InvalidParameterException(strtr($message, array('{parameter}' => $token[3], '{route}' => $name, '{expected}' => $token[2], '{given}' => $mergedParams[$token[3]])));
  164                          }
  165  
  166                          if ($this->logger) {
  167:                             $this->logger->error($message, array('parameter' => $token[3], 'route' => $name, 'expected' => $token[2], 'given' => $mergedParams[$token[3]]));
  168                          }
  169  
  ...
  190          // the path segments "." and ".." are interpreted as relative reference when resolving a URI; see http://tools.ietf.org/html/rfc3986#section-3.3
  191          // so we need to encode them as they are not used for this purpose here
  192:         // otherwise we would generate a URI that, when followed by a user agent (e.g. browser), does not match this route
  193          $url = strtr($url, array('/../' => '/%2E%2E/', '/./' => '/%2E/'));
  194          if ('/..' === substr($url, -3)) {
  ...
  210  
  211              if ($hostTokens) {
  212:                 $routeHost = '';
  213                  foreach ($hostTokens as $token) {
  214                      if ('variable' === $token[0]) {
  215                          if (null !== $this->strictRequirements && !preg_match('#^'.$token[2].'$#i'.(empty($token[4]) ? '' : 'u'), $mergedParams[$token[3]])) {
  216                              if ($this->strictRequirements) {
  217:                                 throw new InvalidParameterException(strtr($message, array('{parameter}' => $token[3], '{route}' => $name, '{expected}' => $token[2], '{given}' => $mergedParams[$token[3]])));
  218                              }
  219  
  220                              if ($this->logger) {
  221:                                 $this->logger->error($message, array('parameter' => $token[3], 'route' => $name, 'expected' => $token[2], 'given' => $mergedParams[$token[3]]));
  222                              }
  223  
  ...
  225                          }
  226  
  227:                         $routeHost = $token[1].$mergedParams[$token[3]].$routeHost;
  228                      } else {
  229:                         $routeHost = $token[1].$routeHost;
  230                      }
  231                  }
  232  
  233:                 if ($routeHost !== $host) {
  234:                     $host = $routeHost;
  235                      if (self::ABSOLUTE_URL !== $referenceType) {
  236                          $referenceType = self::NETWORK_PATH;

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Generator/UrlGeneratorInterface.php:
   14  use Symfony\Component\Routing\Exception\InvalidParameterException;
   15  use Symfony\Component\Routing\Exception\MissingMandatoryParametersException;
   16: use Symfony\Component\Routing\Exception\RouteNotFoundException;
   17  use Symfony\Component\Routing\RequestContextAwareInterface;
   18  
   ..
   56  
   57      /**
   58:      * Generates a URL or path for a specific route based on the given parameters.
   59       *
   60:      * Parameters that reference placeholders in the route pattern will substitute them in the
   61       * path or host. Extra params are added as query string to the URL.
   62       *
   63:      * When the passed reference type cannot be generated for the route because it requires a different
   64       * host or scheme than the current one, the method will return a more comprehensive reference
   65       * that includes the required params. For example, when you call this method with $referenceType = ABSOLUTE_PATH
   66:      * but the route requires the https scheme whereas the current scheme is http, it will instead return an
   67       * ABSOLUTE_URL with the https scheme and the current host. This makes sure the generated URL matches
   68:      * the route in any case.
   69       *
   70:      * If there is no route with the given name, the generator must throw the RouteNotFoundException.
   71       *
   72       * The special parameter _fragment will be used as the document fragment suffixed to the final URL.
   73       *
   74:      * @param string $name          The name of the route
   75       * @param mixed  $parameters    An array of parameters
   76       * @param int    $referenceType The type of reference to be generated (one of the constants)
   ..
   78       * @return string The generated URL
   79       *
   80:      * @throws RouteNotFoundException              If the named route doesn't exist
   81:      * @throws MissingMandatoryParametersException When some parameters are missing that are mandatory for the route
   82       * @throws InvalidParameterException           When a parameter value for a placeholder is not correct because
   83       *                                             it does not match the requirement

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Loader/AnnotationClassLoader.php:
   14  use Doctrine\Common\Annotations\Reader;
   15  use Symfony\Component\Config\Resource\FileResource;
   16: use Symfony\Component\Routing\Route;
   17: use Symfony\Component\Routing\RouteCollection;
   18  use Symfony\Component\Config\Loader\LoaderInterface;
   19  use Symfony\Component\Config\Loader\LoaderResolverInterface;
   ..
   22   * AnnotationClassLoader loads routing information from a PHP class and its methods.
   23   *
   24:  * You need to define an implementation for the getRouteDefaults() method. Most of the
   25:  * time, this method should define some PHP callable to be called for the route
   26   * (a controller in MVC speak).
   27   *
   28:  * The @Route annotation can be set on the class (for global parameters),
   29   * and on each method.
   30   *
   31:  * The @Route annotation main value is the route path. The annotation also
   32   * recognizes several parameters: requirements, options, defaults, schemes,
   33   * methods, host, and name. The name parameter is mandatory.
   ..
   35   *
   36   *     /**
   37:  *      * @Route("/Blog")
   38   *      * /
   39   *     class Blog
   40   *     {
   41   *         /**
   42:  *          * @Route("/", name="blog_index")
   43   *          * /
   44   *         public function index()
   ..
   47   *
   48   *         /**
   49:  *          * @Route("/{id}", name="blog_post", requirements = {"id" = "\d+"})
   50   *          * /
   51   *         public function show()
   ..
   66       * @var string
   67       */
   68:     protected $routeAnnotationClass = 'Symfony\\Component\\Routing\\Annotation\\Route';
   69  
   70      /**
   71       * @var int
   72       */
   73:     protected $defaultRouteIndex = 0;
   74  
   75      /**
   ..
   84  
   85      /**
   86:      * Sets the annotation class to read route properties from.
   87       *
   88       * @param string $class A fully-qualified class name
   89       */
   90:     public function setRouteAnnotationClass($class)
   91      {
   92:         $this->routeAnnotationClass = $class;
   93      }
   94  
   ..
   99       * @param string|null $type  The resource type
  100       *
  101:      * @return RouteCollection A RouteCollection instance
  102       *
  103:      * @throws \InvalidArgumentException When route can't be parsed
  104       */
  105      public function load($class, $type = null)
  ...
  116          $globals = $this->getGlobals($class);
  117  
  118:         $collection = new RouteCollection();
  119          $collection->addResource(new FileResource($class->getFileName()));
  120  
  121          foreach ($class->getMethods() as $method) {
  122:             $this->defaultRouteIndex = 0;
  123              foreach ($this->reader->getMethodAnnotations($method) as $annot) {
  124:                 if ($annot instanceof $this->routeAnnotationClass) {
  125:                     $this->addRoute($collection, $annot, $globals, $class, $method);
  126                  }
  127              }
  128          }
  129  
  130:         if (0 === $collection->count() && $class->hasMethod('__invoke') && $annot = $this->reader->getClassAnnotation($class, $this->routeAnnotationClass)) {
  131              $globals['path'] = '';
  132:             $this->addRoute($collection, $annot, $globals, $class, $class->getMethod('__invoke'));
  133          }
  134  
  ...
  136      }
  137  
  138:     protected function addRoute(RouteCollection $collection, $annot, $globals, \ReflectionClass $class, \ReflectionMethod $method)
  139      {
  140          $name = $annot->getName();
  141          if (null === $name) {
  142:             $name = $this->getDefaultRouteName($class, $method);
  143          }
  144  
  ...
  164          }
  165  
  166:         $route = $this->createRoute($globals['path'].$annot->getPath(), $defaults, $requirements, $options, $host, $schemes, $methods, $condition);
  167  
  168:         $this->configureRoute($route, $class, $method, $annot);
  169  
  170:         $collection->add($name, $route);
  171      }
  172  
  ...
  194  
  195      /**
  196:      * Gets the default route name for a class method.
  197       *
  198       * @param \ReflectionClass  $class
  ...
  201       * @return string
  202       */
  203:     protected function getDefaultRouteName(\ReflectionClass $class, \ReflectionMethod $method)
  204      {
  205          $name = strtolower(str_replace('\\', '_', $class->name).'_'.$method->name);
  206:         if ($this->defaultRouteIndex > 0) {
  207:             $name .= '_'.$this->defaultRouteIndex;
  208          }
  209:         ++$this->defaultRouteIndex;
  210  
  211          return $name;
  ...
  225          );
  226  
  227:         if ($annot = $this->reader->getClassAnnotation($class, $this->routeAnnotationClass)) {
  228              if (null !== $annot->getPath()) {
  229                  $globals['path'] = $annot->getPath();
  ...
  262      }
  263  
  264:     protected function createRoute($path, $defaults, $requirements, $options, $host, $schemes, $methods, $condition)
  265      {
  266:         return new Route($path, $defaults, $requirements, $options, $host, $schemes, $methods, $condition);
  267      }
  268  
  269:     abstract protected function configureRoute(Route $route, \ReflectionClass $class, \ReflectionMethod $method, $annot);
  270  }
  271  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Loader/AnnotationDirectoryLoader.php:
   12  namespace Symfony\Component\Routing\Loader;
   13  
   14: use Symfony\Component\Routing\RouteCollection;
   15  use Symfony\Component\Config\Resource\DirectoryResource;
   16  
   ..
   29       * @param string|null $type The resource type
   30       *
   31:      * @return RouteCollection A RouteCollection instance
   32       *
   33:      * @throws \InvalidArgumentException When the directory does not exist or its routes cannot be parsed
   34       */
   35      public function load($path, $type = null)
   ..
   37          $dir = $this->locator->locate($path);
   38  
   39:         $collection = new RouteCollection();
   40          $collection->addResource(new DirectoryResource($dir, '/\.php$/'));
   41          $files = iterator_to_array(new \RecursiveIteratorIterator(

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Loader/AnnotationFileLoader.php:
   12  namespace Symfony\Component\Routing\Loader;
   13  
   14: use Symfony\Component\Routing\RouteCollection;
   15  use Symfony\Component\Config\Resource\FileResource;
   16  use Symfony\Component\Config\Loader\FileLoader;
   ..
   52       * @param string|null $type The resource type
   53       *
   54:      * @return RouteCollection A RouteCollection instance
   55       *
   56:      * @throws \InvalidArgumentException When the file does not exist or its routes cannot be parsed
   57       */
   58      public function load($file, $type = null)
   ..
   60          $path = $this->locator->locate($file);
   61  
   62:         $collection = new RouteCollection();
   63          if ($class = $this->findClass($path)) {
   64              $collection->addResource(new FileResource($path));

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Loader/ClosureLoader.php:
   13  
   14  use Symfony\Component\Config\Loader\Loader;
   15: use Symfony\Component\Routing\RouteCollection;
   16  
   17  /**
   18:  * ClosureLoader loads routes from a PHP closure.
   19   *
   20:  * The Closure must return a RouteCollection instance.
   21   *
   22   * @author Fabien Potencier <fabien@symfony.com>
   ..
   30       * @param string|null $type    The resource type
   31       *
   32:      * @return RouteCollection A RouteCollection instance
   33       */
   34      public function load($closure, $type = null)

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Loader/DependencyInjection/ServiceRouterLoader.php:
   13  
   14  use Psr\Container\ContainerInterface;
   15: use Symfony\Component\Routing\Loader\ObjectRouteLoader;
   16  
   17  /**
   18:  * A route loader that executes a service to load the routes.
   19   *
   20   * This depends on the DependencyInjection component.
   ..
   22   * @author Ryan Weaver <ryan@knpuniversity.com>
   23   */
   24: class ServiceRouterLoader extends ObjectRouteLoader
   25  {
   26      /**

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Loader/DirectoryLoader.php:
   13  
   14  use Symfony\Component\Config\Loader\FileLoader;
   15: use Symfony\Component\Routing\RouteCollection;
   16  use Symfony\Component\Config\Resource\DirectoryResource;
   17  
   ..
   25          $path = $this->locator->locate($file);
   26  
   27:         $collection = new RouteCollection();
   28          $collection->addResource(new DirectoryResource($path));
   29  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Loader/ObjectRouteLoader.php:
   14  use Symfony\Component\Config\Loader\Loader;
   15  use Symfony\Component\Config\Resource\FileResource;
   16: use Symfony\Component\Routing\RouteCollection;
   17  
   18  /**
   19:  * A route loader that calls a method on an object to load the routes.
   20   *
   21   * @author Ryan Weaver <ryan@knpuniversity.com>
   22   */
   23: abstract class ObjectRouteLoader extends Loader
   24  {
   25      /**
   26:      * Returns the object that the method will be called on to load routes.
   27       *
   28       * For example, if your application uses a service container,
   ..
   36  
   37      /**
   38:      * Calls the service that will load the routes.
   39       *
   40       * @param mixed       $resource Some value that will resolve to a callable
   41       * @param string|null $type     The resource type
   42       *
   43:      * @return RouteCollection
   44       */
   45      public function load($resource, $type = null)
   ..
   47          $parts = explode(':', $resource);
   48          if (count($parts) != 2) {
   49:             throw new \InvalidArgumentException(sprintf('Invalid resource "%s" passed to the "service" route loader: use the format "service_name:methodName"', $resource));
   50          }
   51  
   ..
   63          }
   64  
   65:         $routeCollection = call_user_func(array($loaderObject, $method), $this);
   66  
   67:         if (!$routeCollection instanceof RouteCollection) {
   68:             $type = is_object($routeCollection) ? get_class($routeCollection) : gettype($routeCollection);
   69  
   70:             throw new \LogicException(sprintf('The %s::%s method must return a RouteCollection: %s returned', get_class($loaderObject), $method, $type));
   71          }
   72  
   73          // make the service file tracked so that if it changes, the cache rebuilds
   74:         $this->addClassResource(new \ReflectionClass($loaderObject), $routeCollection);
   75  
   76:         return $routeCollection;
   77      }
   78  
   ..
   85      }
   86  
   87:     private function addClassResource(\ReflectionClass $class, RouteCollection $collection)
   88      {
   89          do {

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Loader/PhpFileLoader.php:
   14  use Symfony\Component\Config\Loader\FileLoader;
   15  use Symfony\Component\Config\Resource\FileResource;
   16: use Symfony\Component\Routing\RouteCollection;
   17  
   18  /**
   19:  * PhpFileLoader loads routes from a PHP file.
   20   *
   21:  * The file must return a RouteCollection instance.
   22   *
   23   * @author Fabien Potencier <fabien@symfony.com>
   ..
   31       * @param string|null $type The resource type
   32       *
   33:      * @return RouteCollection A RouteCollection instance
   34       */
   35      public function load($file, $type = null)
   ..
   58       * @param PhpFileLoader $loader the loader variable is exposed to the included file below
   59       *
   60:      * @return RouteCollection
   61       */
   62      private static function includeFile($file, PhpFileLoader $loader)

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Loader/XmlFileLoader.php:
   12  namespace Symfony\Component\Routing\Loader;
   13  
   14: use Symfony\Component\Routing\RouteCollection;
   15: use Symfony\Component\Routing\Route;
   16  use Symfony\Component\Config\Resource\FileResource;
   17  use Symfony\Component\Config\Loader\FileLoader;
   ..
   35       * @param string|null $type The resource type
   36       *
   37:      * @return RouteCollection A RouteCollection instance
   38       *
   39       * @throws \InvalidArgumentException When the file cannot be loaded or when the XML cannot be
   ..
   46          $xml = $this->loadFile($path);
   47  
   48:         $collection = new RouteCollection();
   49          $collection->addResource(new FileResource($path));
   50  
   51:         // process routes and imports
   52          foreach ($xml->documentElement->childNodes as $node) {
   53              if (!$node instanceof \DOMElement) {
   ..
   64       * Parses a node from a loaded XML file.
   65       *
   66:      * @param RouteCollection $collection Collection to associate with the node
   67       * @param \DOMElement     $node       Element to parse
   68       * @param string          $path       Full path of the XML file being processed
   ..
   71       * @throws \InvalidArgumentException When the XML is invalid
   72       */
   73:     protected function parseNode(RouteCollection $collection, \DOMElement $node, $path, $file)
   74      {
   75          if (self::NAMESPACE_URI !== $node->namespaceURI) {
   ..
   78  
   79          switch ($node->localName) {
   80:             case 'route':
   81:                 $this->parseRoute($collection, $node, $path);
   82                  break;
   83              case 'import':
   ..
   85                  break;
   86              default:
   87:                 throw new \InvalidArgumentException(sprintf('Unknown tag "%s" used in file "%s". Expected "route" or "import".', $node->localName, $path));
   88          }
   89      }
   ..
   98  
   99      /**
  100:      * Parses a route and adds it to the RouteCollection.
  101       *
  102:      * @param RouteCollection $collection RouteCollection instance
  103:      * @param \DOMElement     $node       Element to parse that represents a Route
  104       * @param string          $path       Full path of the XML file being processed
  105       *
  106       * @throws \InvalidArgumentException When the XML is invalid
  107       */
  108:     protected function parseRoute(RouteCollection $collection, \DOMElement $node, $path)
  109      {
  110          if ('' === ($id = $node->getAttribute('id')) || !$node->hasAttribute('path')) {
  111:             throw new \InvalidArgumentException(sprintf('The <route> element in file "%s" must have an "id" and a "path" attribute.', $path));
  112          }
  113  
  ...
  117          list($defaults, $requirements, $options, $condition) = $this->parseConfigs($node, $path);
  118  
  119:         $route = new Route($node->getAttribute('path'), $defaults, $requirements, $options, $node->getAttribute('host'), $schemes, $methods, $condition);
  120:         $collection->add($id, $route);
  121      }
  122  
  123      /**
  124:      * Parses an import and adds the routes in the resource to the RouteCollection.
  125       *
  126:      * @param RouteCollection $collection RouteCollection instance
  127:      * @param \DOMElement     $node       Element to parse that represents a Route
  128       * @param string          $path       Full path of the XML file being processed
  129       * @param string          $file       Loaded file name
  ...
  131       * @throws \InvalidArgumentException When the XML is invalid
  132       */
  133:     protected function parseImport(RouteCollection $collection, \DOMElement $node, $path, $file)
  134      {
  135          if ('' === $resource = $node->getAttribute('resource')) {
  ...
  148  
  149          $subCollection = $this->import($resource, ('' !== $type ? $type : null), false, $file);
  150:         /* @var $subCollection RouteCollection */
  151          $subCollection->addPrefix($prefix);
  152          if (null !== $host) {

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Loader/YamlFileLoader.php:
   12  namespace Symfony\Component\Routing\Loader;
   13  
   14: use Symfony\Component\Routing\RouteCollection;
   15: use Symfony\Component\Routing\Route;
   16  use Symfony\Component\Config\Resource\FileResource;
   17  use Symfony\Component\Yaml\Exception\ParseException;
   ..
   39       * @param string|null $type The resource type
   40       *
   41:      * @return RouteCollection A RouteCollection instance
   42       *
   43:      * @throws \InvalidArgumentException When a route can't be parsed because YAML is invalid
   44       */
   45      public function load($file, $type = null)
   ..
   65          }
   66  
   67:         $collection = new RouteCollection();
   68          $collection->addResource(new FileResource($path));
   69  
   ..
   84                  $this->parseImport($collection, $config, $path, $file);
   85              } else {
   86:                 $this->parseRoute($collection, $name, $config, $path);
   87              }
   88          }
   ..
  100  
  101      /**
  102:      * Parses a route and adds it to the RouteCollection.
  103       *
  104:      * @param RouteCollection $collection A RouteCollection instance
  105:      * @param string          $name       Route name
  106:      * @param array           $config     Route definition
  107       * @param string          $path       Full path of the YAML file being processed
  108       */
  109:     protected function parseRoute(RouteCollection $collection, $name, array $config, $path)
  110      {
  111          $defaults = isset($config['defaults']) ? $config['defaults'] : array();
  ...
  117          $condition = isset($config['condition']) ? $config['condition'] : null;
  118  
  119:         $route = new Route($config['path'], $defaults, $requirements, $options, $host, $schemes, $methods, $condition);
  120  
  121:         $collection->add($name, $route);
  122      }
  123  
  124      /**
  125:      * Parses an import and adds the routes in the resource to the RouteCollection.
  126       *
  127:      * @param RouteCollection $collection A RouteCollection instance
  128:      * @param array           $config     Route definition
  129       * @param string          $path       Full path of the YAML file being processed
  130       * @param string          $file       Loaded file name
  131       */
  132:     protected function parseImport(RouteCollection $collection, array $config, $path, $file)
  133      {
  134          $type = isset($config['type']) ? $config['type'] : null;
  ...
  145  
  146          $subCollection = $this->import($config['resource'], $type, false, $file);
  147:         /* @var $subCollection RouteCollection */
  148          $subCollection->addPrefix($prefix);
  149          if (null !== $host) {
  ...
  167  
  168      /**
  169:      * Validates the route configuration.
  170       *
  171       * @param array  $config A resource config
  ...
  189          if (isset($config['resource']) && isset($config['path'])) {
  190              throw new \InvalidArgumentException(sprintf(
  191:                 'The routing file "%s" must not specify both the "resource" key and the "path" key for "%s". Choose between an import and a route definition.',
  192                  $path, $name
  193              ));
  ...
  195          if (!isset($config['resource']) && isset($config['type'])) {
  196              throw new \InvalidArgumentException(sprintf(
  197:                 'The "type" key for the route definition "%s" in "%s" is unsupported. It is only available for imports in combination with the "resource" key.',
  198                  $name, $path
  199              ));
  ...
  201          if (!isset($config['resource']) && !isset($config['path'])) {
  202              throw new \InvalidArgumentException(sprintf(
  203:                 'You must define a "path" for the route "%s" in file "%s".',
  204                  $name, $path
  205              ));

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Loader/schema/routing/routing-1.0.xsd:
   12  
   13        This scheme defines the elements and attributes that can be used to define
   14:       routes. A route maps an HTTP request to a set of configuration variables.
   15      ]]></xsd:documentation>
   16    </xsd:annotation>
   17  
   18:   <xsd:element name="routes" type="routes" />
   19  
   20:   <xsd:complexType name="routes">
   21      <xsd:choice minOccurs="0" maxOccurs="unbounded">
   22        <xsd:element name="import" type="import" />
   23:       <xsd:element name="route" type="route" />
   24      </xsd:choice>
   25    </xsd:complexType>
   ..
   34    </xsd:group>
   35  
   36:   <xsd:complexType name="route">
   37      <xsd:group ref="configs" minOccurs="0" maxOccurs="unbounded" />
   38  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Matcher/Dumper/DumperCollection.php:
   13  
   14  /**
   15:  * Collection of routes.
   16   *
   17   * @author Arnaud Le Blanc <arnaud.lb@gmail.com>
   ..
   27  
   28      /**
   29:      * @var DumperCollection[]|DumperRoute[]
   30       */
   31      private $children = array();
   ..
   37  
   38      /**
   39:      * Returns the children routes and collections.
   40       *
   41:      * @return self[]|DumperRoute[]
   42       */
   43      public function all()
   ..
   47  
   48      /**
   49:      * Adds a route or collection.
   50       *
   51:      * @param DumperRoute|DumperCollection The route or collection
   52       */
   53      public function add($child)
   ..
   77       * Returns an iterator over the children.
   78       *
   79:      * @return \Iterator|DumperCollection[]|DumperRoute[] The iterator
   80       */
   81      public function getIterator()

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Matcher/Dumper/DumperRoute.php:
   12  namespace Symfony\Component\Routing\Matcher\Dumper;
   13  
   14: use Symfony\Component\Routing\Route;
   15  
   16  /**
   17:  * Container for a Route.
   18   *
   19   * @author Arnaud Le Blanc <arnaud.lb@gmail.com>
   ..
   21   * @internal
   22   */
   23: class DumperRoute
   24  {
   25      /**
   ..
   29  
   30      /**
   31:      * @var Route
   32       */
   33:     private $route;
   34  
   35      /**
   36       * Constructor.
   37       *
   38:      * @param string $name  The route name
   39:      * @param Route  $route The route
   40       */
   41:     public function __construct($name, Route $route)
   42      {
   43          $this->name = $name;
   44:         $this->route = $route;
   45      }
   46  
   47      /**
   48:      * Returns the route name.
   49       *
   50:      * @return string The route name
   51       */
   52      public function getName()
   ..
   56  
   57      /**
   58:      * Returns the route.
   59       *
   60:      * @return Route The route
   61       */
   62:     public function getRoute()
   63      {
   64:         return $this->route;
   65      }
   66  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Matcher/Dumper/MatcherDumper.php:
   12  namespace Symfony\Component\Routing\Matcher\Dumper;
   13  
   14: use Symfony\Component\Routing\RouteCollection;
   15  
   16  /**
   ..
   22  {
   23      /**
   24:      * @var RouteCollection
   25       */
   26:     private $routes;
   27  
   28      /**
   29       * Constructor.
   30       *
   31:      * @param RouteCollection $routes The RouteCollection to dump
   32       */
   33:     public function __construct(RouteCollection $routes)
   34      {
   35:         $this->routes = $routes;
   36      }
   37  
   ..
   39       * {@inheritdoc}
   40       */
   41:     public function getRoutes()
   42      {
   43:         return $this->routes;
   44      }
   45  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Matcher/Dumper/MatcherDumperInterface.php:
   12  namespace Symfony\Component\Routing\Matcher\Dumper;
   13  
   14: use Symfony\Component\Routing\RouteCollection;
   15  
   16  /**
   ..
   22  {
   23      /**
   24:      * Dumps a set of routes to a string representation of executable code
   25:      * that can then be used to match a request against these routes.
   26       *
   27       * @param array $options An array of options
   ..
   32  
   33      /**
   34:      * Gets the routes to dump.
   35       *
   36:      * @return RouteCollection A RouteCollection instance
   37       */
   38:     public function getRoutes();
   39  }
   40  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Matcher/Dumper/PhpMatcherDumper.php:
   12  namespace Symfony\Component\Routing\Matcher\Dumper;
   13  
   14: use Symfony\Component\Routing\Route;
   15: use Symfony\Component\Routing\RouteCollection;
   16  use Symfony\Component\ExpressionLanguage\ExpressionLanguage;
   17  use Symfony\Component\ExpressionLanguage\ExpressionFunctionProviderInterface;
   18  
   19  /**
   20:  * PhpMatcherDumper creates a PHP class able to match URLs for a given set of routes.
   21   *
   22   * @author Fabien Potencier <fabien@symfony.com>
   ..
   34  
   35      /**
   36:      * Dumps a set of routes to a PHP class.
   37       *
   38       * Available options:
   ..
   99      private function generateMatchMethod($supportsRedirections)
  100      {
  101:         $code = rtrim($this->compileRoutes($this->getRoutes(), $supportsRedirections), "\n");
  102  
  103          return <<<EOF
  ...
  125  
  126      /**
  127:      * Generates PHP code to match a RouteCollection with all its routes.
  128       *
  129:      * @param RouteCollection $routes               A RouteCollection instance
  130       * @param bool            $supportsRedirections Whether redirections are supported by the base class
  131       *
  132       * @return string PHP code
  133       */
  134:     private function compileRoutes(RouteCollection $routes, $supportsRedirections)
  135      {
  136          $fetchedHost = false;
  137:         $groups = $this->groupRoutesByHostRegex($routes);
  138          $code = '';
  139  
  ...
  149  
  150              $tree = $this->buildStaticPrefixCollection($collection);
  151:             $groupCode = $this->compileStaticPrefixRoutes($tree, $supportsRedirections);
  152  
  153              if (null !== $regex) {
  ...
  168          $prefixCollection = new StaticPrefixCollection();
  169  
  170:         foreach ($collection as $dumperRoute) {
  171:             $prefix = $dumperRoute->getRoute()->compile()->getStaticPrefix();
  172:             $prefixCollection->addRoute($prefix, $dumperRoute);
  173          }
  174  
  ...
  179  
  180      /**
  181:      * Generates PHP code to match a tree of routes.
  182       *
  183       * @param StaticPrefixCollection $collection           A StaticPrefixCollection instance
  ...
  187       * @return string PHP code
  188       */
  189:     private function compileStaticPrefixRoutes(StaticPrefixCollection $collection, $supportsRedirections, $ifOrElseIf = 'if')
  190      {
  191          $code = '';
  ...
  198          $ifOrElseIf = 'if';
  199  
  200:         foreach ($collection->getItems() as $route) {
  201:             if ($route instanceof StaticPrefixCollection) {
  202:                 $code .= $this->compileStaticPrefixRoutes($route, $supportsRedirections, $ifOrElseIf);
  203                  $ifOrElseIf = 'elseif';
  204              } else {
  205:                 $code .= $this->compileRoute($route[1]->getRoute(), $route[1]->getName(), $supportsRedirections, $prefix)."\n";
  206                  $ifOrElseIf = 'if';
  207              }
  ...
  218  
  219      /**
  220:      * Compiles a single Route to PHP code used to match it against the path info.
  221       *
  222:      * @param Route       $route                A Route instance
  223:      * @param string      $name                 The name of the Route
  224       * @param bool        $supportsRedirections Whether redirections are supported by the base class
  225       * @param string|null $parentPrefix         The prefix of the parent collection used to optimize the code
  ...
  229       * @throws \LogicException
  230       */
  231:     private function compileRoute(Route $route, $name, $supportsRedirections, $parentPrefix = null)
  232      {
  233          $code = '';
  234:         $compiledRoute = $route->compile();
  235          $conditions = array();
  236          $hasTrailingSlash = false;
  237          $matches = false;
  238          $hostMatches = false;
  239:         $methods = $route->getMethods();
  240  
  241          $supportsTrailingSlash = $supportsRedirections && (!$methods || in_array('HEAD', $methods) || in_array('GET', $methods));
  242:         $regex = $compiledRoute->getRegex();
  243  
  244:         if (!count($compiledRoute->getPathVariables()) && false !== preg_match('#^(.)\^(?P<url>.*?)\$\1#'.(substr($regex, -1) === 'u' ? 'u' : ''), $regex, $m)) {
  245              if ($supportsTrailingSlash && substr($m['url'], -1) === '/') {
  246                  $conditions[] = sprintf('%s === $trimmedPathinfo', var_export(rtrim(str_replace('\\', '', $m['url']), '/'), true));
  ...
  250              }
  251          } else {
  252:             if ($compiledRoute->getStaticPrefix() && $compiledRoute->getStaticPrefix() !== $parentPrefix) {
  253:                 $conditions[] = sprintf('0 === strpos($pathinfo, %s)', var_export($compiledRoute->getStaticPrefix(), true));
  254              }
  255  
  ...
  263          }
  264  
  265:         if ($compiledRoute->getHostVariables()) {
  266              $hostMatches = true;
  267          }
  268  
  269:         if ($route->getCondition()) {
  270:             $conditions[] = $this->getExpressionLanguage()->compile($route->getCondition(), array('context', 'request'));
  271          }
  272  
  ...
  344          }
  345  
  346:         if ($schemes = $route->getSchemes()) {
  347              if (!$supportsRedirections) {
  348                  throw new \LogicException('The "schemes" requirement is only supported for URL matchers that implement RedirectableUrlMatcherInterface.');
  ...
  368                  $vars[] = '$matches';
  369              }
  370:             $vars[] = "array('_route' => '$name')";
  371  
  372              $code .= sprintf(
  373                  "            return \$this->mergeDefaults(array_replace(%s), %s);\n",
  374                  implode(', ', $vars),
  375:                 str_replace("\n", '', var_export($route->getDefaults(), true))
  376              );
  377:         } elseif ($route->getDefaults()) {
  378:             $code .= sprintf("            return %s;\n", str_replace("\n", '', var_export(array_replace($route->getDefaults(), array('_route' => $name)), true)));
  379          } else {
  380:             $code .= sprintf("            return array('_route' => '%s');\n", $name);
  381          }
  382          $code .= "        }\n";
  ...
  390  
  391      /**
  392:      * Groups consecutive routes having the same host regex.
  393       *
  394:      * The result is a collection of collections of routes having the same host regex.
  395       *
  396:      * @param RouteCollection $routes A flat RouteCollection
  397       *
  398:      * @return DumperCollection A collection with routes grouped by host regex in sub-collections
  399       */
  400:     private function groupRoutesByHostRegex(RouteCollection $routes)
  401      {
  402          $groups = new DumperCollection();
  ...
  405          $groups->add($currentGroup);
  406  
  407:         foreach ($routes as $name => $route) {
  408:             $hostRegex = $route->compile()->getHostRegex();
  409              if ($currentGroup->getAttribute('host_regex') !== $hostRegex) {
  410                  $currentGroup = new DumperCollection();
  ...
  412                  $groups->add($currentGroup);
  413              }
  414:             $currentGroup->add(new DumperRoute($name, $route));
  415          }
  416  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Matcher/Dumper/StaticPrefixCollection.php:
   13  
   14  /**
   15:  * Prefix tree of routes preserving routes order.
   16   *
   17   * @author Frank de Jonge <info@frankdejonge.nl>
   ..
   55  
   56      /**
   57:      * Adds a route to a group.
   58       *
   59       * @param string $prefix
   60:      * @param mixed  $route
   61       */
   62:     public function addRoute($prefix, $route)
   63      {
   64          $prefix = '/' === $prefix ? $prefix : rtrim($prefix, '/');
   65:         $this->guardAgainstAddingNotAcceptedRoutes($prefix);
   66  
   67          if ($this->prefix === $prefix) {
   68              // When a prefix is exactly the same as the base we move up the match start position.
   69:             // This is needed because otherwise routes that come afterwards have higher precedence
   70              // than a possible regular expression, which goes against the input order sorting.
   71:             $this->items[] = array($prefix, $route);
   72              $this->matchStart = count($this->items);
   73  
   ..
   81  
   82              if ($item instanceof self && $item->accepts($prefix)) {
   83:                 $item->addRoute($prefix, $route);
   84  
   85                  return;
   86              }
   87  
   88:             $group = $this->groupWithItem($item, $prefix, $route);
   89  
   90              if ($group instanceof self) {
   ..
   95          }
   96  
   97:         // No optimised case was found, in this case we simple add the route for possible
   98:         // grouping when new routes are added.
   99:         $this->items[] = array($prefix, $route);
  100      }
  101  
  102      /**
  103:      * Tries to combine a route with another route or group.
  104       *
  105       * @param StaticPrefixCollection|array $item
  106       * @param string                       $prefix
  107:      * @param mixed                        $route
  108       *
  109       * @return null|StaticPrefixCollection
  110       */
  111:     private function groupWithItem($item, $prefix, $route)
  112      {
  113          $itemPrefix = $item instanceof self ? $item->prefix : $item[0];
  ...
  123              $child->items = array($item);
  124          } else {
  125:             $child->addRoute($item[0], $item[1]);
  126          }
  127  
  128:         $child->addRoute($prefix, $route);
  129  
  130          return $child;
  ...
  228       * @throws \LogicException When a prefix does not belong in a group.
  229       */
  230:     private function guardAgainstAddingNotAcceptedRoutes($prefix)
  231      {
  232          if (!$this->accepts($prefix)) {
  233:             $message = sprintf('Could not add route with prefix %s to collection with prefix %s', $prefix, $this->prefix);
  234  
  235              throw new \LogicException($message);

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Matcher/RedirectableUrlMatcher.php:
   13  
   14  use Symfony\Component\Routing\Exception\ResourceNotFoundException;
   15: use Symfony\Component\Routing\Route;
   16  
   17  /**
   ..
   47       * {@inheritdoc}
   48       */
   49:     protected function handleRouteRequirements($pathinfo, $name, Route $route)
   50      {
   51          // expression condition
   52:         if ($route->getCondition() && !$this->getExpressionLanguage()->evaluate($route->getCondition(), array('context' => $this->context, 'request' => $this->request ?: $this->createRequest($pathinfo)))) {
   53              return array(self::REQUIREMENT_MISMATCH, null);
   54          }
   ..
   56          // check HTTP scheme requirement
   57          $scheme = $this->context->getScheme();
   58:         $schemes = $route->getSchemes();
   59:         if ($schemes && !$route->hasScheme($scheme)) {
   60:             return array(self::ROUTE_MATCH, $this->redirect($pathinfo, $name, current($schemes)));
   61          }
   62  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Matcher/RedirectableUrlMatcherInterface.php:
   23       *
   24       * @param string      $path   The path info to redirect to
   25:      * @param string      $route  The route name that matched
   26       * @param string|null $scheme The URL scheme (null to keep the current one)
   27       *
   28       * @return array An array of parameters
   29       */
   30:     public function redirect($path, $route, $scheme = null);
   31  }
   32  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Matcher/RequestMatcherInterface.php:
   24  {
   25      /**
   26:      * Tries to match a request with a set of routes.
   27       *
   28       * If the matcher can not find information, it must throw one of the exceptions documented

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Matcher/TraceableUrlMatcher.php:
   14  use Symfony\Component\HttpFoundation\Request;
   15  use Symfony\Component\Routing\Exception\ExceptionInterface;
   16: use Symfony\Component\Routing\Route;
   17: use Symfony\Component\Routing\RouteCollection;
   18  
   19  /**
   ..
   24  class TraceableUrlMatcher extends UrlMatcher
   25  {
   26:     const ROUTE_DOES_NOT_MATCH = 0;
   27:     const ROUTE_ALMOST_MATCHES = 1;
   28:     const ROUTE_MATCHES = 2;
   29  
   30      protected $traces;
   ..
   51      }
   52  
   53:     protected function matchCollection($pathinfo, RouteCollection $routes)
   54      {
   55:         foreach ($routes as $name => $route) {
   56:             $compiledRoute = $route->compile();
   57  
   58:             if (!preg_match($compiledRoute->getRegex(), $pathinfo, $matches)) {
   59                  // does it match without any requirements?
   60:                 $r = new Route($route->getPath(), $route->getDefaults(), array(), $route->getOptions());
   61                  $cr = $r->compile();
   62                  if (!preg_match($cr->getRegex(), $pathinfo)) {
   63:                     $this->addTrace(sprintf('Path "%s" does not match', $route->getPath()), self::ROUTE_DOES_NOT_MATCH, $name, $route);
   64  
   65                      continue;
   66                  }
   67  
   68:                 foreach ($route->getRequirements() as $n => $regex) {
   69:                     $r = new Route($route->getPath(), $route->getDefaults(), array($n => $regex), $route->getOptions());
   70                      $cr = $r->compile();
   71  
   72                      if (in_array($n, $cr->getVariables()) && !preg_match($cr->getRegex(), $pathinfo)) {
   73:                         $this->addTrace(sprintf('Requirement for "%s" does not match (%s)', $n, $regex), self::ROUTE_ALMOST_MATCHES, $name, $route);
   74  
   75                          continue 2;
   ..
   82              // check host requirement
   83              $hostMatches = array();
   84:             if ($compiledRoute->getHostRegex() && !preg_match($compiledRoute->getHostRegex(), $this->context->getHost(), $hostMatches)) {
   85:                 $this->addTrace(sprintf('Host "%s" does not match the requirement ("%s")', $this->context->getHost(), $route->getHost()), self::ROUTE_ALMOST_MATCHES, $name, $route);
   86  
   87                  continue;
   ..
   89  
   90              // check HTTP method requirement
   91:             if ($requiredMethods = $route->getMethods()) {
   92                  // HEAD and GET are equivalent as per RFC
   93                  if ('HEAD' === $method = $this->context->getMethod()) {
   ..
   98                      $this->allow = array_merge($this->allow, $requiredMethods);
   99  
  100:                     $this->addTrace(sprintf('Method "%s" does not match any of the required methods (%s)', $this->context->getMethod(), implode(', ', $requiredMethods)), self::ROUTE_ALMOST_MATCHES, $name, $route);
  101  
  102                      continue;
  ...
  105  
  106              // check condition
  107:             if ($condition = $route->getCondition()) {
  108                  if (!$this->getExpressionLanguage()->evaluate($condition, array('context' => $this->context, 'request' => $this->request ?: $this->createRequest($pathinfo)))) {
  109:                     $this->addTrace(sprintf('Condition "%s" does not evaluate to "true"', $condition), self::ROUTE_ALMOST_MATCHES, $name, $route);
  110  
  111                      continue;
  ...
  114  
  115              // check HTTP scheme requirement
  116:             if ($requiredSchemes = $route->getSchemes()) {
  117                  $scheme = $this->context->getScheme();
  118  
  119:                 if (!$route->hasScheme($scheme)) {
  120:                     $this->addTrace(sprintf('Scheme "%s" does not match any of the required schemes (%s); the user will be redirected to first required scheme', $scheme, implode(', ', $requiredSchemes)), self::ROUTE_ALMOST_MATCHES, $name, $route);
  121  
  122                      return true;
  ...
  124              }
  125  
  126:             $this->addTrace('Route matches!', self::ROUTE_MATCHES, $name, $route);
  127  
  128              return true;
  ...
  130      }
  131  
  132:     private function addTrace($log, $level = self::ROUTE_DOES_NOT_MATCH, $name = null, $route = null)
  133      {
  134          $this->traces[] = array(
  ...
  136              'name' => $name,
  137              'level' => $level,
  138:             'path' => null !== $route ? $route->getPath() : null,
  139          );
  140      }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Matcher/UrlMatcher.php:
   14  use Symfony\Component\Routing\Exception\MethodNotAllowedException;
   15  use Symfony\Component\Routing\Exception\ResourceNotFoundException;
   16: use Symfony\Component\Routing\RouteCollection;
   17  use Symfony\Component\Routing\RequestContext;
   18: use Symfony\Component\Routing\Route;
   19  use Symfony\Component\HttpFoundation\Request;
   20  use Symfony\Component\ExpressionLanguage\ExpressionLanguage;
   ..
   22  
   23  /**
   24:  * UrlMatcher matches URL based on a set of routes.
   25   *
   26   * @author Fabien Potencier <fabien@symfony.com>
   ..
   30      const REQUIREMENT_MATCH = 0;
   31      const REQUIREMENT_MISMATCH = 1;
   32:     const ROUTE_MATCH = 2;
   33  
   34      /**
   ..
   43  
   44      /**
   45:      * @var RouteCollection
   46       */
   47:     protected $routes;
   48  
   49      protected $request;
   ..
   58       * Constructor.
   59       *
   60:      * @param RouteCollection $routes  A RouteCollection instance
   61       * @param RequestContext  $context The context
   62       */
   63:     public function __construct(RouteCollection $routes, RequestContext $context)
   64      {
   65:         $this->routes = $routes;
   66          $this->context = $context;
   67      }
   ..
   90          $this->allow = array();
   91  
   92:         if ($ret = $this->matchCollection(rawurldecode($pathinfo), $this->routes)) {
   93              return $ret;
   94          }
   ..
   96          throw 0 < count($this->allow)
   97              ? new MethodNotAllowedException(array_unique($this->allow))
   98:             : new ResourceNotFoundException(sprintf('No routes found for "%s".', $pathinfo));
   99      }
  100  
  ...
  119  
  120      /**
  121:      * Tries to match a URL with a set of routes.
  122       *
  123       * @param string          $pathinfo The path info to be parsed
  124:      * @param RouteCollection $routes   The set of routes
  125       *
  126       * @return array An array of parameters
  ...
  129       * @throws MethodNotAllowedException If the resource was found but the request method is not allowed
  130       */
  131:     protected function matchCollection($pathinfo, RouteCollection $routes)
  132      {
  133:         foreach ($routes as $name => $route) {
  134:             $compiledRoute = $route->compile();
  135  
  136              // check the static prefix of the URL first. Only use the more expensive preg_match when it matches
  137:             if ('' !== $compiledRoute->getStaticPrefix() && 0 !== strpos($pathinfo, $compiledRoute->getStaticPrefix())) {
  138                  continue;
  139              }
  140  
  141:             if (!preg_match($compiledRoute->getRegex(), $pathinfo, $matches)) {
  142                  continue;
  143              }
  144  
  145              $hostMatches = array();
  146:             if ($compiledRoute->getHostRegex() && !preg_match($compiledRoute->getHostRegex(), $this->context->getHost(), $hostMatches)) {
  147                  continue;
  148              }
  149  
  150              // check HTTP method requirement
  151:             if ($requiredMethods = $route->getMethods()) {
  152                  // HEAD and GET are equivalent as per RFC
  153                  if ('HEAD' === $method = $this->context->getMethod()) {
  ...
  162              }
  163  
  164:             $status = $this->handleRouteRequirements($pathinfo, $name, $route);
  165  
  166:             if (self::ROUTE_MATCH === $status[0]) {
  167                  return $status[1];
  168              }
  ...
  172              }
  173  
  174:             return $this->getAttributes($route, $name, array_replace($matches, $hostMatches));
  175          }
  176      }
  ...
  179       * Returns an array of values to use as request attributes.
  180       *
  181:      * As this method requires the Route object, it is not available
  182:      * in matchers that do not have access to the matched Route instance
  183       * (like the PHP and Apache matcher dumpers).
  184       *
  185:      * @param Route  $route      The route we are matching against
  186:      * @param string $name       The name of the route
  187       * @param array  $attributes An array of attributes from the matcher
  188       *
  189       * @return array An array of parameters
  190       */
  191:     protected function getAttributes(Route $route, $name, array $attributes)
  192      {
  193:         $attributes['_route'] = $name;
  194  
  195:         return $this->mergeDefaults($attributes, $route->getDefaults());
  196      }
  197  
  198      /**
  199:      * Handles specific route requirements.
  200       *
  201       * @param string $pathinfo The path
  202:      * @param string $name     The route name
  203:      * @param Route  $route    The route
  204       *
  205       * @return array The first element represents the status, the second contains additional information
  206       */
  207:     protected function handleRouteRequirements($pathinfo, $name, Route $route)
  208      {
  209          // expression condition
  210:         if ($route->getCondition() && !$this->getExpressionLanguage()->evaluate($route->getCondition(), array('context' => $this->context, 'request' => $this->request ?: $this->createRequest($pathinfo)))) {
  211              return array(self::REQUIREMENT_MISMATCH, null);
  212          }
  ...
  214          // check HTTP scheme requirement
  215          $scheme = $this->context->getScheme();
  216:         $status = $route->getSchemes() && !$route->hasScheme($scheme) ? self::REQUIREMENT_MISMATCH : self::REQUIREMENT_MATCH;
  217  
  218          return array($status, null);

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Matcher/UrlMatcherInterface.php:
   24  {
   25      /**
   26:      * Tries to match a URL path with a set of routes.
   27       *
   28       * If the matcher can not find information, it must throw one of the exceptions documented

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Route.php:
   13  
   14  /**
   15:  * A Route describes a route and its parameters.
   16   *
   17   * @author Fabien Potencier <fabien@symfony.com>
   18   * @author Tobias Schultze <http://tobion.de>
   19   */
   20: class Route implements \Serializable
   21  {
   22      /**
   ..
   56  
   57      /**
   58:      * @var null|CompiledRoute
   59       */
   60      private $compiled;
   ..
   70       * Available options:
   71       *
   72:      *  * compiler_class: A class name able to compile this route instance (RouteCompiler by default)
   73       *  * utf8:           Whether UTF-8 matching is enforced ot not
   74       *
   ..
   80       * @param string|array $schemes      A required URI scheme or an array of restricted schemes
   81       * @param string|array $methods      A required HTTP method or an array of restricted methods
   82:      * @param string       $condition    A condition that should evaluate to true for the route to match
   83       */
   84      public function __construct($path, array $defaults = array(), array $requirements = array(), array $options = array(), $host = '', $schemes = array(), $methods = array(), $condition = '')
   ..
  156      {
  157          // A pattern must start with a slash and must not have multiple slashes at the beginning because the
  158:         // generated path for this route would be confused with a network path, e.g. '//domain.com/path'.
  159          $this->path = '/'.ltrim(trim($pattern), '/');
  160          $this->compiled = null;
  ...
  191  
  192      /**
  193:      * Returns the lowercased schemes this route is restricted to.
  194       * So an empty array means that any scheme is allowed.
  195       *
  ...
  202  
  203      /**
  204:      * Sets the schemes (e.g. 'https') this route is restricted to.
  205       * So an empty array means that any scheme is allowed.
  206       *
  ...
  232  
  233      /**
  234:      * Returns the uppercased HTTP methods this route is restricted to.
  235       * So an empty array means that any method is allowed.
  236       *
  ...
  243  
  244      /**
  245:      * Sets the HTTP methods (e.g. 'POST') this route is restricted to.
  246       * So an empty array means that any method is allowed.
  247       *
  ...
  282      {
  283          $this->options = array(
  284:             'compiler_class' => 'Symfony\\Component\\Routing\\RouteCompiler',
  285          );
  286  
  ...
  547  
  548      /**
  549:      * Compiles the route.
  550       *
  551:      * @return CompiledRoute A CompiledRoute instance
  552       *
  553:      * @throws \LogicException If the Route cannot be compiled because the
  554       *                         path or host pattern is invalid
  555       *
  556:      * @see RouteCompiler which is responsible for the compilation process
  557       */
  558      public function compile()

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/RouteCollection.php:
   15  
   16  /**
   17:  * A RouteCollection represents a set of Route instances.
   18   *
   19:  * When adding a route at the end of the collection, an existing route
   20:  * with the same name is removed first. So there can only be one route
   21   * with a given name.
   22   *
   ..
   24   * @author Tobias Schultze <http://tobion.de>
   25   */
   26: class RouteCollection implements \IteratorAggregate, \Countable
   27  {
   28      /**
   29:      * @var Route[]
   30       */
   31:     private $routes = array();
   32  
   33      /**
   ..
   38      public function __clone()
   39      {
   40:         foreach ($this->routes as $name => $route) {
   41:             $this->routes[$name] = clone $route;
   42          }
   43      }
   44  
   45      /**
   46:      * Gets the current RouteCollection as an Iterator that includes all routes.
   47       *
   48       * It implements \IteratorAggregate.
   ..
   50       * @see all()
   51       *
   52:      * @return \ArrayIterator|Route[] An \ArrayIterator object for iterating over routes
   53       */
   54      public function getIterator()
   55      {
   56:         return new \ArrayIterator($this->routes);
   57      }
   58  
   59      /**
   60:      * Gets the number of Routes in this collection.
   61       *
   62:      * @return int The number of routes
   63       */
   64      public function count()
   65      {
   66:         return count($this->routes);
   67      }
   68  
   69      /**
   70:      * Adds a route.
   71       *
   72:      * @param string $name  The route name
   73:      * @param Route  $route A Route instance
   74       */
   75:     public function add($name, Route $route)
   76      {
   77:         unset($this->routes[$name]);
   78  
   79:         $this->routes[$name] = $route;
   80      }
   81  
   82      /**
   83:      * Returns all routes in this collection.
   84       *
   85:      * @return Route[] An array of routes
   86       */
   87      public function all()
   88      {
   89:         return $this->routes;
   90      }
   91  
   92      /**
   93:      * Gets a route by name.
   94       *
   95:      * @param string $name The route name
   96       *
   97:      * @return Route|null A Route instance or null when not found
   98       */
   99      public function get($name)
  100      {
  101:         return isset($this->routes[$name]) ? $this->routes[$name] : null;
  102      }
  103  
  104      /**
  105:      * Removes a route or an array of routes by name from the collection.
  106       *
  107:      * @param string|array $name The route name or an array of route names
  108       */
  109      public function remove($name)
  110      {
  111          foreach ((array) $name as $n) {
  112:             unset($this->routes[$n]);
  113          }
  114      }
  115  
  116      /**
  117:      * Adds a route collection at the end of the current set by appending all
  118:      * routes of the added collection.
  119       *
  120:      * @param RouteCollection $collection A RouteCollection instance
  121       */
  122:     public function addCollection(RouteCollection $collection)
  123      {
  124:         // we need to remove all routes with the same names first because just replacing them
  125:         // would not place the new route at the end of the merged array
  126:         foreach ($collection->all() as $name => $route) {
  127:             unset($this->routes[$name]);
  128:             $this->routes[$name] = $route;
  129          }
  130  
  ...
  133  
  134      /**
  135:      * Adds a prefix to the path of all child routes.
  136       *
  137:      * @param string $prefix       An optional prefix to add before each pattern of the route collection
  138       * @param array  $defaults     An array of default values
  139       * @param array  $requirements An array of requirements
  ...
  147          }
  148  
  149:         foreach ($this->routes as $route) {
  150:             $route->setPath('/'.$prefix.$route->getPath());
  151:             $route->addDefaults($defaults);
  152:             $route->addRequirements($requirements);
  153          }
  154      }
  155  
  156      /**
  157:      * Sets the host pattern on all routes.
  158       *
  159       * @param string $pattern      The pattern
  ...
  163      public function setHost($pattern, array $defaults = array(), array $requirements = array())
  164      {
  165:         foreach ($this->routes as $route) {
  166:             $route->setHost($pattern);
  167:             $route->addDefaults($defaults);
  168:             $route->addRequirements($requirements);
  169          }
  170      }
  171  
  172      /**
  173:      * Sets a condition on all routes.
  174       *
  175       * Existing conditions will be overridden.
  ...
  179      public function setCondition($condition)
  180      {
  181:         foreach ($this->routes as $route) {
  182:             $route->setCondition($condition);
  183          }
  184      }
  185  
  186      /**
  187:      * Adds defaults to all routes.
  188       *
  189:      * An existing default value under the same name in a route will be overridden.
  190       *
  191       * @param array $defaults An array of default values
  ...
  194      {
  195          if ($defaults) {
  196:             foreach ($this->routes as $route) {
  197:                 $route->addDefaults($defaults);
  198              }
  199          }
  ...
  201  
  202      /**
  203:      * Adds requirements to all routes.
  204       *
  205:      * An existing requirement under the same name in a route will be overridden.
  206       *
  207       * @param array $requirements An array of requirements
  ...
  210      {
  211          if ($requirements) {
  212:             foreach ($this->routes as $route) {
  213:                 $route->addRequirements($requirements);
  214              }
  215          }
  ...
  217  
  218      /**
  219:      * Adds options to all routes.
  220       *
  221:      * An existing option value under the same name in a route will be overridden.
  222       *
  223       * @param array $options An array of options
  ...
  226      {
  227          if ($options) {
  228:             foreach ($this->routes as $route) {
  229:                 $route->addOptions($options);
  230              }
  231          }
  ...
  233  
  234      /**
  235:      * Sets the schemes (e.g. 'https') all child routes are restricted to.
  236       *
  237       * @param string|array $schemes The scheme or an array of schemes
  ...
  239      public function setSchemes($schemes)
  240      {
  241:         foreach ($this->routes as $route) {
  242:             $route->setSchemes($schemes);
  243          }
  244      }
  245  
  246      /**
  247:      * Sets the HTTP methods (e.g. 'POST') all child routes are restricted to.
  248       *
  249       * @param string|array $methods The method or an array of methods
  ...
  251      public function setMethods($methods)
  252      {
  253:         foreach ($this->routes as $route) {
  254:             $route->setMethods($methods);
  255          }
  256      }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/RouteCollectionBuilder.php:
   17  
   18  /**
   19:  * Helps add and import routes into a RouteCollection.
   20   *
   21   * @author Ryan Weaver <ryan@knpuniversity.com>
   22   */
   23: class RouteCollectionBuilder
   24  {
   25      /**
   26:      * @var Route[]|RouteCollectionBuilder[]
   27       */
   28:     private $routes = array();
   29  
   30      private $loader;
   ..
   48  
   49      /**
   50:      * Import an external routing resource and returns the RouteCollectionBuilder.
   51       *
   52:      *  $routes->import('blog.yml', '/blog');
   53       *
   54       * @param mixed       $resource
   ..
   62      public function import($resource, $prefix = '/', $type = null)
   63      {
   64:         /** @var RouteCollection[] $collection */
   65          $collections = $this->load($resource, $type);
   66  
   67:         // create a builder from the RouteCollection
   68          $builder = $this->createBuilder();
   69  
   ..
   73              }
   74  
   75:             foreach ($collection->all() as $name => $route) {
   76:                 $builder->addRoute($route, $name);
   77              }
   78  
   ..
   89  
   90      /**
   91:      * Adds a route and returns it for future modification.
   92       *
   93:      * @param string      $path       The route path
   94:      * @param string      $controller The route's controller
   95:      * @param string|null $name       The name to give this route
   96       *
   97:      * @return Route
   98       */
   99      public function add($path, $controller, $name = null)
  100      {
  101:         $route = new Route($path);
  102:         $route->setDefault('_controller', $controller);
  103:         $this->addRoute($route, $name);
  104  
  105:         return $route;
  106      }
  107  
  108      /**
  109:      * Returns a RouteCollectionBuilder that can be configured and then added with mount().
  110       *
  111       * @return self
  ...
  117  
  118      /**
  119:      * Add a RouteCollectionBuilder.
  120       *
  121       * @param string                 $prefix
  122:      * @param RouteCollectionBuilder $builder
  123       */
  124:     public function mount($prefix, RouteCollectionBuilder $builder)
  125      {
  126          $builder->prefix = trim(trim($prefix), '/');
  127:         $this->routes[] = $builder;
  128      }
  129  
  130      /**
  131:      * Adds a Route object to the builder.
  132       *
  133:      * @param Route       $route
  134       * @param string|null $name
  135       *
  136       * @return $this
  137       */
  138:     public function addRoute(Route $route, $name = null)
  139      {
  140          if (null === $name) {
  141:             // used as a flag to know which routes will need a name later
  142:             $name = '_unnamed_route_'.spl_object_hash($route);
  143          }
  144  
  145:         $this->routes[$name] = $route;
  146  
  147          return $this;
  ...
  149  
  150      /**
  151:      * Sets the host on all embedded routes (unless already set).
  152       *
  153       * @param string $pattern
  ...
  163  
  164      /**
  165:      * Sets a condition on all embedded routes (unless already set).
  166       *
  167       * @param string $condition
  ...
  177  
  178      /**
  179:      * Sets a default value that will be added to all embedded routes (unless that
  180       * default value is already set).
  181       *
  ...
  193  
  194      /**
  195:      * Sets a requirement that will be added to all embedded routes (unless that
  196       * requirement is already set).
  197       *
  ...
  209  
  210      /**
  211:      * Sets an option that will be added to all embedded routes (unless that
  212       * option is already set).
  213       *
  ...
  225  
  226      /**
  227:      * Sets the schemes on all embedded routes (unless already set).
  228       *
  229       * @param array|string $schemes
  ...
  239  
  240      /**
  241:      * Sets the methods on all embedded routes (unless already set).
  242       *
  243       * @param array|string $methods
  ...
  267  
  268      /**
  269:      * Creates the final RouteCollection and returns it.
  270       *
  271:      * @return RouteCollection
  272       */
  273      public function build()
  274      {
  275:         $routeCollection = new RouteCollection();
  276  
  277:         foreach ($this->routes as $name => $route) {
  278:             if ($route instanceof Route) {
  279:                 $route->setDefaults(array_merge($this->defaults, $route->getDefaults()));
  280:                 $route->setOptions(array_merge($this->options, $route->getOptions()));
  281  
  282                  foreach ($this->requirements as $key => $val) {
  283:                     if (!$route->hasRequirement($key)) {
  284:                         $route->setRequirement($key, $val);
  285                      }
  286                  }
  287  
  288                  if (null !== $this->prefix) {
  289:                     $route->setPath('/'.$this->prefix.$route->getPath());
  290                  }
  291  
  292:                 if (!$route->getHost()) {
  293:                     $route->setHost($this->host);
  294                  }
  295  
  296:                 if (!$route->getCondition()) {
  297:                     $route->setCondition($this->condition);
  298                  }
  299  
  300:                 if (!$route->getSchemes()) {
  301:                     $route->setSchemes($this->schemes);
  302                  }
  303  
  304:                 if (!$route->getMethods()) {
  305:                     $route->setMethods($this->methods);
  306                  }
  307  
  308:                 // auto-generate the route name if it's been marked
  309:                 if ('_unnamed_route_' === substr($name, 0, 15)) {
  310:                     $name = $this->generateRouteName($route);
  311                  }
  312  
  313:                 $routeCollection->add($name, $route);
  314              } else {
  315:                 /* @var self $route */
  316:                 $subCollection = $route->build();
  317                  $subCollection->addPrefix($this->prefix);
  318  
  319:                 $routeCollection->addCollection($subCollection);
  320              }
  321  
  322              foreach ($this->resources as $resource) {
  323:                 $routeCollection->addResource($resource);
  324              }
  325          }
  326  
  327:         return $routeCollection;
  328      }
  329  
  330      /**
  331:      * Generates a route name based on details of this route.
  332       *
  333       * @return string
  334       */
  335:     private function generateRouteName(Route $route)
  336      {
  337:         $methods = implode('_', $route->getMethods()).'_';
  338  
  339:         $routeName = $methods.$route->getPath();
  340:         $routeName = str_replace(array('/', ':', '|', '-'), '_', $routeName);
  341:         $routeName = preg_replace('/[^a-z0-9A-Z_.]+/', '', $routeName);
  342  
  343          // Collapse consecutive underscores down into a single underscore.
  344:         $routeName = preg_replace('/_+/', '_', $routeName);
  345  
  346:         return $routeName;
  347      }
  348  
  ...
  353       * @param string|null $type     The resource type or null if unknown
  354       *
  355:      * @return RouteCollection[]
  356       *
  357       * @throws FileLoaderLoadException If no loader is found
  ...
  360      {
  361          if (null === $this->loader) {
  362:             throw new \BadMethodCallException('Cannot import other routing resources: you must pass a LoaderInterface when constructing RouteCollectionBuilder.');
  363          }
  364  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/RouteCompiler.php:
   13  
   14  /**
   15:  * RouteCompiler compiles Route instances to CompiledRoute instances.
   16   *
   17   * @author Fabien Potencier <fabien@symfony.com>
   18   * @author Tobias Schultze <http://tobion.de>
   19   */
   20: class RouteCompiler implements RouteCompilerInterface
   21  {
   22      const REGEX_DELIMITER = '#';
   ..
   45       *                                   a PCRE subpattern.
   46       */
   47:     public static function compile(Route $route)
   48      {
   49          $hostVariables = array();
   ..
   52          $hostTokens = array();
   53  
   54:         if ('' !== $host = $route->getHost()) {
   55:             $result = self::compilePattern($route, $host, true);
   56  
   57              $hostVariables = $result['variables'];
   ..
   62          }
   63  
   64:         $path = $route->getPath();
   65  
   66:         $result = self::compilePattern($route, $path, false);
   67  
   68          $staticPrefix = $result['staticPrefix'];
   ..
   72          foreach ($pathVariables as $pathParam) {
   73              if ('_fragment' === $pathParam) {
   74:                 throw new \InvalidArgumentException(sprintf('Route pattern "%s" cannot contain "_fragment" as a path parameter.', $route->getPath()));
   75              }
   76          }
   ..
   81          $regex = $result['regex'];
   82  
   83:         return new CompiledRoute(
   84              $staticPrefix,
   85              $regex,
   ..
   93      }
   94  
   95:     private static function compilePattern(Route $route, $pattern, $isHost)
   96      {
   97          $tokens = array();
   ..
  101          $defaultSeparator = $isHost ? '.' : '/';
  102          $useUtf8 = preg_match('//u', $pattern);
  103:         $needsUtf8 = $route->getOption('utf8');
  104  
  105          if (!$needsUtf8 && $useUtf8 && preg_match('/[\x80-\xFF]/', $pattern)) {
  106              $needsUtf8 = true;
  107:             @trigger_error(sprintf('Using UTF-8 route patterns without setting the "utf8" option is deprecated since Symfony 3.2 and will throw a LogicException in 4.0. Turn on the "utf8" route option for pattern "%s".', $pattern), E_USER_DEPRECATED);
  108          }
  109          if (!$useUtf8 && $needsUtf8) {
  ...
  133              // variable would not be usable as a Controller action argument.
  134              if (preg_match('/^\d/', $varName)) {
  135:                 throw new \DomainException(sprintf('Variable name "%s" cannot start with a digit in route pattern "%s". Please use a different name.', $varName, $pattern));
  136              }
  137              if (in_array($varName, $variables)) {
  138:                 throw new \LogicException(sprintf('Route pattern "%s" cannot reference variable name "%s" more than once.', $pattern, $varName));
  139              }
  140  
  141              if (strlen($varName) > self::VARIABLE_MAXIMUM_LENGTH) {
  142:                 throw new \DomainException(sprintf('Variable name "%s" cannot be longer than %s characters in route pattern "%s". Please use a shorter name.', $varName, self::VARIABLE_MAXIMUM_LENGTH, $pattern));
  143              }
  144  
  ...
  149              }
  150  
  151:             $regexp = $route->getRequirement($varName);
  152              if (null === $regexp) {
  153                  $followingPattern = (string) substr($pattern, $pos);
  ...
  155                  // are disallowed for the variable. This default requirement makes sure that optional variables can be matched at all
  156                  // and that the generating-matching-combination of URLs unambiguous, i.e. the params used for generating the URL are
  157:                 // the same that will be matched. Example: new Route('/{page}.{_format}', array('_format' => 'html'))
  158                  // If {page} would also match the separating dot, {_format} would never match as {page} will eagerly consume everything.
  159                  // Also even if {_format} was not optional the requirement prevents that {page} matches something that was originally
  ...
  178                  } elseif (!$needsUtf8 && preg_match('/[\x80-\xFF]|(?<!\\\\)\\\\(?:\\\\\\\\)*+(?-i:X|[pP][\{CLMNPSZ]|x\{[A-Fa-f0-9]{3})/', $regexp)) {
  179                      $needsUtf8 = true;
  180:                     @trigger_error(sprintf('Using UTF-8 route requirements without setting the "utf8" option is deprecated since Symfony 3.2 and will throw a LogicException in 4.0. Turn on the "utf8" route option for variable "%s" in pattern "%s".', $varName, $pattern), E_USER_DEPRECATED);
  181                  }
  182                  if (!$useUtf8 && $needsUtf8) {
  ...
  198              for ($i = count($tokens) - 1; $i >= 0; --$i) {
  199                  $token = $tokens[$i];
  200:                 if ('variable' === $token[0] && $route->hasDefault($token[3])) {
  201                      $firstOptional = $i;
  202                  } else {
  ...
  224  
  225          return array(
  226:             'staticPrefix' => self::determineStaticPrefix($route, $tokens),
  227              'regex' => $regexp,
  228              'tokens' => array_reverse($tokens),
  ...
  232  
  233      /**
  234:      * Determines the longest static prefix possible for a route.
  235       *
  236:      * @param Route $route
  237       * @param array $tokens
  238       *
  239:      * @return string The leading static part of a route's path
  240       */
  241:     private static function determineStaticPrefix(Route $route, array $tokens)
  242      {
  243          if ('text' !== $tokens[0][0]) {
  244:             return ($route->hasDefault($tokens[0][3]) || '/' === $tokens[0][1]) ? '' : $tokens[0][1];
  245          }
  246  
  247          $prefix = $tokens[0][1];
  248  
  249:         if (isset($tokens[1][1]) && '/' !== $tokens[1][1] && false === $route->hasDefault($tokens[1][3])) {
  250              $prefix .= $tokens[1][1];
  251          }
  ...
  255  
  256      /**
  257:      * Returns the next static character in the Route pattern that will serve as a separator.
  258       *
  259:      * @param string $pattern The route pattern
  260       * @param bool   $useUtf8 Whether the character is encoded in UTF-8 or not
  261       *
  ...
  282       * Computes the regexp used to match a specific token. It can be static text or a subpattern.
  283       *
  284:      * @param array $tokens        The route tokens
  285       * @param int   $index         The index of the current token
  286       * @param int   $firstOptional The index of the first optional token

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/RouteCompilerInterface.php:
   13  
   14  /**
   15:  * RouteCompilerInterface is the interface that all RouteCompiler classes must implement.
   16   *
   17   * @author Fabien Potencier <fabien@symfony.com>
   18   */
   19: interface RouteCompilerInterface
   20  {
   21      /**
   22:      * Compiles the current route instance.
   23       *
   24:      * @param Route $route A Route instance
   25       *
   26:      * @return CompiledRoute A CompiledRoute instance
   27       *
   28:      * @throws \LogicException If the Route cannot be compiled because the
   29       *                         path or host pattern is invalid
   30       */
   31:     public static function compile(Route $route);
   32  }
   33  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Router.php:
   27  
   28  /**
   29:  * The Router class is an example of the integration of all pieces of the
   30   * routing system for easier use.
   31   *
   32   * @author Fabien Potencier <fabien@symfony.com>
   33   */
   34: class Router implements RouterInterface, RequestMatcherInterface
   35  {
   36      /**
   ..
   55  
   56      /**
   57:      * @var RouteCollection|null
   58       */
   59      protected $collection;
   ..
  153  
  154          if ($invalid) {
  155:             throw new \InvalidArgumentException(sprintf('The Router does not support the following options: "%s".', implode('", "', $invalid)));
  156          }
  157      }
  ...
  168      {
  169          if (!array_key_exists($key, $this->options)) {
  170:             throw new \InvalidArgumentException(sprintf('The Router does not support the "%s" option.', $key));
  171          }
  172  
  ...
  186      {
  187          if (!array_key_exists($key, $this->options)) {
  188:             throw new \InvalidArgumentException(sprintf('The Router does not support the "%s" option.', $key));
  189          }
  190  
  ...
  195       * {@inheritdoc}
  196       */
  197:     public function getRouteCollection()
  198      {
  199          if (null === $this->collection) {
  ...
  268  
  269      /**
  270:      * Gets the UrlMatcher instance associated with this Router.
  271       *
  272       * @return UrlMatcherInterface A UrlMatcherInterface instance
  ...
  279  
  280          if (null === $this->options['cache_dir'] || null === $this->options['matcher_cache_class']) {
  281:             $this->matcher = new $this->options['matcher_class']($this->getRouteCollection(), $this->context);
  282              if (method_exists($this->matcher, 'addExpressionLanguageProvider')) {
  283                  foreach ($this->expressionLanguageProviders as $provider) {
  ...
  303                  );
  304  
  305:                 $cache->write($dumper->dump($options), $this->getRouteCollection()->getResources());
  306              }
  307          );
  ...
  313  
  314      /**
  315:      * Gets the UrlGenerator instance associated with this Router.
  316       *
  317       * @return UrlGeneratorInterface A UrlGeneratorInterface instance
  ...
  324  
  325          if (null === $this->options['cache_dir'] || null === $this->options['generator_cache_class']) {
  326:             $this->generator = new $this->options['generator_class']($this->getRouteCollection(), $this->context, $this->logger);
  327          } else {
  328              $cache = $this->getConfigCacheFactory()->cache($this->options['cache_dir'].'/'.$this->options['generator_cache_class'].'.php',
  ...
  335                      );
  336  
  337:                     $cache->write($dumper->dump($options), $this->getRouteCollection()->getResources());
  338                  }
  339              );
  ...
  361      protected function getGeneratorDumperInstance()
  362      {
  363:         return new $this->options['generator_dumper_class']($this->getRouteCollection());
  364      }
  365  
  ...
  369      protected function getMatcherDumperInstance()
  370      {
  371:         return new $this->options['matcher_dumper_class']($this->getRouteCollection());
  372      }
  373  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/RouterInterface.php:
   16  
   17  /**
   18:  * RouterInterface is the interface that all Router classes must implement.
   19   *
   20   * This interface is the concatenation of UrlMatcherInterface and UrlGeneratorInterface.
   ..
   22   * @author Fabien Potencier <fabien@symfony.com>
   23   */
   24: interface RouterInterface extends UrlMatcherInterface, UrlGeneratorInterface
   25  {
   26      /**
   27:      * Gets the RouteCollection instance associated with this Router.
   28       *
   29:      * @return RouteCollection A RouteCollection instance
   30       */
   31:     public function getRouteCollection();
   32  }
   33  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Annotation/RouteTest.php:
   13  
   14  use PHPUnit\Framework\TestCase;
   15: use Symfony\Component\Routing\Annotation\Route;
   16  
   17: class RouteTest extends TestCase
   18  {
   19      /**
   20       * @expectedException \BadMethodCallException
   21       */
   22:     public function testInvalidRouteParameter()
   23      {
   24:         $route = new Route(array('foo' => 'bar'));
   25      }
   26  
   ..
   28       * @dataProvider getValidParameters
   29       */
   30:     public function testRouteParameters($parameter, $value, $getter)
   31      {
   32:         $route = new Route(array($parameter => $value));
   33:         $this->assertEquals($route->$getter(), $value);
   34      }
   35  
   ..
   39              array('value', '/Blog', 'getPath'),
   40              array('requirements', array('locale' => 'en'), 'getRequirements'),
   41:             array('options', array('compiler_class' => 'RouteCompiler'), 'getOptions'),
   42              array('name', 'blog_index', 'getName'),
   43              array('defaults', array('_controller' => 'MyBlogBundle:Blog:index'), 'getDefaults'),

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/CompiledRouteTest.php:
   13  
   14  use PHPUnit\Framework\TestCase;
   15: use Symfony\Component\Routing\CompiledRoute;
   16  
   17: class CompiledRouteTest extends TestCase
   18  {
   19      public function testAccessors()
   20      {
   21:         $compiled = new CompiledRoute('prefix', 'regex', array('tokens'), array(), array(), array(), array(), array('variables'));
   22          $this->assertEquals('prefix', $compiled->getStaticPrefix(), '__construct() takes a static prefix as its second argument');
   23          $this->assertEquals('regex', $compiled->getRegex(), '__construct() takes a regexp as its third argument');

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/AnnotatedClasses/BarClass.php:
   14  class BarClass
   15  {
   16:     public function routeAction($arg1, $arg2 = 'defaultValue2', $arg3 = 'defaultValue3')
   17      {
   18      }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/CustomCompiledRoute.php:
   12  namespace Symfony\Component\Routing\Tests\Fixtures;
   13  
   14: use Symfony\Component\Routing\CompiledRoute;
   15  
   16: class CustomCompiledRoute extends CompiledRoute
   17  {
   18  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/CustomRouteCompiler.php:
   12  namespace Symfony\Component\Routing\Tests\Fixtures;
   13  
   14: use Symfony\Component\Routing\Route;
   15: use Symfony\Component\Routing\RouteCompiler;
   16  
   17: class CustomRouteCompiler extends RouteCompiler
   18  {
   19      /**
   20       * {@inheritdoc}
   21       */
   22:     public static function compile(Route $route)
   23      {
   24:         return new CustomCompiledRoute('', '', array(), array());
   25      }
   26  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/OtherAnnotatedClasses/VariadicClass.php:
   14  class VariadicClass
   15  {
   16:     public function routeAction(...$params)
   17      {
   18      }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/RedirectableUrlMatcher.php:
   20  class RedirectableUrlMatcher extends UrlMatcher implements RedirectableUrlMatcherInterface
   21  {
   22:     public function redirect($path, $route, $scheme = null)
   23      {
   24          return array(

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/directory/recurse/routes1.yml:
    1: route1:
    2:     path: /route/1
    3  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/directory/recurse/routes2.yml:
    1: route2:
    2:     path: /route/2
    3  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/directory/routes3.yml:
    1: route3:
    2:     path: /route/3
    3  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/dumper/url_matcher1.apache:
    5  # foo
    6  RewriteCond %{REQUEST_URI} ^/foo/(baz|symfony)$
    7: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:foo,E=_ROUTING_param_bar:%1,E=_ROUTING_default_def:test]
    8  
    9  # foobar
   10  RewriteCond %{REQUEST_URI} ^/foo(?:/([^/]++))?$
   11: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:foobar,E=_ROUTING_param_bar:%1,E=_ROUTING_default_bar:toto]
   12  
   13  # bar
   ..
   16  RewriteRule .* - [S=1,E=_ROUTING_allow_GET:1,E=_ROUTING_allow_HEAD:1]
   17  RewriteCond %{REQUEST_URI} ^/bar/([^/]++)$
   18: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:bar,E=_ROUTING_param_foo:%1]
   19  
   20  # baragain
   ..
   23  RewriteRule .* - [S=1,E=_ROUTING_allow_GET:1,E=_ROUTING_allow_POST:1,E=_ROUTING_allow_HEAD:1]
   24  RewriteCond %{REQUEST_URI} ^/baragain/([^/]++)$
   25: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:baragain,E=_ROUTING_param_foo:%1]
   26  
   27  # baz
   28  RewriteCond %{REQUEST_URI} ^/test/baz$
   29: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:baz]
   30  
   31  # baz2
   32  RewriteCond %{REQUEST_URI} ^/test/baz\.html$
   33: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:baz2]
   34  
   35  # baz3
   ..
   37  RewriteRule .* $0/ [QSA,L,R=301]
   38  RewriteCond %{REQUEST_URI} ^/test/baz3/$
   39: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:baz3]
   40  
   41  # baz4
   ..
   43  RewriteRule .* $0/ [QSA,L,R=301]
   44  RewriteCond %{REQUEST_URI} ^/test/([^/]++)/$
   45: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:baz4,E=_ROUTING_param_foo:%1]
   46  
   47  # baz5
   ..
   52  RewriteRule .* $0/ [QSA,L,R=301]
   53  RewriteCond %{REQUEST_URI} ^/test/([^/]++)/$
   54: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:baz5,E=_ROUTING_param_foo:%1]
   55  
   56  # baz5unsafe
   ..
   59  RewriteRule .* - [S=1,E=_ROUTING_allow_POST:1]
   60  RewriteCond %{REQUEST_URI} ^/testunsafe/([^/]++)/$
   61: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:baz5unsafe,E=_ROUTING_param_foo:%1]
   62  
   63  # baz6
   64  RewriteCond %{REQUEST_URI} ^/test/baz$
   65: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:baz6,E=_ROUTING_default_foo:bar\ baz]
   66  
   67  # baz7
   68  RewriteCond %{REQUEST_URI} ^/te\ st/baz$
   69: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:baz7]
   70  
   71  # baz8
   72  RewriteCond %{REQUEST_URI} ^/te\\\ st/baz$
   73: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:baz8]
   74  
   75  # baz9
   76  RewriteCond %{REQUEST_URI} ^/test/(te\\\ st)$
   77: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:baz9,E=_ROUTING_param_baz:%1]
   78  
   79  RewriteCond %{HTTP:Host} ^a\.example\.com$
   80  RewriteRule .? - [E=__ROUTING_host_1:1]
   81  
   82: # route1
   83  RewriteCond %{ENV:__ROUTING_host_1} =1
   84: RewriteCond %{REQUEST_URI} ^/route1$
   85: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route1]
   86  
   87: # route2
   88  RewriteCond %{ENV:__ROUTING_host_1} =1
   89: RewriteCond %{REQUEST_URI} ^/c2/route2$
   90: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route2]
   91  
   92  RewriteCond %{HTTP:Host} ^b\.example\.com$
   93  RewriteRule .? - [E=__ROUTING_host_2:1]
   94  
   95: # route3
   96  RewriteCond %{ENV:__ROUTING_host_2} =1
   97: RewriteCond %{REQUEST_URI} ^/c2/route3$
   98: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route3]
   99  
  100  RewriteCond %{HTTP:Host} ^a\.example\.com$
  101  RewriteRule .? - [E=__ROUTING_host_3:1]
  102  
  103: # route4
  104  RewriteCond %{ENV:__ROUTING_host_3} =1
  105: RewriteCond %{REQUEST_URI} ^/route4$
  106: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route4]
  107  
  108  RewriteCond %{HTTP:Host} ^c\.example\.com$
  109  RewriteRule .? - [E=__ROUTING_host_4:1]
  110  
  111: # route5
  112  RewriteCond %{ENV:__ROUTING_host_4} =1
  113: RewriteCond %{REQUEST_URI} ^/route5$
  114: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route5]
  115  
  116: # route6
  117: RewriteCond %{REQUEST_URI} ^/route6$
  118: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route6]
  119  
  120  RewriteCond %{HTTP:Host} ^([^\.]++)\.example\.com$
  121  RewriteRule .? - [E=__ROUTING_host_5:1,E=__ROUTING_host_5_var1:%1]
  122  
  123: # route11
  124  RewriteCond %{ENV:__ROUTING_host_5} =1
  125: RewriteCond %{REQUEST_URI} ^/route11$
  126: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route11,E=_ROUTING_param_var1:%{ENV:__ROUTING_host_5_var1}]
  127  
  128: # route12
  129  RewriteCond %{ENV:__ROUTING_host_5} =1
  130: RewriteCond %{REQUEST_URI} ^/route12$
  131: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route12,E=_ROUTING_param_var1:%{ENV:__ROUTING_host_5_var1},E=_ROUTING_default_var1:val]
  132  
  133: # route13
  134  RewriteCond %{ENV:__ROUTING_host_5} =1
  135: RewriteCond %{REQUEST_URI} ^/route13/([^/]++)$
  136: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route13,E=_ROUTING_param_var1:%{ENV:__ROUTING_host_5_var1},E=_ROUTING_param_name:%1]
  137  
  138: # route14
  139  RewriteCond %{ENV:__ROUTING_host_5} =1
  140: RewriteCond %{REQUEST_URI} ^/route14/([^/]++)$
  141: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route14,E=_ROUTING_param_var1:%{ENV:__ROUTING_host_5_var1},E=_ROUTING_param_name:%1,E=_ROUTING_default_var1:val]
  142  
  143  RewriteCond %{HTTP:Host} ^c\.example\.com$
  144  RewriteRule .? - [E=__ROUTING_host_6:1]
  145  
  146: # route15
  147  RewriteCond %{ENV:__ROUTING_host_6} =1
  148: RewriteCond %{REQUEST_URI} ^/route15/([^/]++)$
  149: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route15,E=_ROUTING_param_name:%1]
  150  
  151: # route16
  152: RewriteCond %{REQUEST_URI} ^/route16/([^/]++)$
  153: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route16,E=_ROUTING_param_name:%1,E=_ROUTING_default_var1:val]
  154  
  155: # route17
  156: RewriteCond %{REQUEST_URI} ^/route17$
  157: RewriteRule .* app.php [QSA,L,E=_ROUTING_route:route17]
  158  
  159  # 405 Method Not Allowed

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/dumper/url_matcher1.php:
   39              // foo
   40              if (preg_match('#^/foo/(?P<bar>baz|symfony)$#s', $pathinfo, $matches)) {
   41:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'foo')), array (  'def' => 'test',));
   42              }
   43  
   44              // foofoo
   45              if ('/foofoo' === $pathinfo) {
   46:                 return array (  'def' => 'test',  '_route' => 'foofoo',);
   47              }
   48  
   ..
   57                  }
   58  
   59:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'bar')), array ());
   60              }
   61              not_bar:
   ..
   68                  }
   69  
   70:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'barhead')), array ());
   71              }
   72              not_barhead:
   ..
   78                  // baz
   79                  if ('/test/baz' === $pathinfo) {
   80:                     return array('_route' => 'baz');
   81                  }
   82  
   83                  // baz2
   84                  if ('/test/baz.html' === $pathinfo) {
   85:                     return array('_route' => 'baz2');
   86                  }
   87  
   88                  // baz3
   89                  if ('/test/baz3/' === $pathinfo) {
   90:                     return array('_route' => 'baz3');
   91                  }
   92  
   ..
   95              // baz4
   96              if (preg_match('#^/test/(?P<foo>[^/]++)/$#s', $pathinfo, $matches)) {
   97:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'baz4')), array ());
   98              }
   99  
  ...
  105                  }
  106  
  107:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'baz5')), array ());
  108              }
  109              not_baz5:
  ...
  116                  }
  117  
  118:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'baz.baz6')), array ());
  119              }
  120              not_bazbaz6:
  ...
  124          // quoter
  125          if (preg_match('#^/(?P<quoter>[\']+)$#s', $pathinfo, $matches)) {
  126:             return $this->mergeDefaults(array_replace($matches, array('_route' => 'quoter')), array ());
  127          }
  128  
  129          // space
  130          if ('/spa ce' === $pathinfo) {
  131:             return array('_route' => 'space');
  132          }
  133  
  ...
  136                  // foo1
  137                  if (preg_match('#^/a/b\'b/(?P<foo>[^/]++)$#s', $pathinfo, $matches)) {
  138:                     return $this->mergeDefaults(array_replace($matches, array('_route' => 'foo1')), array ());
  139                  }
  140  
  141                  // bar1
  142                  if (preg_match('#^/a/b\'b/(?P<bar>[^/]++)$#s', $pathinfo, $matches)) {
  143:                     return $this->mergeDefaults(array_replace($matches, array('_route' => 'bar1')), array ());
  144                  }
  145  
  ...
  148              // overridden
  149              if (preg_match('#^/a/(?P<var>.*)$#s', $pathinfo, $matches)) {
  150:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'overridden')), array ());
  151              }
  152  
  ...
  154                  // foo2
  155                  if (preg_match('#^/a/b\'b/(?P<foo1>[^/]++)$#s', $pathinfo, $matches)) {
  156:                     return $this->mergeDefaults(array_replace($matches, array('_route' => 'foo2')), array ());
  157                  }
  158  
  159                  // bar2
  160                  if (preg_match('#^/a/b\'b/(?P<bar1>[^/]++)$#s', $pathinfo, $matches)) {
  161:                     return $this->mergeDefaults(array_replace($matches, array('_route' => 'bar2')), array ());
  162                  }
  163  
  ...
  169              // helloWorld
  170              if (0 === strpos($pathinfo, '/multi/hello') && preg_match('#^/multi/hello(?:/(?P<who>[^/]++))?$#s', $pathinfo, $matches)) {
  171:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'helloWorld')), array (  'who' => 'World!',));
  172              }
  173  
  174              // hey
  175              if ('/multi/hey/' === $pathinfo) {
  176:                 return array('_route' => 'hey');
  177              }
  178  
  179              // overridden2
  180              if ('/multi/new' === $pathinfo) {
  181:                 return array('_route' => 'overridden2');
  182              }
  183  
  ...
  186          // foo3
  187          if (preg_match('#^/(?P<_locale>[^/]++)/b/(?P<foo>[^/]++)$#s', $pathinfo, $matches)) {
  188:             return $this->mergeDefaults(array_replace($matches, array('_route' => 'foo3')), array ());
  189          }
  190  
  191          // bar3
  192          if (preg_match('#^/(?P<_locale>[^/]++)/b/(?P<bar>[^/]++)$#s', $pathinfo, $matches)) {
  193:             return $this->mergeDefaults(array_replace($matches, array('_route' => 'bar3')), array ());
  194          }
  195  
  ...
  197              // ababa
  198              if ('/ababa' === $pathinfo) {
  199:                 return array('_route' => 'ababa');
  200              }
  201  
  202              // foo4
  203              if (preg_match('#^/aba/(?P<foo>[^/]++)$#s', $pathinfo, $matches)) {
  204:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'foo4')), array ());
  205              }
  206  
  ...
  210  
  211          if (preg_match('#^a\\.example\\.com$#si', $host, $hostMatches)) {
  212:             // route1
  213:             if ('/route1' === $pathinfo) {
  214:                 return array('_route' => 'route1');
  215              }
  216  
  217:             // route2
  218:             if ('/c2/route2' === $pathinfo) {
  219:                 return array('_route' => 'route2');
  220              }
  221  
  ...
  223  
  224          if (preg_match('#^b\\.example\\.com$#si', $host, $hostMatches)) {
  225:             // route3
  226:             if ('/c2/route3' === $pathinfo) {
  227:                 return array('_route' => 'route3');
  228              }
  229  
  ...
  231  
  232          if (preg_match('#^a\\.example\\.com$#si', $host, $hostMatches)) {
  233:             // route4
  234:             if ('/route4' === $pathinfo) {
  235:                 return array('_route' => 'route4');
  236              }
  237  
  ...
  239  
  240          if (preg_match('#^c\\.example\\.com$#si', $host, $hostMatches)) {
  241:             // route5
  242:             if ('/route5' === $pathinfo) {
  243:                 return array('_route' => 'route5');
  244              }
  245  
  246          }
  247  
  248:         // route6
  249:         if ('/route6' === $pathinfo) {
  250:             return array('_route' => 'route6');
  251          }
  252  
  253          if (preg_match('#^(?P<var1>[^\\.]++)\\.example\\.com$#si', $host, $hostMatches)) {
  254:             if (0 === strpos($pathinfo, '/route1')) {
  255:                 // route11
  256:                 if ('/route11' === $pathinfo) {
  257:                     return $this->mergeDefaults(array_replace($hostMatches, array('_route' => 'route11')), array ());
  258                  }
  259  
  260:                 // route12
  261:                 if ('/route12' === $pathinfo) {
  262:                     return $this->mergeDefaults(array_replace($hostMatches, array('_route' => 'route12')), array (  'var1' => 'val',));
  263                  }
  264  
  265:                 // route13
  266:                 if (0 === strpos($pathinfo, '/route13') && preg_match('#^/route13/(?P<name>[^/]++)$#s', $pathinfo, $matches)) {
  267:                     return $this->mergeDefaults(array_replace($hostMatches, $matches, array('_route' => 'route13')), array ());
  268                  }
  269  
  270:                 // route14
  271:                 if (0 === strpos($pathinfo, '/route14') && preg_match('#^/route14/(?P<name>[^/]++)$#s', $pathinfo, $matches)) {
  272:                     return $this->mergeDefaults(array_replace($hostMatches, $matches, array('_route' => 'route14')), array (  'var1' => 'val',));
  273                  }
  274  
  ...
  278  
  279          if (preg_match('#^c\\.example\\.com$#si', $host, $hostMatches)) {
  280:             // route15
  281:             if (0 === strpos($pathinfo, '/route15') && preg_match('#^/route15/(?P<name>[^/]++)$#s', $pathinfo, $matches)) {
  282:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'route15')), array ());
  283              }
  284  
  285          }
  286  
  287:         // route16
  288:         if (0 === strpos($pathinfo, '/route16') && preg_match('#^/route16/(?P<name>[^/]++)$#s', $pathinfo, $matches)) {
  289:             return $this->mergeDefaults(array_replace($matches, array('_route' => 'route16')), array (  'var1' => 'val',));
  290          }
  291  
  292:         // route17
  293:         if ('/route17' === $pathinfo) {
  294:             return array('_route' => 'route17');
  295          }
  296  
  297          // a
  298          if ('/a/a...' === $pathinfo) {
  299:             return array('_route' => 'a');
  300          }
  301  
  ...
  303              // b
  304              if (preg_match('#^/a/b/(?P<var>[^/]++)$#s', $pathinfo, $matches)) {
  305:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'b')), array ());
  306              }
  307  
  308              // c
  309              if (0 === strpos($pathinfo, '/a/b/c') && preg_match('#^/a/b/c/(?P<var>[^/]++)$#s', $pathinfo, $matches)) {
  310:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'c')), array ());
  311              }
  312  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/dumper/url_matcher2.apache:
    5  # foo
    6  RewriteCond %{REQUEST_URI} ^/foo$
    7: RewriteRule .* ap\ p_d\ ev.php [QSA,L,E=_ROUTING_route:foo]
    8  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/dumper/url_matcher2.php:
   39              // foo
   40              if (preg_match('#^/foo/(?P<bar>baz|symfony)$#s', $pathinfo, $matches)) {
   41:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'foo')), array (  'def' => 'test',));
   42              }
   43  
   44              // foofoo
   45              if ('/foofoo' === $pathinfo) {
   46:                 return array (  'def' => 'test',  '_route' => 'foofoo',);
   47              }
   48  
   ..
   57                  }
   58  
   59:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'bar')), array ());
   60              }
   61              not_bar:
   ..
   68                  }
   69  
   70:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'barhead')), array ());
   71              }
   72              not_barhead:
   ..
   78                  // baz
   79                  if ('/test/baz' === $pathinfo) {
   80:                     return array('_route' => 'baz');
   81                  }
   82  
   83                  // baz2
   84                  if ('/test/baz.html' === $pathinfo) {
   85:                     return array('_route' => 'baz2');
   86                  }
   87  
   ..
   92                      }
   93  
   94:                     return array('_route' => 'baz3');
   95                  }
   96  
   ..
  103                  }
  104  
  105:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'baz4')), array ());
  106              }
  107  
  ...
  113                  }
  114  
  115:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'baz5')), array ());
  116              }
  117              not_baz5:
  ...
  124                  }
  125  
  126:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'baz.baz6')), array ());
  127              }
  128              not_bazbaz6:
  ...
  132          // quoter
  133          if (preg_match('#^/(?P<quoter>[\']+)$#s', $pathinfo, $matches)) {
  134:             return $this->mergeDefaults(array_replace($matches, array('_route' => 'quoter')), array ());
  135          }
  136  
  137          // space
  138          if ('/spa ce' === $pathinfo) {
  139:             return array('_route' => 'space');
  140          }
  141  
  ...
  144                  // foo1
  145                  if (preg_match('#^/a/b\'b/(?P<foo>[^/]++)$#s', $pathinfo, $matches)) {
  146:                     return $this->mergeDefaults(array_replace($matches, array('_route' => 'foo1')), array ());
  147                  }
  148  
  149                  // bar1
  150                  if (preg_match('#^/a/b\'b/(?P<bar>[^/]++)$#s', $pathinfo, $matches)) {
  151:                     return $this->mergeDefaults(array_replace($matches, array('_route' => 'bar1')), array ());
  152                  }
  153  
  ...
  156              // overridden
  157              if (preg_match('#^/a/(?P<var>.*)$#s', $pathinfo, $matches)) {
  158:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'overridden')), array ());
  159              }
  160  
  ...
  162                  // foo2
  163                  if (preg_match('#^/a/b\'b/(?P<foo1>[^/]++)$#s', $pathinfo, $matches)) {
  164:                     return $this->mergeDefaults(array_replace($matches, array('_route' => 'foo2')), array ());
  165                  }
  166  
  167                  // bar2
  168                  if (preg_match('#^/a/b\'b/(?P<bar1>[^/]++)$#s', $pathinfo, $matches)) {
  169:                     return $this->mergeDefaults(array_replace($matches, array('_route' => 'bar2')), array ());
  170                  }
  171  
  ...
  177              // helloWorld
  178              if (0 === strpos($pathinfo, '/multi/hello') && preg_match('#^/multi/hello(?:/(?P<who>[^/]++))?$#s', $pathinfo, $matches)) {
  179:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'helloWorld')), array (  'who' => 'World!',));
  180              }
  181  
  ...
  186                  }
  187  
  188:                 return array('_route' => 'hey');
  189              }
  190  
  191              // overridden2
  192              if ('/multi/new' === $pathinfo) {
  193:                 return array('_route' => 'overridden2');
  194              }
  195  
  ...
  198          // foo3
  199          if (preg_match('#^/(?P<_locale>[^/]++)/b/(?P<foo>[^/]++)$#s', $pathinfo, $matches)) {
  200:             return $this->mergeDefaults(array_replace($matches, array('_route' => 'foo3')), array ());
  201          }
  202  
  203          // bar3
  204          if (preg_match('#^/(?P<_locale>[^/]++)/b/(?P<bar>[^/]++)$#s', $pathinfo, $matches)) {
  205:             return $this->mergeDefaults(array_replace($matches, array('_route' => 'bar3')), array ());
  206          }
  207  
  ...
  209              // ababa
  210              if ('/ababa' === $pathinfo) {
  211:                 return array('_route' => 'ababa');
  212              }
  213  
  214              // foo4
  215              if (preg_match('#^/aba/(?P<foo>[^/]++)$#s', $pathinfo, $matches)) {
  216:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'foo4')), array ());
  217              }
  218  
  ...
  222  
  223          if (preg_match('#^a\\.example\\.com$#si', $host, $hostMatches)) {
  224:             // route1
  225:             if ('/route1' === $pathinfo) {
  226:                 return array('_route' => 'route1');
  227              }
  228  
  229:             // route2
  230:             if ('/c2/route2' === $pathinfo) {
  231:                 return array('_route' => 'route2');
  232              }
  233  
  ...
  235  
  236          if (preg_match('#^b\\.example\\.com$#si', $host, $hostMatches)) {
  237:             // route3
  238:             if ('/c2/route3' === $pathinfo) {
  239:                 return array('_route' => 'route3');
  240              }
  241  
  ...
  243  
  244          if (preg_match('#^a\\.example\\.com$#si', $host, $hostMatches)) {
  245:             // route4
  246:             if ('/route4' === $pathinfo) {
  247:                 return array('_route' => 'route4');
  248              }
  249  
  ...
  251  
  252          if (preg_match('#^c\\.example\\.com$#si', $host, $hostMatches)) {
  253:             // route5
  254:             if ('/route5' === $pathinfo) {
  255:                 return array('_route' => 'route5');
  256              }
  257  
  258          }
  259  
  260:         // route6
  261:         if ('/route6' === $pathinfo) {
  262:             return array('_route' => 'route6');
  263          }
  264  
  265          if (preg_match('#^(?P<var1>[^\\.]++)\\.example\\.com$#si', $host, $hostMatches)) {
  266:             if (0 === strpos($pathinfo, '/route1')) {
  267:                 // route11
  268:                 if ('/route11' === $pathinfo) {
  269:                     return $this->mergeDefaults(array_replace($hostMatches, array('_route' => 'route11')), array ());
  270                  }
  271  
  272:                 // route12
  273:                 if ('/route12' === $pathinfo) {
  274:                     return $this->mergeDefaults(array_replace($hostMatches, array('_route' => 'route12')), array (  'var1' => 'val',));
  275                  }
  276  
  277:                 // route13
  278:                 if (0 === strpos($pathinfo, '/route13') && preg_match('#^/route13/(?P<name>[^/]++)$#s', $pathinfo, $matches)) {
  279:                     return $this->mergeDefaults(array_replace($hostMatches, $matches, array('_route' => 'route13')), array ());
  280                  }
  281  
  282:                 // route14
  283:                 if (0 === strpos($pathinfo, '/route14') && preg_match('#^/route14/(?P<name>[^/]++)$#s', $pathinfo, $matches)) {
  284:                     return $this->mergeDefaults(array_replace($hostMatches, $matches, array('_route' => 'route14')), array (  'var1' => 'val',));
  285                  }
  286  
  ...
  290  
  291          if (preg_match('#^c\\.example\\.com$#si', $host, $hostMatches)) {
  292:             // route15
  293:             if (0 === strpos($pathinfo, '/route15') && preg_match('#^/route15/(?P<name>[^/]++)$#s', $pathinfo, $matches)) {
  294:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'route15')), array ());
  295              }
  296  
  297          }
  298  
  299:         // route16
  300:         if (0 === strpos($pathinfo, '/route16') && preg_match('#^/route16/(?P<name>[^/]++)$#s', $pathinfo, $matches)) {
  301:             return $this->mergeDefaults(array_replace($matches, array('_route' => 'route16')), array (  'var1' => 'val',));
  302          }
  303  
  304:         // route17
  305:         if ('/route17' === $pathinfo) {
  306:             return array('_route' => 'route17');
  307          }
  308  
  309          // a
  310          if ('/a/a...' === $pathinfo) {
  311:             return array('_route' => 'a');
  312          }
  313  
  ...
  315              // b
  316              if (preg_match('#^/a/b/(?P<var>[^/]++)$#s', $pathinfo, $matches)) {
  317:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'b')), array ());
  318              }
  319  
  320              // c
  321              if (0 === strpos($pathinfo, '/a/b/c') && preg_match('#^/a/b/c/(?P<var>[^/]++)$#s', $pathinfo, $matches)) {
  322:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'c')), array ());
  323              }
  324  
  ...
  332              }
  333  
  334:             return array('_route' => 'secure');
  335          }
  336  
  ...
  342              }
  343  
  344:             return array('_route' => 'nonsecure');
  345          }
  346  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/dumper/url_matcher3.php:
   39              // static
   40              if ('/rootprefix/test' === $pathinfo) {
   41:                 return array('_route' => 'static');
   42              }
   43  
   44              // dynamic
   45              if (preg_match('#^/rootprefix/(?P<var>[^/]++)$#s', $pathinfo, $matches)) {
   46:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'dynamic')), array ());
   47              }
   48  
   ..
   51          // with-condition
   52          if ('/with-condition' === $pathinfo && ($context->getMethod() == "GET")) {
   53:             return array('_route' => 'with-condition');
   54          }
   55  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/dumper/url_matcher4.php:
   43              }
   44  
   45:             return array('_route' => 'just_head');
   46          }
   47          not_just_head:
   ..
   54              }
   55  
   56:             return array('_route' => 'head_and_get');
   57          }
   58          not_head_and_get:
   ..
   65              }
   66  
   67:             return array('_route' => 'post_and_head');
   68          }
   69          not_post_and_head:
   ..
   77                  }
   78  
   79:                 return array('_route' => 'put_and_post');
   80              }
   81              not_put_and_post:
   ..
   88                  }
   89  
   90:                 return array('_route' => 'put_and_get_and_head');
   91              }
   92              not_put_and_get_and_head:

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/dumper/url_matcher5.php:
   39              // a_first
   40              if ('/a/11' === $pathinfo) {
   41:                 return array('_route' => 'a_first');
   42              }
   43  
   44              // a_second
   45              if ('/a/22' === $pathinfo) {
   46:                 return array('_route' => 'a_second');
   47              }
   48  
   49              // a_third
   50              if ('/a/333' === $pathinfo) {
   51:                 return array('_route' => 'a_third');
   52              }
   53  
   ..
   56          // a_wildcard
   57          if (preg_match('#^/(?P<param>[^/]++)$#s', $pathinfo, $matches)) {
   58:             return $this->mergeDefaults(array_replace($matches, array('_route' => 'a_wildcard')), array ());
   59          }
   60  
   ..
   66                  }
   67  
   68:                 return array('_route' => 'a_fourth');
   69              }
   70  
   ..
   75                  }
   76  
   77:                 return array('_route' => 'a_fifth');
   78              }
   79  
   ..
   84                  }
   85  
   86:                 return array('_route' => 'a_sixth');
   87              }
   88  
   ..
   91          // nested_wildcard
   92          if (0 === strpos($pathinfo, '/nested') && preg_match('#^/nested/(?P<param>[^/]++)$#s', $pathinfo, $matches)) {
   93:             return $this->mergeDefaults(array_replace($matches, array('_route' => 'nested_wildcard')), array ());
   94          }
   95  
   ..
  101                  }
  102  
  103:                 return array('_route' => 'nested_a');
  104              }
  105  
  ...
  110                  }
  111  
  112:                 return array('_route' => 'nested_b');
  113              }
  114  
  ...
  119                  }
  120  
  121:                 return array('_route' => 'nested_c');
  122              }
  123  
  ...
  131                  }
  132  
  133:                 return array('_route' => 'slashed_a');
  134              }
  135  
  ...
  140                  }
  141  
  142:                 return array('_route' => 'slashed_b');
  143              }
  144  
  ...
  149                  }
  150  
  151:                 return array('_route' => 'slashed_c');
  152              }
  153  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/dumper/url_matcher6.php:
   39              // simple_trailing_slash_no_methods
   40              if ('/trailing/simple/no-methods/' === $pathinfo) {
   41:                 return array('_route' => 'simple_trailing_slash_no_methods');
   42              }
   43  
   ..
   49                  }
   50  
   51:                 return array('_route' => 'simple_trailing_slash_GET_method');
   52              }
   53              not_simple_trailing_slash_GET_method:
   ..
   60                  }
   61  
   62:                 return array('_route' => 'simple_trailing_slash_HEAD_method');
   63              }
   64              not_simple_trailing_slash_HEAD_method:
   ..
   71                  }
   72  
   73:                 return array('_route' => 'simple_trailing_slash_POST_method');
   74              }
   75              not_simple_trailing_slash_POST_method:
   ..
   80              // regex_trailing_slash_no_methods
   81              if (0 === strpos($pathinfo, '/trailing/regex/no-methods') && preg_match('#^/trailing/regex/no\\-methods/(?P<param>[^/]++)/$#s', $pathinfo, $matches)) {
   82:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_trailing_slash_no_methods')), array ());
   83              }
   84  
   ..
   90                  }
   91  
   92:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_trailing_slash_GET_method')), array ());
   93              }
   94              not_regex_trailing_slash_GET_method:
   ..
  101                  }
  102  
  103:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_trailing_slash_HEAD_method')), array ());
  104              }
  105              not_regex_trailing_slash_HEAD_method:
  ...
  112                  }
  113  
  114:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_trailing_slash_POST_method')), array ());
  115              }
  116              not_regex_trailing_slash_POST_method:
  ...
  121              // simple_not_trailing_slash_no_methods
  122              if ('/not-trailing/simple/no-methods' === $pathinfo) {
  123:                 return array('_route' => 'simple_not_trailing_slash_no_methods');
  124              }
  125  
  ...
  131                  }
  132  
  133:                 return array('_route' => 'simple_not_trailing_slash_GET_method');
  134              }
  135              not_simple_not_trailing_slash_GET_method:
  ...
  142                  }
  143  
  144:                 return array('_route' => 'simple_not_trailing_slash_HEAD_method');
  145              }
  146              not_simple_not_trailing_slash_HEAD_method:
  ...
  153                  }
  154  
  155:                 return array('_route' => 'simple_not_trailing_slash_POST_method');
  156              }
  157              not_simple_not_trailing_slash_POST_method:
  ...
  162              // regex_not_trailing_slash_no_methods
  163              if (0 === strpos($pathinfo, '/not-trailing/regex/no-methods') && preg_match('#^/not\\-trailing/regex/no\\-methods/(?P<param>[^/]++)$#s', $pathinfo, $matches)) {
  164:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_not_trailing_slash_no_methods')), array ());
  165              }
  166  
  ...
  172                  }
  173  
  174:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_not_trailing_slash_GET_method')), array ());
  175              }
  176              not_regex_not_trailing_slash_GET_method:
  ...
  183                  }
  184  
  185:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_not_trailing_slash_HEAD_method')), array ());
  186              }
  187              not_regex_not_trailing_slash_HEAD_method:
  ...
  194                  }
  195  
  196:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_not_trailing_slash_POST_method')), array ());
  197              }
  198              not_regex_not_trailing_slash_POST_method:

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/dumper/url_matcher7.php:
   43                  }
   44  
   45:                 return array('_route' => 'simple_trailing_slash_no_methods');
   46              }
   47  
   ..
   57                  }
   58  
   59:                 return array('_route' => 'simple_trailing_slash_GET_method');
   60              }
   61              not_simple_trailing_slash_GET_method:
   ..
   72                  }
   73  
   74:                 return array('_route' => 'simple_trailing_slash_HEAD_method');
   75              }
   76              not_simple_trailing_slash_HEAD_method:
   ..
   83                  }
   84  
   85:                 return array('_route' => 'simple_trailing_slash_POST_method');
   86              }
   87              not_simple_trailing_slash_POST_method:
   ..
   96                  }
   97  
   98:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_trailing_slash_no_methods')), array ());
   99              }
  100  
  ...
  110                  }
  111  
  112:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_trailing_slash_GET_method')), array ());
  113              }
  114              not_regex_trailing_slash_GET_method:
  ...
  125                  }
  126  
  127:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_trailing_slash_HEAD_method')), array ());
  128              }
  129              not_regex_trailing_slash_HEAD_method:
  ...
  136                  }
  137  
  138:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_trailing_slash_POST_method')), array ());
  139              }
  140              not_regex_trailing_slash_POST_method:
  ...
  145              // simple_not_trailing_slash_no_methods
  146              if ('/not-trailing/simple/no-methods' === $pathinfo) {
  147:                 return array('_route' => 'simple_not_trailing_slash_no_methods');
  148              }
  149  
  ...
  155                  }
  156  
  157:                 return array('_route' => 'simple_not_trailing_slash_GET_method');
  158              }
  159              not_simple_not_trailing_slash_GET_method:
  ...
  166                  }
  167  
  168:                 return array('_route' => 'simple_not_trailing_slash_HEAD_method');
  169              }
  170              not_simple_not_trailing_slash_HEAD_method:
  ...
  177                  }
  178  
  179:                 return array('_route' => 'simple_not_trailing_slash_POST_method');
  180              }
  181              not_simple_not_trailing_slash_POST_method:
  ...
  186              // regex_not_trailing_slash_no_methods
  187              if (0 === strpos($pathinfo, '/not-trailing/regex/no-methods') && preg_match('#^/not\\-trailing/regex/no\\-methods/(?P<param>[^/]++)$#s', $pathinfo, $matches)) {
  188:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_not_trailing_slash_no_methods')), array ());
  189              }
  190  
  ...
  196                  }
  197  
  198:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_not_trailing_slash_GET_method')), array ());
  199              }
  200              not_regex_not_trailing_slash_GET_method:
  ...
  207                  }
  208  
  209:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_not_trailing_slash_HEAD_method')), array ());
  210              }
  211              not_regex_not_trailing_slash_HEAD_method:
  ...
  218                  }
  219  
  220:                 return $this->mergeDefaults(array_replace($matches, array('_route' => 'regex_not_trailing_slash_POST_method')), array ());
  221              }
  222              not_regex_not_trailing_slash_POST_method:

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/list_defaults.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2: <routes xmlns="http://symfony.com/schema/routing"
    3      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    4      xsi:schemaLocation="http://symfony.com/schema/routing
    5          http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="blog" path="/blog">
    8          <default key="_controller">
    9              <string>AcmeBlogBundle:Blog:index</string>
   ..
   17              </list>
   18          </default>
   19:     </route>
   20: </routes>
   21  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/list_in_list_defaults.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2: <routes xmlns="http://symfony.com/schema/routing"
    3      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    4      xsi:schemaLocation="http://symfony.com/schema/routing
    5          http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="blog" path="/blog">
    8          <default key="_controller">
    9              <string>AcmeBlogBundle:Blog:index</string>
   ..
   19              </list>
   20          </default>
   21:     </route>
   22: </routes>
   23  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/list_in_map_defaults.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2: <routes xmlns="http://symfony.com/schema/routing"
    3      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    4      xsi:schemaLocation="http://symfony.com/schema/routing
    5          http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="blog" path="/blog">
    8          <default key="_controller">
    9              <string>AcmeBlogBundle:Blog:index</string>
   ..
   19              </map>
   20          </default>
   21:     </route>
   22: </routes>
   23  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/list_null_values.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2: <routes xmlns="http://symfony.com/schema/routing"
    3      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    4      xsi:schemaLocation="http://symfony.com/schema/routing
    5          http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="blog" path="/blog">
    8          <default key="_controller">
    9              <string>AcmeBlogBundle:Blog:index</string>
   ..
   19              </list>
   20          </default>
   21:     </route>
   22: </routes>
   23  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/map_defaults.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2: <routes xmlns="http://symfony.com/schema/routing"
    3      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    4      xsi:schemaLocation="http://symfony.com/schema/routing
    5          http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="blog" path="/blog">
    8          <default key="_controller">
    9              <string>AcmeBlogBundle:Blog:index</string>
   ..
   17              </map>
   18          </default>
   19:     </route>
   20: </routes>
   21  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/map_in_list_defaults.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2: <routes xmlns="http://symfony.com/schema/routing"
    3      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    4      xsi:schemaLocation="http://symfony.com/schema/routing
    5          http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="blog" path="/blog">
    8          <default key="_controller">
    9              <string>AcmeBlogBundle:Blog:index</string>
   ..
   19              </list>
   20          </default>
   21:     </route>
   22: </routes>
   23  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/map_in_map_defaults.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2: <routes xmlns="http://symfony.com/schema/routing"
    3      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    4      xsi:schemaLocation="http://symfony.com/schema/routing
    5          http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="blog" path="/blog">
    8          <default key="_controller">
    9              <string>AcmeBlogBundle:Blog:index</string>
   ..
   19              </map>
   20          </default>
   21:     </route>
   22: </routes>
   23  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/map_null_values.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2: <routes xmlns="http://symfony.com/schema/routing"
    3          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    4          xsi:schemaLocation="http://symfony.com/schema/routing
    5          http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="blog" path="/blog">
    8          <default key="_controller">
    9              <string>AcmeBlogBundle:Blog:index</string>
   ..
   19              </map>
   20          </default>
   21:     </route>
   22: </routes>
   23  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/missing_id.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2  
    3: <routes xmlns="http://symfony.com/schema/routing"
    4      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    5      xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route path="/test"></route>
    8: </routes>
    9  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/missing_path.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2  
    3: <routes xmlns="http://symfony.com/schema/routing"
    4      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    5      xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="myroute"></route>
    8: </routes>
    9  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/namespaceprefix.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2  
    3: <r:routes xmlns:r="http://symfony.com/schema/routing"
    4      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    5      xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <r:route id="blog_show" path="/blog/{slug}" host="{_locale}.example.com">
    8          <r:default key="_controller">MyBundle:Blog:show</r:default>
    9          <requirement xmlns="http://symfony.com/schema/routing" key="slug">\w+</requirement>
   10          <r2:requirement xmlns:r2="http://symfony.com/schema/routing" key="_locale">en|fr|de</r2:requirement>
   11:         <r:option key="compiler_class">RouteCompiler</r:option>
   12          <r:default key="page">
   13              <r3:int xmlns:r3="http://symfony.com/schema/routing">1</r3:int>
   14          </r:default>
   15:     </r:route>
   16: </r:routes>
   17  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/nonvalid.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2  
    3: <routes xmlns="http://symfony.com/schema/routing"
    4      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    5      xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="blog_show" path="/blog/{slug}">
    8          <default key="_controller">MyBundle:Blog:show</default>
    9:     <!-- </route> -->
   10: </routes>
   11  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/nonvalid2.yml:
    1: route: string
    2  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/nonvalidkeys.yml:
    1: someroute:
    2    resource: path/to/some.yml
    3    name_prefix: test_

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/nonvalidnode.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2  
    3: <routes xmlns="http://symfony.com/schema/routing"
    4      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    5      xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7      <foo>bar</foo>
    8: </routes>
    9  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/nonvalidroute.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2  
    3: <routes xmlns="http://symfony.com/schema/routing"
    4      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    5      xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="blog_show" path="/blog/{slug}">
    8          <default key="_controller">MyBundle:Blog:show</default>
    9:         <option key="compiler_class">RouteCompiler</option>
   10          <foo key="bar">baz</foo>
   11:     </route>
   12: </routes>
   13  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/null_values.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2: <routes xmlns="http://symfony.com/schema/routing"
    3      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    4      xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd">
    5  
    6:     <route id="blog_show" path="/blog/{slug}">
    7          <default key="foo" xsi:nil="true" />
    8          <default key="bar" xsi:nil="1" />
    9          <default key="foobar" xsi:nil="false">foo</default>
   10          <default key="baz" xsi:nil="0">bar</default>
   11:     </route>
   12: </routes>
   13  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/scalar_defaults.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2: <routes xmlns="http://symfony.com/schema/routing"
    3      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    4      xsi:schemaLocation="http://symfony.com/schema/routing
    5          http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="blog" path="/blog">
    8          <default key="_controller">
    9              <string>AcmeBlogBundle:Blog:index</string>
   ..
   30          <default key="foo" xsi:nil="true" />
   31          <default key="bar" xsi:nil="1" />
   32:     </route>
   33: </routes>
   34  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/validpattern.php:
    1  <?php
    2  
    3: use Symfony\Component\Routing\RouteCollection;
    4: use Symfony\Component\Routing\Route;
    5  
    6: $collection = new RouteCollection();
    7: $collection->add('blog_show', new Route(
    8      '/blog/{slug}',
    9      array('_controller' => 'MyBlogBundle:Blog:show'),
   10      array('locale' => '\w+'),
   11:     array('compiler_class' => 'RouteCompiler'),
   12      '{locale}.example.com',
   13      array('https'),

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/validpattern.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2  
    3: <routes xmlns="http://symfony.com/schema/routing"
    4      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    5      xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd">
    6  
    7:     <route id="blog_show" path="/blog/{slug}" host="{locale}.example.com" methods="GET|POST  put,OpTiOnS" schemes="hTTps">
    8          <default key="_controller">MyBundle:Blog:show</default>
    9          <requirement key="locale">\w+</requirement>
   10:         <option key="compiler_class">RouteCompiler</option>
   11          <condition>context.getMethod() == "GET"</condition>
   12:     </route>
   13  
   14:     <route id="blog_show_inherited" path="/blog/{slug}" />
   15: </routes>
   16  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/validpattern.yml:
    8      condition:    'context.getMethod() == "GET"'
    9      options:
   10:         compiler_class: RouteCompiler
   11  
   12  blog_show_inherited:

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/validresource.php:
    2  
    3  /** @var $loader \Symfony\Component\Routing\Loader\PhpFileLoader */
    4: /** @var \Symfony\Component\Routing\RouteCollection $collection */
    5  $collection = $loader->import('validpattern.php');
    6  $collection->addDefaults(array(

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/validresource.xml:
    1  <?xml version="1.0" encoding="UTF-8" ?>
    2  
    3: <routes xmlns="http://symfony.com/schema/routing"
    4      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    5      xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd">
    .
   11          <condition>context.getMethod() == "POST"</condition>
   12      </import>
   13: </routes>
   14  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Fixtures/with_define_path_variable.php:
    3  $path = '/1/2/3';
    4  
    5: return new \Symfony\Component\Routing\RouteCollection();
    6  

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Generator/Dumper/PhpGeneratorDumperTest.php:
   14  use PHPUnit\Framework\TestCase;
   15  use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
   16: use Symfony\Component\Routing\RouteCollection;
   17: use Symfony\Component\Routing\Route;
   18  use Symfony\Component\Routing\Generator\Dumper\PhpGeneratorDumper;
   19  use Symfony\Component\Routing\RequestContext;
   ..
   22  {
   23      /**
   24:      * @var RouteCollection
   25       */
   26:     private $routeCollection;
   27  
   28      /**
   ..
   45          parent::setUp();
   46  
   47:         $this->routeCollection = new RouteCollection();
   48:         $this->generatorDumper = new PhpGeneratorDumper($this->routeCollection);
   49          $this->testTmpFilepath = sys_get_temp_dir().DIRECTORY_SEPARATOR.'php_generator.'.$this->getName().'.php';
   50          $this->largeTestTmpFilepath = sys_get_temp_dir().DIRECTORY_SEPARATOR.'php_generator.'.$this->getName().'.large.php';
   ..
   59          @unlink($this->testTmpFilepath);
   60  
   61:         $this->routeCollection = null;
   62          $this->generatorDumper = null;
   63          $this->testTmpFilepath = null;
   64      }
   65  
   66:     public function testDumpWithRoutes()
   67      {
   68:         $this->routeCollection->add('Test', new Route('/testing/{foo}'));
   69:         $this->routeCollection->add('Test2', new Route('/testing2'));
   70  
   71          file_put_contents($this->testTmpFilepath, $this->generatorDumper->dump());
   ..
   85      }
   86  
   87:     public function testDumpWithTooManyRoutes()
   88      {
   89          if (defined('HHVM_VERSION_ID')) {
   ..
   91          }
   92  
   93:         $this->routeCollection->add('Test', new Route('/testing/{foo}'));
   94          for ($i = 0; $i < 32769; ++$i) {
   95:             $this->routeCollection->add('route_'.$i, new Route('/route_'.$i));
   96          }
   97:         $this->routeCollection->add('Test2', new Route('/testing2'));
   98  
   99          file_put_contents($this->largeTestTmpFilepath, $this->generatorDumper->dump(array(
  100              'class' => 'ProjectLargeUrlGenerator',
  101          )));
  102:         $this->routeCollection = $this->generatorDumper = null;
  103          include $this->largeTestTmpFilepath;
  104  
  ...
  119       * @expectedException \InvalidArgumentException
  120       */
  121:     public function testDumpWithoutRoutes()
  122      {
  123:         file_put_contents($this->testTmpFilepath, $this->generatorDumper->dump(array('class' => 'WithoutRoutesUrlGenerator')));
  124          include $this->testTmpFilepath;
  125  
  126:         $projectUrlGenerator = new \WithoutRoutesUrlGenerator(new RequestContext('/app.php'));
  127  
  128          $projectUrlGenerator->generate('Test', array());
  ...
  130  
  131      /**
  132:      * @expectedException \Symfony\Component\Routing\Exception\RouteNotFoundException
  133       */
  134:     public function testGenerateNonExistingRoute()
  135      {
  136:         $this->routeCollection->add('Test', new Route('/test'));
  137  
  138:         file_put_contents($this->testTmpFilepath, $this->generatorDumper->dump(array('class' => 'NonExistingRoutesUrlGenerator')));
  139          include $this->testTmpFilepath;
  140  
  141:         $projectUrlGenerator = new \NonExistingRoutesUrlGenerator(new RequestContext());
  142          $url = $projectUrlGenerator->generate('NonExisting', array());
  143      }
  144  
  145:     public function testDumpForRouteWithDefaults()
  146      {
  147:         $this->routeCollection->add('Test', new Route('/testing/{foo}', array('foo' => 'bar')));
  148  
  149:         file_put_contents($this->testTmpFilepath, $this->generatorDumper->dump(array('class' => 'DefaultRoutesUrlGenerator')));
  150          include $this->testTmpFilepath;
  151  
  152:         $projectUrlGenerator = new \DefaultRoutesUrlGenerator(new RequestContext());
  153          $url = $projectUrlGenerator->generate('Test', array());
  154  
  ...
  158      public function testDumpWithSchemeRequirement()
  159      {
  160:         $this->routeCollection->add('Test1', new Route('/testing', array(), array(), array(), '', array('ftp', 'https')));
  161  
  162          file_put_contents($this->testTmpFilepath, $this->generatorDumper->dump(array('class' => 'SchemeUrlGenerator')));

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Generator/UrlGeneratorTest.php:
   13  
   14  use PHPUnit\Framework\TestCase;
   15: use Symfony\Component\Routing\RouteCollection;
   16: use Symfony\Component\Routing\Route;
   17  use Symfony\Component\Routing\Generator\UrlGenerator;
   18  use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
   ..
   23      public function testAbsoluteUrlWithPort80()
   24      {
   25:         $routes = $this->getRoutes('test', new Route('/testing'));
   26:         $url = $this->getGenerator($routes)->generate('test', array(), UrlGeneratorInterface::ABSOLUTE_URL);
   27  
   28          $this->assertEquals('http://localhost/app.php/testing', $url);
   ..
   31      public function testAbsoluteSecureUrlWithPort443()
   32      {
   33:         $routes = $this->getRoutes('test', new Route('/testing'));
   34:         $url = $this->getGenerator($routes, array('scheme' => 'https'))->generate('test', array(), UrlGeneratorInterface::ABSOLUTE_URL);
   35  
   36          $this->assertEquals('https://localhost/app.php/testing', $url);
   ..
   39      public function testAbsoluteUrlWithNonStandardPort()
   40      {
   41:         $routes = $this->getRoutes('test', new Route('/testing'));
   42:         $url = $this->getGenerator($routes, array('httpPort' => 8080))->generate('test', array(), UrlGeneratorInterface::ABSOLUTE_URL);
   43  
   44          $this->assertEquals('http://localhost:8080/app.php/testing', $url);
   ..
   47      public function testAbsoluteSecureUrlWithNonStandardPort()
   48      {
   49:         $routes = $this->getRoutes('test', new Route('/testing'));
   50:         $url = $this->getGenerator($routes, array('httpsPort' => 8080, 'scheme' => 'https'))->generate('test', array(), UrlGeneratorInterface::ABSOLUTE_URL);
   51  
   52          $this->assertEquals('https://localhost:8080/app.php/testing', $url);
   ..
   55      public function testRelativeUrlWithoutParameters()
   56      {
   57:         $routes = $this->getRoutes('test', new Route('/testing'));
   58:         $url = $this->getGenerator($routes)->generate('test', array(), UrlGeneratorInterface::ABSOLUTE_PATH);
   59  
   60          $this->assertEquals('/app.php/testing', $url);
   ..
   63      public function testRelativeUrlWithParameter()
   64      {
   65:         $routes = $this->getRoutes('test', new Route('/testing/{foo}'));
   66:         $url = $this->getGenerator($routes)->generate('test', array('foo' => 'bar'), UrlGeneratorInterface::ABSOLUTE_PATH);
   67  
   68          $this->assertEquals('/app.php/testing/bar', $url);
   ..
   71      public function testRelativeUrlWithNullParameter()
   72      {
   73:         $routes = $this->getRoutes('test', new Route('/testing.{format}', array('format' => null)));
   74:         $url = $this->getGenerator($routes)->generate('test', array(), UrlGeneratorInterface::ABSOLUTE_PATH);
   75  
   76          $this->assertEquals('/app.php/testing', $url);
   ..
   82      public function testRelativeUrlWithNullParameterButNotOptional()
   83      {
   84:         $routes = $this->getRoutes('test', new Route('/testing/{foo}/bar', array('foo' => null)));
   85          // This must raise an exception because the default requirement for "foo" is "[^/]+" which is not met with these params.
   86:         // Generating path "/testing//bar" would be wrong as matching this route would fail.
   87:         $this->getGenerator($routes)->generate('test', array(), UrlGeneratorInterface::ABSOLUTE_PATH);
   88      }
   89  
   90      public function testRelativeUrlWithOptionalZeroParameter()
   91      {
   92:         $routes = $this->getRoutes('test', new Route('/testing/{page}'));
   93:         $url = $this->getGenerator($routes)->generate('test', array('page' => 0), UrlGeneratorInterface::ABSOLUTE_PATH);
   94  
   95          $this->assertEquals('/app.php/testing/0', $url);
   ..
   98      public function testNotPassedOptionalParameterInBetween()
   99      {
  100:         $routes = $this->getRoutes('test', new Route('/{slug}/{page}', array('slug' => 'index', 'page' => 0)));
  101:         $this->assertSame('/app.php/index/1', $this->getGenerator($routes)->generate('test', array('page' => 1)));
  102:         $this->assertSame('/app.php/', $this->getGenerator($routes)->generate('test'));
  103      }
  104  
  105      public function testRelativeUrlWithExtraParameters()
  106      {
  107:         $routes = $this->getRoutes('test', new Route('/testing'));
  108:         $url = $this->getGenerator($routes)->generate('test', array('foo' => 'bar'), UrlGeneratorInterface::ABSOLUTE_PATH);
  109  
  110          $this->assertEquals('/app.php/testing?foo=bar', $url);
  ...
  113      public function testAbsoluteUrlWithExtraParameters()
  114      {
  115:         $routes = $this->getRoutes('test', new Route('/testing'));
  116:         $url = $this->getGenerator($routes)->generate('test', array('foo' => 'bar'), UrlGeneratorInterface::ABSOLUTE_URL);
  117  
  118          $this->assertEquals('http://localhost/app.php/testing?foo=bar', $url);
  ...
  121      public function testUrlWithNullExtraParameters()
  122      {
  123:         $routes = $this->getRoutes('test', new Route('/testing'));
  124:         $url = $this->getGenerator($routes)->generate('test', array('foo' => null), UrlGeneratorInterface::ABSOLUTE_URL);
  125  
  126          $this->assertEquals('http://localhost/app.php/testing', $url);
  ...
  129      public function testUrlWithExtraParametersFromGlobals()
  130      {
  131:         $routes = $this->getRoutes('test', new Route('/testing'));
  132:         $generator = $this->getGenerator($routes);
  133          $context = new RequestContext('/app.php');
  134          $context->setParameter('bar', 'bar');
  ...
  141      public function testUrlWithGlobalParameter()
  142      {
  143:         $routes = $this->getRoutes('test', new Route('/testing/{foo}'));
  144:         $generator = $this->getGenerator($routes);
  145          $context = new RequestContext('/app.php');
  146          $context->setParameter('foo', 'bar');
  ...
  153      public function testGlobalParameterHasHigherPriorityThanDefault()
  154      {
  155:         $routes = $this->getRoutes('test', new Route('/{_locale}', array('_locale' => 'en')));
  156:         $generator = $this->getGenerator($routes);
  157          $context = new RequestContext('/app.php');
  158          $context->setParameter('_locale', 'de');
  ...
  164  
  165      /**
  166:      * @expectedException \Symfony\Component\Routing\Exception\RouteNotFoundException
  167       */
  168:     public function testGenerateWithoutRoutes()
  169      {
  170:         $routes = $this->getRoutes('foo', new Route('/testing/{foo}'));
  171:         $this->getGenerator($routes)->generate('test', array(), UrlGeneratorInterface::ABSOLUTE_URL);
  172      }
  173  
  ...
  175       * @expectedException \Symfony\Component\Routing\Exception\MissingMandatoryParametersException
  176       */
  177:     public function testGenerateForRouteWithoutMandatoryParameter()
  178      {
  179:         $routes = $this->getRoutes('test', new Route('/testing/{foo}'));
  180:         $this->getGenerator($routes)->generate('test', array(), UrlGeneratorInterface::ABSOLUTE_URL);
  181      }
  182  
  ...
  184       * @expectedException \Symfony\Component\Routing\Exception\InvalidParameterException
  185       */
  186:     public function testGenerateForRouteWithInvalidOptionalParameter()
  187      {
  188:         $routes = $this->getRoutes('test', new Route('/testing/{foo}', array('foo' => '1'), array('foo' => 'd+')));
  189:         $this->getGenerator($routes)->generate('test', array('foo' => 'bar'), UrlGeneratorInterface::ABSOLUTE_URL);
  190      }
  191  
  ...
  193       * @expectedException \Symfony\Component\Routing\Exception\InvalidParameterException
  194       */
  195:     public function testGenerateForRouteWithInvalidParameter()
  196      {
  197:         $routes = $this->getRoutes('test', new Route('/testing/{foo}', array(), array('foo' => '1|2')));
  198:         $this->getGenerator($routes)->generate('test', array('foo' => '0'), UrlGeneratorInterface::ABSOLUTE_URL);
  199      }
  200  
  201:     public function testGenerateForRouteWithInvalidOptionalParameterNonStrict()
  202      {
  203:         $routes = $this->getRoutes('test', new Route('/testing/{foo}', array('foo' => '1'), array('foo' => 'd+')));
  204:         $generator = $this->getGenerator($routes);
  205          $generator->setStrictRequirements(false);
  206          $this->assertNull($generator->generate('test', array('foo' => 'bar'), UrlGeneratorInterface::ABSOLUTE_URL));
  207      }
  208  
  209:     public function testGenerateForRouteWithInvalidOptionalParameterNonStrictWithLogger()
  210      {
  211:         $routes = $this->getRoutes('test', new Route('/testing/{foo}', array('foo' => '1'), array('foo' => 'd+')));
  212          $logger = $this->getMockBuilder('Psr\Log\LoggerInterface')->getMock();
  213          $logger->expects($this->once())
  214              ->method('error');
  215:         $generator = $this->getGenerator($routes, array(), $logger);
  216          $generator->setStrictRequirements(false);
  217          $this->assertNull($generator->generate('test', array('foo' => 'bar'), UrlGeneratorInterface::ABSOLUTE_URL));
  218      }
  219  
  220:     public function testGenerateForRouteWithInvalidParameterButDisabledRequirementsCheck()
  221      {
  222:         $routes = $this->getRoutes('test', new Route('/testing/{foo}', array('foo' => '1'), array('foo' => 'd+')));
  223:         $generator = $this->getGenerator($routes);
  224          $generator->setStrictRequirements(null);
  225          $this->assertSame('/app.php/testing/bar', $generator->generate('test', array('foo' => 'bar')));
  ...
  229       * @expectedException \Symfony\Component\Routing\Exception\InvalidParameterException
  230       */
  231:     public function testGenerateForRouteWithInvalidMandatoryParameter()
  232      {
  233:         $routes = $this->getRoutes('test', new Route('/testing/{foo}', array(), array('foo' => 'd+')));
  234:         $this->getGenerator($routes)->generate('test', array('foo' => 'bar'), UrlGeneratorInterface::ABSOLUTE_URL);
  235      }
  236  
  ...
  238       * @expectedException \Symfony\Component\Routing\Exception\InvalidParameterException
  239       */
  240:     public function testGenerateForRouteWithInvalidUtf8Parameter()
  241      {
  242:         $routes = $this->getRoutes('test', new Route('/testing/{foo}', array(), array('foo' => '\pL+'), array('utf8' => true)));
  243:         $this->getGenerator($routes)->generate('test', array('foo' => 'abc123'), UrlGeneratorInterface::ABSOLUTE_URL);
  244      }
  245  
  ...
  249      public function testRequiredParamAndEmptyPassed()
  250      {
  251:         $routes = $this->getRoutes('test', new Route('/{slug}', array(), array('slug' => '.+')));
  252:         $this->getGenerator($routes)->generate('test', array('slug' => ''));
  253      }
  254  
  255      public function testSchemeRequirementDoesNothingIfSameCurrentScheme()
  256      {
  257:         $routes = $this->getRoutes('test', new Route('/', array(), array(), array(), '', array('http')));
  258:         $this->assertEquals('/app.php/', $this->getGenerator($routes)->generate('test'));
  259  
  260:         $routes = $this->getRoutes('test', new Route('/', array(), array(), array(), '', array('https')));
  261:         $this->assertEquals('/app.php/', $this->getGenerator($routes, array('scheme' => 'https'))->generate('test'));
  262      }
  263  
  264      public function testSchemeRequirementForcesAbsoluteUrl()
  265      {
  266:         $routes = $this->getRoutes('test', new Route('/', array(), array(), array(), '', array('https')));
  267:         $this->assertEquals('https://localhost/app.php/', $this->getGenerator($routes)->generate('test'));
  268  
  269:         $routes = $this->getRoutes('test', new Route('/', array(), array(), array(), '', array('http')));
  270:         $this->assertEquals('http://localhost/app.php/', $this->getGenerator($routes, array('scheme' => 'https'))->generate('test'));
  271      }
  272  
  273      public function testSchemeRequirementCreatesUrlForFirstRequiredScheme()
  274      {
  275:         $routes = $this->getRoutes('test', new Route('/', array(), array(), array(), '', array('Ftp', 'https')));
  276:         $this->assertEquals('ftp://localhost/app.php/', $this->getGenerator($routes)->generate('test'));
  277      }
  278  
  279      public function testPathWithTwoStartingSlashes()
  280      {
  281:         $routes = $this->getRoutes('test', new Route('//path-and-not-domain'));
  282  
  283          // this must not generate '//path-and-not-domain' because that would be a network path
  284:         $this->assertSame('/path-and-not-domain', $this->getGenerator($routes, array('BaseUrl' => ''))->generate('test'));
  285      }
  286  
  287      public function testNoTrailingSlashForMultipleOptionalParameters()
  288      {
  289:         $routes = $this->getRoutes('test', new Route('/category/{slug1}/{slug2}/{slug3}', array('slug2' => null, 'slug3' => null)));
  290  
  291:         $this->assertEquals('/app.php/category/foo', $this->getGenerator($routes)->generate('test', array('slug1' => 'foo')));
  292      }
  293  
  294      public function testWithAnIntegerAsADefaultValue()
  295      {
  296:         $routes = $this->getRoutes('test', new Route('/{default}', array('default' => 0)));
  297  
  298:         $this->assertEquals('/app.php/foo', $this->getGenerator($routes)->generate('test', array('default' => 'foo')));
  299      }
  300  
  301      public function testNullForOptionalParameterIsIgnored()
  302      {
  303:         $routes = $this->getRoutes('test', new Route('/test/{default}', array('default' => 0)));
  304  
  305:         $this->assertEquals('/app.php/test', $this->getGenerator($routes)->generate('test', array('default' => null)));
  306      }
  307  
  308      public function testQueryParamSameAsDefault()
  309      {
  310:         $routes = $this->getRoutes('test', new Route('/test', array('page' => 1)));
  311  
  312:         $this->assertSame('/app.php/test?page=2', $this->getGenerator($routes)->generate('test', array('page' => 2)));
  313:         $this->assertSame('/app.php/test', $this->getGenerator($routes)->generate('test', array('page' => 1)));
  314:         $this->assertSame('/app.php/test', $this->getGenerator($routes)->generate('test', array('page' => '1')));
  315:         $this->assertSame('/app.php/test', $this->getGenerator($routes)->generate('test'));
  316      }
  317  
  318      public function testArrayQueryParamSameAsDefault()
  319      {
  320:         $routes = $this->getRoutes('test', new Route('/test', array('array' => array('foo', 'bar'))));
  321  
  322:         $this->assertSame('/app.php/test?array%5B0%5D=bar&array%5B1%5D=foo', $this->getGenerator($routes)->generate('test', array('array' => array('bar', 'foo'))));
  323:         $this->assertSame('/app.php/test?array%5Ba%5D=foo&array%5Bb%5D=bar', $this->getGenerator($routes)->generate('test', array('array' => array('a' => 'foo', 'b' => 'bar'))));
  324:         $this->assertSame('/app.php/test', $this->getGenerator($routes)->generate('test', array('array' => array('foo', 'bar'))));
  325:         $this->assertSame('/app.php/test', $this->getGenerator($routes)->generate('test', array('array' => array(1 => 'bar', 0 => 'foo'))));
  326:         $this->assertSame('/app.php/test', $this->getGenerator($routes)->generate('test'));
  327      }
  328  
  329:     public function testGenerateWithSpecialRouteName()
  330      {
  331:         $routes = $this->getRoutes('$péß^a|', new Route('/bar'));
  332  
  333:         $this->assertSame('/app.php/bar', $this->getGenerator($routes)->generate('$péß^a|'));
  334      }
  335  
  ...
  343          // and other special ASCII chars. These chars are tested as static text path, variable path and query param.
  344          $chars = '@:[]/()*\'" +,;-._~&$<>|{}%\\^`!?foo=bar#id';
  345:         $routes = $this->getRoutes('test', new Route("/$chars/{varpath}", array(), array('varpath' => '.+')));
  346:         $this->assertSame($expectedPath, $this->getGenerator($routes)->generate('test', array(
  347              'varpath' => $chars,
  348              'query' => $chars,
  ...
  352      public function testEncodingOfRelativePathSegments()
  353      {
  354:         $routes = $this->getRoutes('test', new Route('/dir/../dir/..'));
  355:         $this->assertSame('/app.php/dir/%2E%2E/dir/%2E%2E', $this->getGenerator($routes)->generate('test'));
  356:         $routes = $this->getRoutes('test', new Route('/dir/./dir/.'));
  357:         $this->assertSame('/app.php/dir/%2E/dir/%2E', $this->getGenerator($routes)->generate('test'));
  358:         $routes = $this->getRoutes('test', new Route('/a./.a/a../..a/...'));
  359:         $this->assertSame('/app.php/a./.a/a../..a/...', $this->getGenerator($routes)->generate('test'));
  360      }
  361  
  362      public function testAdjacentVariables()
  363      {
  364:         $routes = $this->getRoutes('test', new Route('/{x}{y}{z}.{_format}', array('z' => 'default-z', '_format' => 'html'), array('y' => '\d+')));
  365:         $generator = $this->getGenerator($routes);
  366          $this->assertSame('/app.php/foo123', $generator->generate('test', array('x' => 'foo', 'y' => '123')));
  367          $this->assertSame('/app.php/foo123bar.xml', $generator->generate('test', array('x' => 'foo', 'y' => '123', 'z' => 'bar', '_format' => 'xml')));
  ...
  375      public function testOptionalVariableWithNoRealSeparator()
  376      {
  377:         $routes = $this->getRoutes('test', new Route('/get{what}', array('what' => 'All')));
  378:         $generator = $this->getGenerator($routes);
  379  
  380          $this->assertSame('/app.php/get', $generator->generate('test'));
  ...
  384      public function testRequiredVariableWithNoRealSeparator()
  385      {
  386:         $routes = $this->getRoutes('test', new Route('/get{what}Suffix'));
  387:         $generator = $this->getGenerator($routes);
  388  
  389          $this->assertSame('/app.php/getSitesSuffix', $generator->generate('test', array('what' => 'Sites')));
  ...
  392      public function testDefaultRequirementOfVariable()
  393      {
  394:         $routes = $this->getRoutes('test', new Route('/{page}.{_format}'));
  395:         $generator = $this->getGenerator($routes);
  396  
  397          $this->assertSame('/app.php/index.mobile.html', $generator->generate('test', array('page' => 'index', '_format' => 'mobile.html')));
  ...
  403      public function testDefaultRequirementOfVariableDisallowsSlash()
  404      {
  405:         $routes = $this->getRoutes('test', new Route('/{page}.{_format}'));
  406:         $this->getGenerator($routes)->generate('test', array('page' => 'index', '_format' => 'sl/ash'));
  407      }
  408  
  ...
  412      public function testDefaultRequirementOfVariableDisallowsNextSeparator()
  413      {
  414:         $routes = $this->getRoutes('test', new Route('/{page}.{_format}'));
  415:         $this->getGenerator($routes)->generate('test', array('page' => 'do.t', '_format' => 'html'));
  416      }
  417  
  418      public function testWithHostDifferentFromContext()
  419      {
  420:         $routes = $this->getRoutes('test', new Route('/{name}', array(), array(), array(), '{locale}.example.com'));
  421  
  422:         $this->assertEquals('//fr.example.com/app.php/Fabien', $this->getGenerator($routes)->generate('test', array('name' => 'Fabien', 'locale' => 'fr')));
  423      }
  424  
  425      public function testWithHostSameAsContext()
  426      {
  427:         $routes = $this->getRoutes('test', new Route('/{name}', array(), array(), array(), '{locale}.example.com'));
  428  
  429:         $this->assertEquals('/app.php/Fabien', $this->getGenerator($routes, array('host' => 'fr.example.com'))->generate('test', array('name' => 'Fabien', 'locale' => 'fr')));
  430      }
  431  
  432      public function testWithHostSameAsContextAndAbsolute()
  433      {
  434:         $routes = $this->getRoutes('test', new Route('/{name}', array(), array(), array(), '{locale}.example.com'));
  435  
  436:         $this->assertEquals('http://fr.example.com/app.php/Fabien', $this->getGenerator($routes, array('host' => 'fr.example.com'))->generate('test', array('name' => 'Fabien', 'locale' => 'fr'), UrlGeneratorInterface::ABSOLUTE_URL));
  437      }
  438  
  ...
  442      public function testUrlWithInvalidParameterInHost()
  443      {
  444:         $routes = $this->getRoutes('test', new Route('/', array(), array('foo' => 'bar'), array(), '{foo}.example.com'));
  445:         $this->getGenerator($routes)->generate('test', array('foo' => 'baz'), UrlGeneratorInterface::ABSOLUTE_PATH);
  446      }
  447  
  ...
  451      public function testUrlWithInvalidParameterInHostWhenParamHasADefaultValue()
  452      {
  453:         $routes = $this->getRoutes('test', new Route('/', array('foo' => 'bar'), array('foo' => 'bar'), array(), '{foo}.example.com'));
  454:         $this->getGenerator($routes)->generate('test', array('foo' => 'baz'), UrlGeneratorInterface::ABSOLUTE_PATH);
  455      }
  456  
  ...
  460      public function testUrlWithInvalidParameterEqualsDefaultValueInHost()
  461      {
  462:         $routes = $this->getRoutes('test', new Route('/', array('foo' => 'baz'), array('foo' => 'bar'), array(), '{foo}.example.com'));
  463:         $this->getGenerator($routes)->generate('test', array('foo' => 'baz'), UrlGeneratorInterface::ABSOLUTE_PATH);
  464      }
  465  
  466      public function testUrlWithInvalidParameterInHostInNonStrictMode()
  467      {
  468:         $routes = $this->getRoutes('test', new Route('/', array(), array('foo' => 'bar'), array(), '{foo}.example.com'));
  469:         $generator = $this->getGenerator($routes);
  470          $generator->setStrictRequirements(false);
  471          $this->assertNull($generator->generate('test', array('foo' => 'baz'), UrlGeneratorInterface::ABSOLUTE_PATH));
  ...
  474      public function testHostIsCaseInsensitive()
  475      {
  476:         $routes = $this->getRoutes('test', new Route('/', array(), array('locale' => 'en|de|fr'), array(), '{locale}.FooBar.com'));
  477:         $generator = $this->getGenerator($routes);
  478          $this->assertSame('//EN.FooBar.com/app.php/', $generator->generate('test', array('locale' => 'EN'), UrlGeneratorInterface::NETWORK_PATH));
  479      }
  ...
  481      public function testGenerateNetworkPath()
  482      {
  483:         $routes = $this->getRoutes('test', new Route('/{name}', array(), array(), array(), '{locale}.example.com', array('http')));
  484  
  485:         $this->assertSame('//fr.example.com/app.php/Fabien', $this->getGenerator($routes)->generate('test',
  486              array('name' => 'Fabien', 'locale' => 'fr'), UrlGeneratorInterface::NETWORK_PATH), 'network path with different host'
  487          );
  488:         $this->assertSame('//fr.example.com/app.php/Fabien?query=string', $this->getGenerator($routes, array('host' => 'fr.example.com'))->generate('test',
  489              array('name' => 'Fabien', 'locale' => 'fr', 'query' => 'string'), UrlGeneratorInterface::NETWORK_PATH), 'network path although host same as context'
  490          );
  491:         $this->assertSame('http://fr.example.com/app.php/Fabien', $this->getGenerator($routes, array('scheme' => 'https'))->generate('test',
  492              array('name' => 'Fabien', 'locale' => 'fr'), UrlGeneratorInterface::NETWORK_PATH), 'absolute URL because scheme requirement does not match context'
  493          );
  494:         $this->assertSame('http://fr.example.com/app.php/Fabien', $this->getGenerator($routes)->generate('test',
  495              array('name' => 'Fabien', 'locale' => 'fr'), UrlGeneratorInterface::ABSOLUTE_URL), 'absolute URL with same scheme because it is requested'
  496          );
  ...
  499      public function testGenerateRelativePath()
  500      {
  501:         $routes = new RouteCollection();
  502:         $routes->add('article', new Route('/{author}/{article}/'));
  503:         $routes->add('comments', new Route('/{author}/{article}/comments'));
  504:         $routes->add('host', new Route('/{article}', array(), array(), array(), '{author}.example.com'));
  505:         $routes->add('scheme', new Route('/{author}/blog', array(), array(), array(), '', array('https')));
  506:         $routes->add('unrelated', new Route('/about'));
  507  
  508:         $generator = $this->getGenerator($routes, array('host' => 'example.com', 'pathInfo' => '/fabien/symfony-is-great/'));
  509  
  510          $this->assertSame('comments', $generator->generate('comments',
  ...
  647      public function testFragmentsCanBeAppendedToUrls()
  648      {
  649:         $routes = $this->getRoutes('test', new Route('/testing'));
  650  
  651:         $url = $this->getGenerator($routes)->generate('test', array('_fragment' => 'frag ment'), UrlGeneratorInterface::ABSOLUTE_PATH);
  652          $this->assertEquals('/app.php/testing#frag%20ment', $url);
  653  
  654:         $url = $this->getGenerator($routes)->generate('test', array('_fragment' => '0'), UrlGeneratorInterface::ABSOLUTE_PATH);
  655          $this->assertEquals('/app.php/testing#0', $url);
  656      }
  ...
  658      public function testFragmentsDoNotEscapeValidCharacters()
  659      {
  660:         $routes = $this->getRoutes('test', new Route('/testing'));
  661:         $url = $this->getGenerator($routes)->generate('test', array('_fragment' => '?/'), UrlGeneratorInterface::ABSOLUTE_PATH);
  662  
  663          $this->assertEquals('/app.php/testing#?/', $url);
  ...
  666      public function testFragmentsCanBeDefinedAsDefaults()
  667      {
  668:         $routes = $this->getRoutes('test', new Route('/testing', array('_fragment' => 'fragment')));
  669:         $url = $this->getGenerator($routes)->generate('test', array(), UrlGeneratorInterface::ABSOLUTE_PATH);
  670  
  671          $this->assertEquals('/app.php/testing#fragment', $url);
  672      }
  673  
  674:     protected function getGenerator(RouteCollection $routes, array $parameters = array(), $logger = null)
  675      {
  676          $context = new RequestContext('/app.php');
  ...
  680          }
  681  
  682:         return new UrlGenerator($routes, $context, $logger);
  683      }
  684  
  685:     protected function getRoutes($name, Route $route)
  686      {
  687:         $routes = new RouteCollection();
  688:         $routes->add($name, $route);
  689  
  690:         return $routes;
  691      }
  692  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Loader/AnnotationClassLoaderTest.php:
   12  namespace Symfony\Component\Routing\Tests\Loader;
   13  
   14: use Symfony\Component\Routing\Annotation\Route;
   15  
   16  class AnnotationClassLoaderTest extends AbstractAnnotationLoaderTest
   ..
   75              array(
   76                  'Symfony\Component\Routing\Tests\Fixtures\AnnotatedClasses\BarClass',
   77:                 array('name' => 'route1', 'path' => '/path'),
   78                  array('arg2' => 'defaultValue2', 'arg3' => 'defaultValue3'),
   79              ),
   ..
  104       * @dataProvider getLoadTests
  105       */
  106:     public function testLoad($className, $routeData = array(), $methodArgs = array())
  107      {
  108:         $routeData = array_replace(array(
  109:             'name' => 'route',
  110              'path' => '/',
  111              'requirements' => array(),
  ...
  115              'methods' => array(),
  116              'condition' => '',
  117:         ), $routeData);
  118  
  119          $this->reader
  120              ->expects($this->once())
  121              ->method('getMethodAnnotations')
  122:             ->will($this->returnValue(array($this->getAnnotatedRoute($routeData))))
  123          ;
  124  
  125:         $routeCollection = $this->loader->load($className);
  126:         $route = $routeCollection->get($routeData['name']);
  127  
  128:         $this->assertSame($routeData['path'], $route->getPath(), '->load preserves path annotation');
  129          $this->assertCount(
  130:             count($routeData['requirements']),
  131:             array_intersect_assoc($routeData['requirements'], $route->getRequirements()),
  132              '->load preserves requirements annotation'
  133          );
  134          $this->assertCount(
  135:             count($routeData['options']),
  136:             array_intersect_assoc($routeData['options'], $route->getOptions()),
  137              '->load preserves options annotation'
  138          );
  139          $this->assertCount(
  140:             count($routeData['defaults']),
  141:             $route->getDefaults(),
  142              '->load preserves defaults annotation'
  143          );
  144:         $this->assertEquals($routeData['schemes'], $route->getSchemes(), '->load preserves schemes annotation');
  145:         $this->assertEquals($routeData['methods'], $route->getMethods(), '->load preserves methods annotation');
  146:         $this->assertSame($routeData['condition'], $route->getCondition(), '->load preserves condition annotation');
  147      }
  148  
  149:     public function testClassRouteLoad()
  150      {
  151:         $classRouteData = array(
  152              'path' => '/prefix',
  153              'schemes' => array('https'),
  ...
  155          );
  156  
  157:         $methodRouteData = array(
  158:             'name' => 'route1',
  159              'path' => '/path',
  160              'schemes' => array('http'),
  ...
  165              ->expects($this->once())
  166              ->method('getClassAnnotation')
  167:             ->will($this->returnValue($this->getAnnotatedRoute($classRouteData)))
  168          ;
  169          $this->reader
  170              ->expects($this->once())
  171              ->method('getMethodAnnotations')
  172:             ->will($this->returnValue(array($this->getAnnotatedRoute($methodRouteData))))
  173          ;
  174  
  175:         $routeCollection = $this->loader->load('Symfony\Component\Routing\Tests\Fixtures\AnnotatedClasses\BarClass');
  176:         $route = $routeCollection->get($methodRouteData['name']);
  177  
  178:         $this->assertSame($classRouteData['path'].$methodRouteData['path'], $route->getPath(), '->load concatenates class and method route path');
  179:         $this->assertEquals(array_merge($classRouteData['schemes'], $methodRouteData['schemes']), $route->getSchemes(), '->load merges class and method route schemes');
  180:         $this->assertEquals(array_merge($classRouteData['methods'], $methodRouteData['methods']), $route->getMethods(), '->load merges class and method route methods');
  181      }
  182  
  183:     public function testInvokableClassRouteLoad()
  184      {
  185:         $classRouteData = array(
  186:             'name' => 'route1',
  187              'path' => '/',
  188              'schemes' => array('https'),
  ...
  193              ->expects($this->exactly(2))
  194              ->method('getClassAnnotation')
  195:             ->will($this->returnValue($this->getAnnotatedRoute($classRouteData)))
  196          ;
  197          $this->reader
  ...
  201          ;
  202  
  203:         $routeCollection = $this->loader->load('Symfony\Component\Routing\Tests\Fixtures\AnnotatedClasses\BazClass');
  204:         $route = $routeCollection->get($classRouteData['name']);
  205  
  206:         $this->assertSame($classRouteData['path'], $route->getPath(), '->load preserves class route path');
  207:         $this->assertEquals(array_merge($classRouteData['schemes'], $classRouteData['schemes']), $route->getSchemes(), '->load preserves class route schemes');
  208:         $this->assertEquals(array_merge($classRouteData['methods'], $classRouteData['methods']), $route->getMethods(), '->load preserves class route methods');
  209      }
  210  
  211:     public function testInvokableClassWithMethodRouteLoad()
  212      {
  213:         $classRouteData = array(
  214:             'name' => 'route1',
  215              'path' => '/prefix',
  216              'schemes' => array('https'),
  ...
  218          );
  219  
  220:         $methodRouteData = array(
  221:             'name' => 'route2',
  222              'path' => '/path',
  223              'schemes' => array('http'),
  ...
  228              ->expects($this->once())
  229              ->method('getClassAnnotation')
  230:             ->will($this->returnValue($this->getAnnotatedRoute($classRouteData)))
  231          ;
  232          $this->reader
  233              ->expects($this->once())
  234              ->method('getMethodAnnotations')
  235:             ->will($this->returnValue(array($this->getAnnotatedRoute($methodRouteData))))
  236          ;
  237  
  238:         $routeCollection = $this->loader->load('Symfony\Component\Routing\Tests\Fixtures\AnnotatedClasses\BazClass');
  239:         $route = $routeCollection->get($classRouteData['name']);
  240  
  241:         $this->assertNull($route, '->load ignores class route');
  242  
  243:         $route = $routeCollection->get($methodRouteData['name']);
  244  
  245:         $this->assertSame($classRouteData['path'].$methodRouteData['path'], $route->getPath(), '->load concatenates class and method route path');
  246:         $this->assertEquals(array_merge($classRouteData['schemes'], $methodRouteData['schemes']), $route->getSchemes(), '->load merges class and method route schemes');
  247:         $this->assertEquals(array_merge($classRouteData['methods'], $methodRouteData['methods']), $route->getMethods(), '->load merges class and method route methods');
  248      }
  249  
  250:     private function getAnnotatedRoute($data)
  251      {
  252:         return new Route($data);
  253      }
  254  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Loader/AnnotationFileLoaderTest.php:
   14  use Symfony\Component\Routing\Loader\AnnotationFileLoader;
   15  use Symfony\Component\Config\FileLocator;
   16: use Symfony\Component\Routing\Annotation\Route;
   17  
   18  class AnnotationFileLoaderTest extends AbstractAnnotationLoaderTest
   ..
   60      public function testLoadVariadic()
   61      {
   62:         $route = new Route(array('path' => '/path/to/{id}'));
   63          $this->reader->expects($this->once())->method('getClassAnnotation');
   64          $this->reader->expects($this->once())->method('getMethodAnnotations')
   65:             ->will($this->returnValue(array($route)));
   66  
   67          $this->loader->load(__DIR__.'/../Fixtures/OtherAnnotatedClasses/VariadicClass.php');

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Loader/ClosureLoaderTest.php:
   14  use PHPUnit\Framework\TestCase;
   15  use Symfony\Component\Routing\Loader\ClosureLoader;
   16: use Symfony\Component\Routing\Route;
   17: use Symfony\Component\Routing\RouteCollection;
   18  
   19  class ClosureLoaderTest extends TestCase
   ..
   36          $loader = new ClosureLoader();
   37  
   38:         $route = new Route('/');
   39:         $routes = $loader->load(function () use ($route) {
   40:             $routes = new RouteCollection();
   41  
   42:             $routes->add('foo', $route);
   43  
   44:             return $routes;
   45          });
   46  
   47:         $this->assertEquals($route, $routes->get('foo'), '->load() loads a \Closure resource');
   48      }
   49  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Loader/DirectoryLoaderTest.php:
   17  use Symfony\Component\Config\Loader\LoaderResolver;
   18  use Symfony\Component\Config\FileLocator;
   19: use Symfony\Component\Routing\RouteCollection;
   20  
   21  class DirectoryLoaderTest extends AbstractAnnotationLoaderTest
   ..
   51      }
   52  
   53:     private function verifyCollection(RouteCollection $collection)
   54      {
   55:         $routes = $collection->all();
   56  
   57:         $this->assertCount(3, $routes, 'Three routes are loaded');
   58:         $this->assertContainsOnly('Symfony\Component\Routing\Route', $routes);
   59  
   60          for ($i = 1; $i <= 3; ++$i) {
   61:             $this->assertSame('/route/'.$i, $routes['route'.$i]->getPath());
   62          }
   63      }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Loader/ObjectRouteLoaderTest.php:
   13  
   14  use PHPUnit\Framework\TestCase;
   15: use Symfony\Component\Routing\Loader\ObjectRouteLoader;
   16: use Symfony\Component\Routing\Route;
   17: use Symfony\Component\Routing\RouteCollection;
   18  
   19: class ObjectRouteLoaderTest extends TestCase
   20  {
   21      public function testLoadCallsServiceAndReturnsCollection()
   22      {
   23:         $loader = new ObjectRouteLoaderForTest();
   24  
   25          // create a basic collection that will be returned
   26:         $collection = new RouteCollection();
   27:         $collection->add('foo', new Route('/foo'));
   28  
   29          $loader->loaderMap = array(
   30:             'my_route_provider_service' => new RouteService($collection),
   31          );
   32  
   33:         $actualRoutes = $loader->load(
   34:             'my_route_provider_service:loadRoutes',
   35              'service'
   36          );
   37  
   38:         $this->assertSame($collection, $actualRoutes);
   39          // the service file should be listed as a resource
   40:         $this->assertNotEmpty($actualRoutes->getResources());
   41      }
   42  
   ..
   47      public function testExceptionWithoutSyntax($resourceString)
   48      {
   49:         $loader = new ObjectRouteLoaderForTest();
   50          $loader->load($resourceString);
   51      }
   ..
   65      public function testExceptionOnNoObjectReturned()
   66      {
   67:         $loader = new ObjectRouteLoaderForTest();
   68          $loader->loaderMap = array('my_service' => 'NOT_AN_OBJECT');
   69          $loader->load('my_service:method');
   ..
   75      public function testExceptionOnBadMethod()
   76      {
   77:         $loader = new ObjectRouteLoaderForTest();
   78          $loader->loaderMap = array('my_service' => new \stdClass());
   79          $loader->load('my_service:method');
   ..
   86      {
   87          $service = $this->getMockBuilder('stdClass')
   88:             ->setMethods(array('loadRoutes'))
   89              ->getMock();
   90          $service->expects($this->once())
   91:             ->method('loadRoutes')
   92              ->will($this->returnValue('NOT_A_COLLECTION'));
   93  
   94:         $loader = new ObjectRouteLoaderForTest();
   95          $loader->loaderMap = array('my_service' => $service);
   96:         $loader->load('my_service:loadRoutes');
   97      }
   98  }
   99  
  100: class ObjectRouteLoaderForTest extends ObjectRouteLoader
  101  {
  102      public $loaderMap = array();
  ...
  108  }
  109  
  110: class RouteService
  111  {
  112      private $collection;
  ...
  117      }
  118  
  119:     public function loadRoutes()
  120      {
  121          return $this->collection;

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Loader/PhpFileLoaderTest.php:
   29      }
   30  
   31:     public function testLoadWithRoute()
   32      {
   33          $loader = new PhpFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
   34:         $routeCollection = $loader->load('validpattern.php');
   35:         $routes = $routeCollection->all();
   36  
   37:         $this->assertCount(1, $routes, 'One route is loaded');
   38:         $this->assertContainsOnly('Symfony\Component\Routing\Route', $routes);
   39  
   40:         foreach ($routes as $route) {
   41:             $this->assertSame('/blog/{slug}', $route->getPath());
   42:             $this->assertSame('MyBlogBundle:Blog:show', $route->getDefault('_controller'));
   43:             $this->assertSame('{locale}.example.com', $route->getHost());
   44:             $this->assertSame('RouteCompiler', $route->getOption('compiler_class'));
   45:             $this->assertEquals(array('GET', 'POST', 'PUT', 'OPTIONS'), $route->getMethods());
   46:             $this->assertEquals(array('https'), $route->getSchemes());
   47          }
   48      }
   ..
   51      {
   52          $loader = new PhpFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
   53:         $routeCollection = $loader->load('validresource.php');
   54:         $routes = $routeCollection->all();
   55  
   56:         $this->assertCount(1, $routes, 'One route is loaded');
   57:         $this->assertContainsOnly('Symfony\Component\Routing\Route', $routes);
   58  
   59:         foreach ($routes as $route) {
   60:             $this->assertSame('/prefix/blog/{slug}', $route->getPath());
   61:             $this->assertSame('MyBlogBundle:Blog:show', $route->getDefault('_controller'));
   62:             $this->assertSame('{locale}.example.com', $route->getHost());
   63:             $this->assertSame('RouteCompiler', $route->getOption('compiler_class'));
   64:             $this->assertEquals(array('GET', 'POST', 'PUT', 'OPTIONS'), $route->getMethods());
   65:             $this->assertEquals(array('https'), $route->getSchemes());
   66          }
   67      }
   ..
   71          $locator = new FileLocator(array(__DIR__.'/../Fixtures'));
   72          $loader = new PhpFileLoader($locator);
   73:         $routeCollection = $loader->load('with_define_path_variable.php');
   74:         $resources = $routeCollection->getResources();
   75          $this->assertCount(1, $resources);
   76          $this->assertContainsOnly('Symfony\Component\Config\Resource\ResourceInterface', $resources);

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Loader/XmlFileLoaderTest.php:
   30      }
   31  
   32:     public function testLoadWithRoute()
   33      {
   34          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
   35:         $routeCollection = $loader->load('validpattern.xml');
   36:         $route = $routeCollection->get('blog_show');
   37  
   38:         $this->assertInstanceOf('Symfony\Component\Routing\Route', $route);
   39:         $this->assertSame('/blog/{slug}', $route->getPath());
   40:         $this->assertSame('{locale}.example.com', $route->getHost());
   41:         $this->assertSame('MyBundle:Blog:show', $route->getDefault('_controller'));
   42:         $this->assertSame('\w+', $route->getRequirement('locale'));
   43:         $this->assertSame('RouteCompiler', $route->getOption('compiler_class'));
   44:         $this->assertEquals(array('GET', 'POST', 'PUT', 'OPTIONS'), $route->getMethods());
   45:         $this->assertEquals(array('https'), $route->getSchemes());
   46:         $this->assertEquals('context.getMethod() == "GET"', $route->getCondition());
   47      }
   48  
   ..
   50      {
   51          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
   52:         $routeCollection = $loader->load('namespaceprefix.xml');
   53  
   54:         $this->assertCount(1, $routeCollection->all(), 'One route is loaded');
   55  
   56:         $route = $routeCollection->get('blog_show');
   57:         $this->assertSame('/blog/{slug}', $route->getPath());
   58:         $this->assertSame('{_locale}.example.com', $route->getHost());
   59:         $this->assertSame('MyBundle:Blog:show', $route->getDefault('_controller'));
   60:         $this->assertSame('\w+', $route->getRequirement('slug'));
   61:         $this->assertSame('en|fr|de', $route->getRequirement('_locale'));
   62:         $this->assertNull($route->getDefault('slug'));
   63:         $this->assertSame('RouteCompiler', $route->getOption('compiler_class'));
   64:         $this->assertSame(1, $route->getDefault('page'));
   65      }
   66  
   ..
   68      {
   69          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
   70:         $routeCollection = $loader->load('validresource.xml');
   71:         $routes = $routeCollection->all();
   72  
   73:         $this->assertCount(2, $routes, 'Two routes are loaded');
   74:         $this->assertContainsOnly('Symfony\Component\Routing\Route', $routes);
   75  
   76:         foreach ($routes as $route) {
   77:             $this->assertSame('/{foo}/blog/{slug}', $route->getPath());
   78:             $this->assertSame('123', $route->getDefault('foo'));
   79:             $this->assertSame('\d+', $route->getRequirement('foo'));
   80:             $this->assertSame('bar', $route->getOption('foo'));
   81:             $this->assertSame('', $route->getHost());
   82:             $this->assertSame('context.getMethod() == "POST"', $route->getCondition());
   83          }
   84      }
   ..
  106      public function getPathsToInvalidFiles()
  107      {
  108:         return array(array('nonvalidnode.xml'), array('nonvalidroute.xml'), array('nonvalid.xml'), array('missing_id.xml'), array('missing_path.xml'));
  109      }
  110  
  ...
  122      {
  123          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
  124:         $routeCollection = $loader->load('null_values.xml');
  125:         $route = $routeCollection->get('blog_show');
  126  
  127:         $this->assertTrue($route->hasDefault('foo'));
  128:         $this->assertNull($route->getDefault('foo'));
  129:         $this->assertTrue($route->hasDefault('bar'));
  130:         $this->assertNull($route->getDefault('bar'));
  131:         $this->assertEquals('foo', $route->getDefault('foobar'));
  132:         $this->assertEquals('bar', $route->getDefault('baz'));
  133      }
  134  
  ...
  136      {
  137          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
  138:         $routeCollection = $loader->load('scalar_defaults.xml');
  139:         $route = $routeCollection->get('blog');
  140  
  141          $this->assertSame(
  ...
  152                  'bar' => null,
  153              ),
  154:             $route->getDefaults()
  155          );
  156      }
  ...
  159      {
  160          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
  161:         $routeCollection = $loader->load('list_defaults.xml');
  162:         $route = $routeCollection->get('blog');
  163  
  164          $this->assertSame(
  ...
  167                  'values' => array(true, 1, 3.5, 'foo'),
  168              ),
  169:             $route->getDefaults()
  170          );
  171      }
  ...
  174      {
  175          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
  176:         $routeCollection = $loader->load('list_in_list_defaults.xml');
  177:         $route = $routeCollection->get('blog');
  178  
  179          $this->assertSame(
  ...
  182                  'values' => array(array(true, 1, 3.5, 'foo')),
  183              ),
  184:             $route->getDefaults()
  185          );
  186      }
  ...
  189      {
  190          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
  191:         $routeCollection = $loader->load('list_in_map_defaults.xml');
  192:         $route = $routeCollection->get('blog');
  193  
  194          $this->assertSame(
  ...
  197                  'values' => array('list' => array(true, 1, 3.5, 'foo')),
  198              ),
  199:             $route->getDefaults()
  200          );
  201      }
  ...
  204      {
  205          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
  206:         $routeCollection = $loader->load('map_defaults.xml');
  207:         $route = $routeCollection->get('blog');
  208  
  209          $this->assertSame(
  ...
  217                  ),
  218              ),
  219:             $route->getDefaults()
  220          );
  221      }
  ...
  224      {
  225          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
  226:         $routeCollection = $loader->load('map_in_list_defaults.xml');
  227:         $route = $routeCollection->get('blog');
  228  
  229          $this->assertSame(
  ...
  237                  )),
  238              ),
  239:             $route->getDefaults()
  240          );
  241      }
  ...
  244      {
  245          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
  246:         $routeCollection = $loader->load('map_in_map_defaults.xml');
  247:         $route = $routeCollection->get('blog');
  248  
  249          $this->assertSame(
  ...
  257                  )),
  258              ),
  259:             $route->getDefaults()
  260          );
  261      }
  ...
  264      {
  265          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
  266:         $routeCollection = $loader->load('list_null_values.xml');
  267:         $route = $routeCollection->get('blog');
  268  
  269:         $this->assertSame(array(null, null, null, null, null, null), $route->getDefault('list'));
  270      }
  271  
  ...
  273      {
  274          $loader = new XmlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
  275:         $routeCollection = $loader->load('map_null_values.xml');
  276:         $route = $routeCollection->get('blog');
  277  
  278          $this->assertSame(
  ...
  285                  'map' => null,
  286              ),
  287:             $route->getDefault('map')
  288          );
  289      }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Loader/YamlFileLoaderTest.php:
   64      }
   65  
   66:     public function testLoadSpecialRouteName()
   67      {
   68          $loader = new YamlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
   69:         $routeCollection = $loader->load('special_route_name.yml');
   70:         $route = $routeCollection->get('#$péß^a|');
   71  
   72:         $this->assertInstanceOf('Symfony\Component\Routing\Route', $route);
   73:         $this->assertSame('/true', $route->getPath());
   74      }
   75  
   76:     public function testLoadWithRoute()
   77      {
   78          $loader = new YamlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
   79:         $routeCollection = $loader->load('validpattern.yml');
   80:         $route = $routeCollection->get('blog_show');
   81  
   82:         $this->assertInstanceOf('Symfony\Component\Routing\Route', $route);
   83:         $this->assertSame('/blog/{slug}', $route->getPath());
   84:         $this->assertSame('{locale}.example.com', $route->getHost());
   85:         $this->assertSame('MyBundle:Blog:show', $route->getDefault('_controller'));
   86:         $this->assertSame('\w+', $route->getRequirement('locale'));
   87:         $this->assertSame('RouteCompiler', $route->getOption('compiler_class'));
   88:         $this->assertEquals(array('GET', 'POST', 'PUT', 'OPTIONS'), $route->getMethods());
   89:         $this->assertEquals(array('https'), $route->getSchemes());
   90:         $this->assertEquals('context.getMethod() == "GET"', $route->getCondition());
   91      }
   92  
   ..
   94      {
   95          $loader = new YamlFileLoader(new FileLocator(array(__DIR__.'/../Fixtures')));
   96:         $routeCollection = $loader->load('validresource.yml');
   97:         $routes = $routeCollection->all();
   98  
   99:         $this->assertCount(2, $routes, 'Two routes are loaded');
  100:         $this->assertContainsOnly('Symfony\Component\Routing\Route', $routes);
  101  
  102:         foreach ($routes as $route) {
  103:             $this->assertSame('/{foo}/blog/{slug}', $route->getPath());
  104:             $this->assertSame('123', $route->getDefault('foo'));
  105:             $this->assertSame('\d+', $route->getRequirement('foo'));
  106:             $this->assertSame('bar', $route->getOption('foo'));
  107:             $this->assertSame('', $route->getHost());
  108:             $this->assertSame('context.getMethod() == "POST"', $route->getCondition());
  109          }
  110      }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Matcher/Dumper/PhpMatcherDumperTest.php:
   14  use PHPUnit\Framework\TestCase;
   15  use Symfony\Component\Routing\Matcher\Dumper\PhpMatcherDumper;
   16: use Symfony\Component\Routing\Route;
   17: use Symfony\Component\Routing\RouteCollection;
   18  
   19  class PhpMatcherDumperTest extends TestCase
   ..
   24      public function testDumpWhenSchemeIsUsedWithoutAProperDumper()
   25      {
   26:         $collection = new RouteCollection();
   27:         $collection->add('secure', new Route(
   28              '/secure',
   29              array(),
   ..
   38  
   39      /**
   40:      * @dataProvider getRouteCollections
   41       */
   42:     public function testDump(RouteCollection $collection, $fixture, $options = array())
   43      {
   44          $basePath = __DIR__.'/../../Fixtures/dumper/';
   45  
   46          $dumper = new PhpMatcherDumper($collection);
   47:         $this->assertStringEqualsFile($basePath.$fixture, $dumper->dump($options), '->dump() correctly dumps routes as optimized PHP code.');
   48      }
   49  
   50:     public function getRouteCollections()
   51      {
   52          /* test case 1 */
   53  
   54:         $collection = new RouteCollection();
   55  
   56:         $collection->add('overridden', new Route('/overridden'));
   57  
   58          // defaults and requirements
   59:         $collection->add('foo', new Route(
   60              '/foo/{bar}',
   61              array('def' => 'test'),
   ..
   63          ));
   64          // method requirement
   65:         $collection->add('bar', new Route(
   66              '/bar/{foo}',
   67              array(),
   ..
   73          ));
   74          // GET method requirement automatically adds HEAD as valid
   75:         $collection->add('barhead', new Route(
   76              '/barhead/{foo}',
   77              array(),
   ..
   83          ));
   84          // simple
   85:         $collection->add('baz', new Route(
   86              '/test/baz'
   87          ));
   88          // simple with extension
   89:         $collection->add('baz2', new Route(
   90              '/test/baz.html'
   91          ));
   92          // trailing slash
   93:         $collection->add('baz3', new Route(
   94              '/test/baz3/'
   95          ));
   96          // trailing slash with variable
   97:         $collection->add('baz4', new Route(
   98              '/test/{foo}/'
   99          ));
  100          // trailing slash and method
  101:         $collection->add('baz5', new Route(
  102              '/test/{foo}/',
  103              array(),
  ...
  109          ));
  110          // complex name
  111:         $collection->add('baz.baz6', new Route(
  112              '/test/{foo}/',
  113              array(),
  ...
  119          ));
  120          // defaults without variable
  121:         $collection->add('foofoo', new Route(
  122              '/foofoo',
  123              array('def' => 'test')
  124          ));
  125          // pattern with quotes
  126:         $collection->add('quoter', new Route(
  127              '/{quoter}',
  128              array(),
  ...
  130          ));
  131          // space in pattern
  132:         $collection->add('space', new Route(
  133              '/spa ce'
  134          ));
  135  
  136          // prefixes
  137:         $collection1 = new RouteCollection();
  138:         $collection1->add('overridden', new Route('/overridden1'));
  139:         $collection1->add('foo1', new Route('/{foo}'));
  140:         $collection1->add('bar1', new Route('/{bar}'));
  141          $collection1->addPrefix('/b\'b');
  142:         $collection2 = new RouteCollection();
  143          $collection2->addCollection($collection1);
  144:         $collection2->add('overridden', new Route('/{var}', array(), array('var' => '.*')));
  145:         $collection1 = new RouteCollection();
  146:         $collection1->add('foo2', new Route('/{foo1}'));
  147:         $collection1->add('bar2', new Route('/{bar1}'));
  148          $collection1->addPrefix('/b\'b');
  149          $collection2->addCollection($collection1);
  ...
  152  
  153          // overridden through addCollection() and multiple sub-collections with no own prefix
  154:         $collection1 = new RouteCollection();
  155:         $collection1->add('overridden2', new Route('/old'));
  156:         $collection1->add('helloWorld', new Route('/hello/{who}', array('who' => 'World!')));
  157:         $collection2 = new RouteCollection();
  158:         $collection3 = new RouteCollection();
  159:         $collection3->add('overridden2', new Route('/new'));
  160:         $collection3->add('hey', new Route('/hey/'));
  161          $collection2->addCollection($collection3);
  162          $collection1->addCollection($collection2);
  ...
  165  
  166          // "dynamic" prefix
  167:         $collection1 = new RouteCollection();
  168:         $collection1->add('foo3', new Route('/{foo}'));
  169:         $collection1->add('bar3', new Route('/{bar}'));
  170          $collection1->addPrefix('/b');
  171          $collection1->addPrefix('{_locale}');
  172          $collection->addCollection($collection1);
  173  
  174:         // route between collections
  175:         $collection->add('ababa', new Route('/ababa'));
  176  
  177:         // collection with static prefix but only one route
  178:         $collection1 = new RouteCollection();
  179:         $collection1->add('foo4', new Route('/{foo}'));
  180          $collection1->addPrefix('/aba');
  181          $collection->addCollection($collection1);
  ...
  183          // prefix and host
  184  
  185:         $collection1 = new RouteCollection();
  186  
  187:         $route1 = new Route('/route1', array(), array(), array(), 'a.example.com');
  188:         $collection1->add('route1', $route1);
  189  
  190:         $route2 = new Route('/c2/route2', array(), array(), array(), 'a.example.com');
  191:         $collection1->add('route2', $route2);
  192  
  193:         $route3 = new Route('/c2/route3', array(), array(), array(), 'b.example.com');
  194:         $collection1->add('route3', $route3);
  195  
  196:         $route4 = new Route('/route4', array(), array(), array(), 'a.example.com');
  197:         $collection1->add('route4', $route4);
  198  
  199:         $route5 = new Route('/route5', array(), array(), array(), 'c.example.com');
  200:         $collection1->add('route5', $route5);
  201  
  202:         $route6 = new Route('/route6', array(), array(), array(), null);
  203:         $collection1->add('route6', $route6);
  204  
  205          $collection->addCollection($collection1);
  ...
  207          // host and variables
  208  
  209:         $collection1 = new RouteCollection();
  210  
  211:         $route11 = new Route('/route11', array(), array(), array(), '{var1}.example.com');
  212:         $collection1->add('route11', $route11);
  213  
  214:         $route12 = new Route('/route12', array('var1' => 'val'), array(), array(), '{var1}.example.com');
  215:         $collection1->add('route12', $route12);
  216  
  217:         $route13 = new Route('/route13/{name}', array(), array(), array(), '{var1}.example.com');
  218:         $collection1->add('route13', $route13);
  219  
  220:         $route14 = new Route('/route14/{name}', array('var1' => 'val'), array(), array(), '{var1}.example.com');
  221:         $collection1->add('route14', $route14);
  222  
  223:         $route15 = new Route('/route15/{name}', array(), array(), array(), 'c.example.com');
  224:         $collection1->add('route15', $route15);
  225  
  226:         $route16 = new Route('/route16/{name}', array('var1' => 'val'), array(), array(), null);
  227:         $collection1->add('route16', $route16);
  228  
  229:         $route17 = new Route('/route17', array(), array(), array(), null);
  230:         $collection1->add('route17', $route17);
  231  
  232          $collection->addCollection($collection1);
  233  
  234:         // multiple sub-collections with a single route and a prefix each
  235:         $collection1 = new RouteCollection();
  236:         $collection1->add('a', new Route('/a...'));
  237:         $collection2 = new RouteCollection();
  238:         $collection2->add('b', new Route('/{var}'));
  239:         $collection3 = new RouteCollection();
  240:         $collection3->add('c', new Route('/{var}'));
  241          $collection3->addPrefix('/c');
  242          $collection2->addCollection($collection3);
  ...
  251  
  252          // force HTTPS redirection
  253:         $redirectCollection->add('secure', new Route(
  254              '/secure',
  255              array(),
  ...
  261  
  262          // force HTTP redirection
  263:         $redirectCollection->add('nonsecure', new Route(
  264              '/nonsecure',
  265              array(),
  ...
  272          /* test case 3 */
  273  
  274:         $rootprefixCollection = new RouteCollection();
  275:         $rootprefixCollection->add('static', new Route('/test'));
  276:         $rootprefixCollection->add('dynamic', new Route('/{var}'));
  277          $rootprefixCollection->addPrefix('rootprefix');
  278:         $route = new Route('/with-condition');
  279:         $route->setCondition('context.getMethod() == "GET"');
  280:         $rootprefixCollection->add('with-condition', $route);
  281  
  282          /* test case 4 */
  283:         $headMatchCasesCollection = new RouteCollection();
  284:         $headMatchCasesCollection->add('just_head', new Route(
  285              '/just_head',
  286              array(),
  ...
  291              array('HEAD')
  292          ));
  293:         $headMatchCasesCollection->add('head_and_get', new Route(
  294              '/head_and_get',
  295              array(),
  ...
  300              array('GET', 'HEAD')
  301          ));
  302:         $headMatchCasesCollection->add('post_and_head', new Route(
  303              '/post_and_get',
  304              array(),
  ...
  309              array('POST', 'HEAD')
  310          ));
  311:         $headMatchCasesCollection->add('put_and_post', new Route(
  312              '/put_and_post',
  313              array(),
  ...
  318              array('PUT', 'POST')
  319          ));
  320:         $headMatchCasesCollection->add('put_and_get_and_head', new Route(
  321              '/put_and_post',
  322              array(),
  ...
  329  
  330          /* test case 5 */
  331:         $groupOptimisedCollection = new RouteCollection();
  332:         $groupOptimisedCollection->add('a_first', new Route('/a/11'));
  333:         $groupOptimisedCollection->add('a_second', new Route('/a/22'));
  334:         $groupOptimisedCollection->add('a_third', new Route('/a/333'));
  335:         $groupOptimisedCollection->add('a_wildcard', new Route('/{param}'));
  336:         $groupOptimisedCollection->add('a_fourth', new Route('/a/44/'));
  337:         $groupOptimisedCollection->add('a_fifth', new Route('/a/55/'));
  338:         $groupOptimisedCollection->add('a_sixth', new Route('/a/66/'));
  339:         $groupOptimisedCollection->add('nested_wildcard', new Route('/nested/{param}'));
  340:         $groupOptimisedCollection->add('nested_a', new Route('/nested/group/a/'));
  341:         $groupOptimisedCollection->add('nested_b', new Route('/nested/group/b/'));
  342:         $groupOptimisedCollection->add('nested_c', new Route('/nested/group/c/'));
  343  
  344:         $groupOptimisedCollection->add('slashed_a', new Route('/slashed/group/'));
  345:         $groupOptimisedCollection->add('slashed_b', new Route('/slashed/group/b/'));
  346:         $groupOptimisedCollection->add('slashed_c', new Route('/slashed/group/c/'));
  347  
  348:         $trailingSlashCollection = new RouteCollection();
  349:         $trailingSlashCollection->add('simple_trailing_slash_no_methods', new Route('/trailing/simple/no-methods/', array(), array(), array(), '', array(), array()));
  350:         $trailingSlashCollection->add('simple_trailing_slash_GET_method', new Route('/trailing/simple/get-method/', array(), array(), array(), '', array(), array('GET')));
  351:         $trailingSlashCollection->add('simple_trailing_slash_HEAD_method', new Route('/trailing/simple/head-method/', array(), array(), array(), '', array(), array('HEAD')));
  352:         $trailingSlashCollection->add('simple_trailing_slash_POST_method', new Route('/trailing/simple/post-method/', array(), array(), array(), '', array(), array('POST')));
  353:         $trailingSlashCollection->add('regex_trailing_slash_no_methods', new Route('/trailing/regex/no-methods/{param}/', array(), array(), array(), '', array(), array()));
  354:         $trailingSlashCollection->add('regex_trailing_slash_GET_method', new Route('/trailing/regex/get-method/{param}/', array(), array(), array(), '', array(), array('GET')));
  355:         $trailingSlashCollection->add('regex_trailing_slash_HEAD_method', new Route('/trailing/regex/head-method/{param}/', array(), array(), array(), '', array(), array('HEAD')));
  356:         $trailingSlashCollection->add('regex_trailing_slash_POST_method', new Route('/trailing/regex/post-method/{param}/', array(), array(), array(), '', array(), array('POST')));
  357  
  358:         $trailingSlashCollection->add('simple_not_trailing_slash_no_methods', new Route('/not-trailing/simple/no-methods', array(), array(), array(), '', array(), array()));
  359:         $trailingSlashCollection->add('simple_not_trailing_slash_GET_method', new Route('/not-trailing/simple/get-method', array(), array(), array(), '', array(), array('GET')));
  360:         $trailingSlashCollection->add('simple_not_trailing_slash_HEAD_method', new Route('/not-trailing/simple/head-method', array(), array(), array(), '', array(), array('HEAD')));
  361:         $trailingSlashCollection->add('simple_not_trailing_slash_POST_method', new Route('/not-trailing/simple/post-method', array(), array(), array(), '', array(), array('POST')));
  362:         $trailingSlashCollection->add('regex_not_trailing_slash_no_methods', new Route('/not-trailing/regex/no-methods/{param}', array(), array(), array(), '', array(), array()));
  363:         $trailingSlashCollection->add('regex_not_trailing_slash_GET_method', new Route('/not-trailing/regex/get-method/{param}', array(), array(), array(), '', array(), array('GET')));
  364:         $trailingSlashCollection->add('regex_not_trailing_slash_HEAD_method', new Route('/not-trailing/regex/head-method/{param}', array(), array(), array(), '', array(), array('HEAD')));
  365:         $trailingSlashCollection->add('regex_not_trailing_slash_POST_method', new Route('/not-trailing/regex/post-method/{param}', array(), array(), array(), '', array(), array('POST')));
  366  
  367          return array(

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Matcher/Dumper/StaticPrefixCollectionTest.php:
    5  use PHPUnit\Framework\TestCase;
    6  use Symfony\Component\Routing\Matcher\Dumper\StaticPrefixCollection;
    7: use Symfony\Component\Routing\Route;
    8  
    9  class StaticPrefixCollectionTest extends TestCase
   10  {
   11      /**
   12:      * @dataProvider routeProvider
   13       */
   14:     public function testGrouping(array $routes, $expected)
   15      {
   16          $collection = new StaticPrefixCollection('/');
   17  
   18:         foreach ($routes as $route) {
   19:             list($path, $name) = $route;
   20:             $staticPrefix = (new Route($path))->compile()->getStaticPrefix();
   21:             $collection->addRoute($staticPrefix, $name);
   22          }
   23  
   ..
   27      }
   28  
   29:     public function routeProvider()
   30      {
   31          return array(

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Matcher/RedirectableUrlMatcherTest.php:
   13  
   14  use PHPUnit\Framework\TestCase;
   15: use Symfony\Component\Routing\Route;
   16: use Symfony\Component\Routing\RouteCollection;
   17  use Symfony\Component\Routing\RequestContext;
   18  
   ..
   21      public function testRedirectWhenNoSlash()
   22      {
   23:         $coll = new RouteCollection();
   24:         $coll->add('foo', new Route('/foo/'));
   25  
   26          $matcher = $this->getMockForAbstractClass('Symfony\Component\Routing\Matcher\RedirectableUrlMatcher', array($coll, new RequestContext()));
   ..
   34      public function testRedirectWhenNoSlashForNonSafeMethod()
   35      {
   36:         $coll = new RouteCollection();
   37:         $coll->add('foo', new Route('/foo/'));
   38  
   39          $context = new RequestContext();
   ..
   45      public function testSchemeRedirectRedirectsToFirstScheme()
   46      {
   47:         $coll = new RouteCollection();
   48:         $coll->add('foo', new Route('/foo', array(), array(), array(), '', array('FTP', 'HTTPS')));
   49  
   50          $matcher = $this->getMockForAbstractClass('Symfony\Component\Routing\Matcher\RedirectableUrlMatcher', array($coll, new RequestContext()));
   ..
   53              ->method('redirect')
   54              ->with('/foo', 'foo', 'ftp')
   55:             ->will($this->returnValue(array('_route' => 'foo')))
   56          ;
   57          $matcher->match('/foo');
   ..
   60      public function testNoSchemaRedirectIfOnOfMultipleSchemesMatches()
   61      {
   62:         $coll = new RouteCollection();
   63:         $coll->add('foo', new Route('/foo', array(), array(), array(), '', array('https', 'http')));
   64  
   65          $matcher = $this->getMockForAbstractClass('Symfony\Component\Routing\Matcher\RedirectableUrlMatcher', array($coll, new RequestContext()));

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Matcher/TraceableUrlMatcherTest.php:
   14  use PHPUnit\Framework\TestCase;
   15  use Symfony\Component\HttpFoundation\Request;
   16: use Symfony\Component\Routing\Route;
   17: use Symfony\Component\Routing\RouteCollection;
   18  use Symfony\Component\Routing\RequestContext;
   19  use Symfony\Component\Routing\Matcher\TraceableUrlMatcher;
   ..
   23      public function test()
   24      {
   25:         $coll = new RouteCollection();
   26:         $coll->add('foo', new Route('/foo', array(), array(), array(), '', array(), array('POST')));
   27:         $coll->add('bar', new Route('/bar/{id}', array(), array('id' => '\d+')));
   28:         $coll->add('bar1', new Route('/bar/{name}', array(), array('id' => '\w+'), array(), '', array(), array('POST')));
   29:         $coll->add('bar2', new Route('/foo', array(), array(), array(), 'baz'));
   30:         $coll->add('bar3', new Route('/foo1', array(), array(), array(), 'baz'));
   31:         $coll->add('bar4', new Route('/foo2', array(), array(), array(), 'baz', array(), array(), 'context.getMethod() == "GET"'));
   32  
   33          $context = new RequestContext();
   ..
   61      }
   62  
   63:     public function testMatchRouteOnMultipleHosts()
   64      {
   65:         $routes = new RouteCollection();
   66:         $routes->add('first', new Route(
   67              '/mypath/',
   68              array('_controller' => 'MainBundle:Info:first'),
   ..
   72          ));
   73  
   74:         $routes->add('second', new Route(
   75              '/mypath/',
   76              array('_controller' => 'MainBundle:Info:second'),
   ..
   83          $context->setHost('baz');
   84  
   85:         $matcher = new TraceableUrlMatcher($routes, $context);
   86  
   87          $traces = $matcher->getTraces('/mypath/');
   88          $this->assertSame(
   89:             array(TraceableUrlMatcher::ROUTE_ALMOST_MATCHES, TraceableUrlMatcher::ROUTE_ALMOST_MATCHES),
   90              $this->getLevels($traces)
   91          );
   ..
  102      }
  103  
  104:     public function testRoutesWithConditions()
  105      {
  106:         $routes = new RouteCollection();
  107:         $routes->add('foo', new Route('/foo', array(), array(), array(), 'baz', array(), array(), "request.headers.get('User-Agent') matches '/firefox/i'"));
  108  
  109          $context = new RequestContext();
  110          $context->setHost('baz');
  111  
  112:         $matcher = new TraceableUrlMatcher($routes, $context);
  113  
  114          $notMatchingRequest = Request::create('/foo', 'GET');
  ...
  118          $matchingRequest = Request::create('/foo', 'GET', array(), array(), array(), array('HTTP_USER_AGENT' => 'Firefox'));
  119          $traces = $matcher->getTracesForRequest($matchingRequest);
  120:         $this->assertEquals('Route matches!', $traces[0]['log']);
  121      }
  122  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/Matcher/UrlMatcherTest.php:
   16  use Symfony\Component\Routing\Exception\ResourceNotFoundException;
   17  use Symfony\Component\Routing\Matcher\UrlMatcher;
   18: use Symfony\Component\Routing\Route;
   19: use Symfony\Component\Routing\RouteCollection;
   20  use Symfony\Component\Routing\RequestContext;
   21  
   ..
   24      public function testNoMethodSoAllowed()
   25      {
   26:         $coll = new RouteCollection();
   27:         $coll->add('foo', new Route('/foo'));
   28  
   29          $matcher = new UrlMatcher($coll, new RequestContext());
   ..
   33      public function testMethodNotAllowed()
   34      {
   35:         $coll = new RouteCollection();
   36:         $coll->add('foo', new Route('/foo', array(), array(), array(), '', array(), array('post')));
   37  
   38          $matcher = new UrlMatcher($coll, new RequestContext());
   ..
   48      public function testHeadAllowedWhenRequirementContainsGet()
   49      {
   50:         $coll = new RouteCollection();
   51:         $coll->add('foo', new Route('/foo', array(), array(), array(), '', array(), array('get')));
   52  
   53          $matcher = new UrlMatcher($coll, new RequestContext('', 'head'));
   ..
   57      public function testMethodNotAllowedAggregatesAllowedMethods()
   58      {
   59:         $coll = new RouteCollection();
   60:         $coll->add('foo1', new Route('/foo', array(), array(), array(), '', array(), array('post')));
   61:         $coll->add('foo2', new Route('/foo', array(), array(), array(), '', array(), array('put', 'delete')));
   62  
   63          $matcher = new UrlMatcher($coll, new RequestContext());
   ..
   74      {
   75          // test the patterns are matched and parameters are returned
   76:         $collection = new RouteCollection();
   77:         $collection->add('foo', new Route('/foo/{bar}'));
   78          $matcher = new UrlMatcher($collection, new RequestContext());
   79          try {
   ..
   82          } catch (ResourceNotFoundException $e) {
   83          }
   84:         $this->assertEquals(array('_route' => 'foo', 'bar' => 'baz'), $matcher->match('/foo/baz'));
   85  
   86          // test that defaults are merged
   87:         $collection = new RouteCollection();
   88:         $collection->add('foo', new Route('/foo/{bar}', array('def' => 'test')));
   89          $matcher = new UrlMatcher($collection, new RequestContext());
   90:         $this->assertEquals(array('_route' => 'foo', 'bar' => 'baz', 'def' => 'test'), $matcher->match('/foo/baz'));
   91  
   92:         // test that route "method" is ignored if no method is given in the context
   93:         $collection = new RouteCollection();
   94:         $collection->add('foo', new Route('/foo', array(), array(), array(), '', array(), array('get', 'head')));
   95          $matcher = new UrlMatcher($collection, new RequestContext());
   96          $this->assertInternalType('array', $matcher->match('/foo'));
   97  
   98:         // route does not match with POST method context
   99          $matcher = new UrlMatcher($collection, new RequestContext('', 'post'));
  100          try {
  ...
  104          }
  105  
  106:         // route does match with GET or HEAD method context
  107          $matcher = new UrlMatcher($collection, new RequestContext());
  108          $this->assertInternalType('array', $matcher->match('/foo'));
  ...
  110          $this->assertInternalType('array', $matcher->match('/foo'));
  111  
  112:         // route with an optional variable as the first segment
  113:         $collection = new RouteCollection();
  114:         $collection->add('bar', new Route('/{bar}/foo', array('bar' => 'bar'), array('bar' => 'foo|bar')));
  115          $matcher = new UrlMatcher($collection, new RequestContext());
  116:         $this->assertEquals(array('_route' => 'bar', 'bar' => 'bar'), $matcher->match('/bar/foo'));
  117:         $this->assertEquals(array('_route' => 'bar', 'bar' => 'foo'), $matcher->match('/foo/foo'));
  118  
  119:         $collection = new RouteCollection();
  120:         $collection->add('bar', new Route('/{bar}', array('bar' => 'bar'), array('bar' => 'foo|bar')));
  121          $matcher = new UrlMatcher($collection, new RequestContext());
  122:         $this->assertEquals(array('_route' => 'bar', 'bar' => 'foo'), $matcher->match('/foo'));
  123:         $this->assertEquals(array('_route' => 'bar', 'bar' => 'bar'), $matcher->match('/'));
  124  
  125:         // route with only optional variables
  126:         $collection = new RouteCollection();
  127:         $collection->add('bar', new Route('/{foo}/{bar}', array('foo' => 'foo', 'bar' => 'bar'), array()));
  128          $matcher = new UrlMatcher($collection, new RequestContext());
  129:         $this->assertEquals(array('_route' => 'bar', 'foo' => 'foo', 'bar' => 'bar'), $matcher->match('/'));
  130:         $this->assertEquals(array('_route' => 'bar', 'foo' => 'a', 'bar' => 'bar'), $matcher->match('/a'));
  131:         $this->assertEquals(array('_route' => 'bar', 'foo' => 'a', 'bar' => 'b'), $matcher->match('/a/b'));
  132      }
  133  
  134      public function testMatchWithPrefixes()
  135      {
  136:         $collection = new RouteCollection();
  137:         $collection->add('foo', new Route('/{foo}'));
  138          $collection->addPrefix('/b');
  139          $collection->addPrefix('/a');
  140  
  141          $matcher = new UrlMatcher($collection, new RequestContext());
  142:         $this->assertEquals(array('_route' => 'foo', 'foo' => 'foo'), $matcher->match('/a/b/foo'));
  143      }
  144  
  145      public function testMatchWithDynamicPrefix()
  146      {
  147:         $collection = new RouteCollection();
  148:         $collection->add('foo', new Route('/{foo}'));
  149          $collection->addPrefix('/b');
  150          $collection->addPrefix('/{_locale}');
  151  
  152          $matcher = new UrlMatcher($collection, new RequestContext());
  153:         $this->assertEquals(array('_locale' => 'fr', '_route' => 'foo', 'foo' => 'foo'), $matcher->match('/fr/b/foo'));
  154      }
  155  
  156:     public function testMatchSpecialRouteName()
  157      {
  158:         $collection = new RouteCollection();
  159:         $collection->add('$péß^a|', new Route('/bar'));
  160  
  161          $matcher = new UrlMatcher($collection, new RequestContext());
  162:         $this->assertEquals(array('_route' => '$péß^a|'), $matcher->match('/bar'));
  163      }
  164  
  165      public function testMatchNonAlpha()
  166      {
  167:         $collection = new RouteCollection();
  168          $chars = '!"$%éà &\'()*+,./:;<=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\[]^_`abcdefghijklmnopqrstuvwxyz{|}~-';
  169:         $collection->add('foo', new Route('/{foo}/bar', array(), array('foo' => '['.preg_quote($chars).']+'), array('utf8' => true)));
  170  
  171          $matcher = new UrlMatcher($collection, new RequestContext());
  172:         $this->assertEquals(array('_route' => 'foo', 'foo' => $chars), $matcher->match('/'.rawurlencode($chars).'/bar'));
  173:         $this->assertEquals(array('_route' => 'foo', 'foo' => $chars), $matcher->match('/'.strtr($chars, array('%' => '%25')).'/bar'));
  174      }
  175  
  176      public function testMatchWithDotMetacharacterInRequirements()
  177      {
  178:         $collection = new RouteCollection();
  179:         $collection->add('foo', new Route('/{foo}/bar', array(), array('foo' => '.+')));
  180  
  181          $matcher = new UrlMatcher($collection, new RequestContext());
  182:         $this->assertEquals(array('_route' => 'foo', 'foo' => "\n"), $matcher->match('/'.urlencode("\n").'/bar'), 'linefeed character is matched');
  183      }
  184  
  185:     public function testMatchOverriddenRoute()
  186      {
  187:         $collection = new RouteCollection();
  188:         $collection->add('foo', new Route('/foo'));
  189  
  190:         $collection1 = new RouteCollection();
  191:         $collection1->add('foo', new Route('/foo1'));
  192  
  193          $collection->addCollection($collection1);
  ...
  195          $matcher = new UrlMatcher($collection, new RequestContext());
  196  
  197:         $this->assertEquals(array('_route' => 'foo'), $matcher->match('/foo1'));
  198          $this->{method_exists($this, $_ = 'expectException') ? $_ : 'setExpectedException'}('Symfony\Component\Routing\Exception\ResourceNotFoundException');
  199          $this->assertEquals(array(), $matcher->match('/foo'));
  ...
  202      public function testMatchRegression()
  203      {
  204:         $coll = new RouteCollection();
  205:         $coll->add('foo', new Route('/foo/{foo}'));
  206:         $coll->add('bar', new Route('/foo/bar/{foo}'));
  207  
  208          $matcher = new UrlMatcher($coll, new RequestContext());
  209:         $this->assertEquals(array('foo' => 'bar', '_route' => 'bar'), $matcher->match('/foo/bar/bar'));
  210  
  211:         $collection = new RouteCollection();
  212:         $collection->add('foo', new Route('/{bar}'));
  213          $matcher = new UrlMatcher($collection, new RequestContext());
  214          try {
  ...
  221      public function testDefaultRequirementForOptionalVariables()
  222      {
  223:         $coll = new RouteCollection();
  224:         $coll->add('test', new Route('/{page}.{_format}', array('page' => 'index', '_format' => 'html')));
  225  
  226          $matcher = new UrlMatcher($coll, new RequestContext());
  227:         $this->assertEquals(array('page' => 'my-page', '_format' => 'xml', '_route' => 'test'), $matcher->match('/my-page.xml'));
  228      }
  229  
  230      public function testMatchingIsEager()
  231      {
  232:         $coll = new RouteCollection();
  233:         $coll->add('test', new Route('/{foo}-{bar}-', array(), array('foo' => '.+', 'bar' => '.+')));
  234  
  235          $matcher = new UrlMatcher($coll, new RequestContext());
  236:         $this->assertEquals(array('foo' => 'text1-text2-text3', 'bar' => 'text4', '_route' => 'test'), $matcher->match('/text1-text2-text3-text4-'));
  237      }
  238  
  239      public function testAdjacentVariables()
  240      {
  241:         $coll = new RouteCollection();
  242:         $coll->add('test', new Route('/{w}{x}{y}{z}.{_format}', array('z' => 'default-z', '_format' => 'html'), array('y' => 'y|Y')));
  243  
  244          $matcher = new UrlMatcher($coll, new RequestContext());
  ...
  246          // This also shows that the variables w-z must all exclude the separating char (the dot '.' in this case) by default requirement.
  247          // Otherwise they would also consume '.xml' and _format would never match as it's an optional variable.
  248:         $this->assertEquals(array('w' => 'wwwww', 'x' => 'x', 'y' => 'Y', 'z' => 'Z', '_format' => 'xml', '_route' => 'test'), $matcher->match('/wwwwwxYZ.xml'));
  249          // As 'y' has custom requirement and can only be of value 'y|Y', it will leave  'ZZZ' to variable z.
  250          // So with carefully chosen requirements adjacent variables, can be useful.
  251:         $this->assertEquals(array('w' => 'wwwww', 'x' => 'x', 'y' => 'y', 'z' => 'ZZZ', '_format' => 'html', '_route' => 'test'), $matcher->match('/wwwwwxyZZZ'));
  252          // z and _format are optional.
  253:         $this->assertEquals(array('w' => 'wwwww', 'x' => 'x', 'y' => 'y', 'z' => 'default-z', '_format' => 'html', '_route' => 'test'), $matcher->match('/wwwwwxy'));
  254  
  255          $this->{method_exists($this, $_ = 'expectException') ? $_ : 'setExpectedException'}('Symfony\Component\Routing\Exception\ResourceNotFoundException');
  ...
  259      public function testOptionalVariableWithNoRealSeparator()
  260      {
  261:         $coll = new RouteCollection();
  262:         $coll->add('test', new Route('/get{what}', array('what' => 'All')));
  263          $matcher = new UrlMatcher($coll, new RequestContext());
  264  
  265:         $this->assertEquals(array('what' => 'All', '_route' => 'test'), $matcher->match('/get'));
  266:         $this->assertEquals(array('what' => 'Sites', '_route' => 'test'), $matcher->match('/getSites'));
  267  
  268          // Usually the character in front of an optional parameter can be left out, e.g. with pattern '/get/{what}' just '/get' would match.
  ...
  274      public function testRequiredVariableWithNoRealSeparator()
  275      {
  276:         $coll = new RouteCollection();
  277:         $coll->add('test', new Route('/get{what}Suffix'));
  278          $matcher = new UrlMatcher($coll, new RequestContext());
  279  
  280:         $this->assertEquals(array('what' => 'Sites', '_route' => 'test'), $matcher->match('/getSitesSuffix'));
  281      }
  282  
  283      public function testDefaultRequirementOfVariable()
  284      {
  285:         $coll = new RouteCollection();
  286:         $coll->add('test', new Route('/{page}.{_format}'));
  287          $matcher = new UrlMatcher($coll, new RequestContext());
  288  
  289:         $this->assertEquals(array('page' => 'index', '_format' => 'mobile.html', '_route' => 'test'), $matcher->match('/index.mobile.html'));
  290      }
  291  
  ...
  295      public function testDefaultRequirementOfVariableDisallowsSlash()
  296      {
  297:         $coll = new RouteCollection();
  298:         $coll->add('test', new Route('/{page}.{_format}'));
  299          $matcher = new UrlMatcher($coll, new RequestContext());
  300  
  ...
  307      public function testDefaultRequirementOfVariableDisallowsNextSeparator()
  308      {
  309:         $coll = new RouteCollection();
  310:         $coll->add('test', new Route('/{page}.{_format}', array(), array('_format' => 'html|xml')));
  311          $matcher = new UrlMatcher($coll, new RequestContext());
  312  
  ...
  319      public function testSchemeRequirement()
  320      {
  321:         $coll = new RouteCollection();
  322:         $coll->add('foo', new Route('/foo', array(), array(), array(), '', array('https')));
  323          $matcher = new UrlMatcher($coll, new RequestContext());
  324          $matcher->match('/foo');
  ...
  330      public function testCondition()
  331      {
  332:         $coll = new RouteCollection();
  333:         $route = new Route('/foo');
  334:         $route->setCondition('context.getMethod() == "POST"');
  335:         $coll->add('foo', $route);
  336          $matcher = new UrlMatcher($coll, new RequestContext());
  337          $matcher->match('/foo');
  ...
  340      public function testRequestCondition()
  341      {
  342:         $coll = new RouteCollection();
  343:         $route = new Route('/foo/{bar}');
  344:         $route->setCondition('request.getBaseUrl() == "/sub/front.php" and request.getPathInfo() == "/foo/bar"');
  345:         $coll->add('foo', $route);
  346          $matcher = new UrlMatcher($coll, new RequestContext('/sub/front.php'));
  347:         $this->assertEquals(array('bar' => 'bar', '_route' => 'foo'), $matcher->match('/foo/bar'));
  348      }
  349  
  350      public function testDecodeOnce()
  351      {
  352:         $coll = new RouteCollection();
  353:         $coll->add('foo', new Route('/foo/{foo}'));
  354  
  355          $matcher = new UrlMatcher($coll, new RequestContext());
  356:         $this->assertEquals(array('foo' => 'bar%23', '_route' => 'foo'), $matcher->match('/foo/bar%2523'));
  357      }
  358  
  359      public function testCannotRelyOnPrefix()
  360      {
  361:         $coll = new RouteCollection();
  362  
  363:         $subColl = new RouteCollection();
  364:         $subColl->add('bar', new Route('/bar'));
  365          $subColl->addPrefix('/prefix');
  366:         // overwrite the pattern, so the prefix is not valid anymore for this route in the collection
  367          $subColl->get('bar')->setPath('/new');
  368  
  ...
  370  
  371          $matcher = new UrlMatcher($coll, new RequestContext());
  372:         $this->assertEquals(array('_route' => 'bar'), $matcher->match('/new'));
  373      }
  374  
  375      public function testWithHost()
  376      {
  377:         $coll = new RouteCollection();
  378:         $coll->add('foo', new Route('/foo/{foo}', array(), array(), array(), '{locale}.example.com'));
  379  
  380          $matcher = new UrlMatcher($coll, new RequestContext('', 'GET', 'en.example.com'));
  381:         $this->assertEquals(array('foo' => 'bar', '_route' => 'foo', 'locale' => 'en'), $matcher->match('/foo/bar'));
  382      }
  383  
  384:     public function testWithHostOnRouteCollection()
  385      {
  386:         $coll = new RouteCollection();
  387:         $coll->add('foo', new Route('/foo/{foo}'));
  388:         $coll->add('bar', new Route('/bar/{foo}', array(), array(), array(), '{locale}.example.net'));
  389          $coll->setHost('{locale}.example.com');
  390  
  391          $matcher = new UrlMatcher($coll, new RequestContext('', 'GET', 'en.example.com'));
  392:         $this->assertEquals(array('foo' => 'bar', '_route' => 'foo', 'locale' => 'en'), $matcher->match('/foo/bar'));
  393  
  394          $matcher = new UrlMatcher($coll, new RequestContext('', 'GET', 'en.example.com'));
  395:         $this->assertEquals(array('foo' => 'bar', '_route' => 'bar', 'locale' => 'en'), $matcher->match('/bar/bar'));
  396      }
  397  
  ...
  401      public function testWithOutHostHostDoesNotMatch()
  402      {
  403:         $coll = new RouteCollection();
  404:         $coll->add('foo', new Route('/foo/{foo}', array(), array(), array(), '{locale}.example.com'));
  405  
  406          $matcher = new UrlMatcher($coll, new RequestContext('', 'GET', 'example.com'));
  ...
  413      public function testPathIsCaseSensitive()
  414      {
  415:         $coll = new RouteCollection();
  416:         $coll->add('foo', new Route('/locale', array(), array('locale' => 'EN|FR|DE')));
  417  
  418          $matcher = new UrlMatcher($coll, new RequestContext());
  ...
  422      public function testHostIsCaseInsensitive()
  423      {
  424:         $coll = new RouteCollection();
  425:         $coll->add('foo', new Route('/', array(), array('locale' => 'EN|FR|DE'), array(), '{locale}.example.com'));
  426  
  427          $matcher = new UrlMatcher($coll, new RequestContext('', 'GET', 'en.example.com'));
  428:         $this->assertEquals(array('_route' => 'foo', 'locale' => 'en'), $matcher->match('/'));
  429      }
  430  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/RouteCollectionBuilderTest.php:
   14  use PHPUnit\Framework\TestCase;
   15  use Symfony\Component\Config\Resource\FileResource;
   16: use Symfony\Component\Routing\Route;
   17: use Symfony\Component\Routing\RouteCollection;
   18: use Symfony\Component\Routing\RouteCollectionBuilder;
   19  
   20: class RouteCollectionBuilderTest extends TestCase
   21  {
   22      public function testImport()
   ..
   29              ->will($this->returnValue($resolvedLoader));
   30  
   31:         $originalRoute = new Route('/foo/path');
   32:         $expectedCollection = new RouteCollection();
   33:         $expectedCollection->add('one_test_route', $originalRoute);
   34          $expectedCollection->addResource(new FileResource(__DIR__.'/Fixtures/file_resource.yml'));
   35  
   ..
   46  
   47          // import the file!
   48:         $routes = new RouteCollectionBuilder($loader);
   49:         $importedRoutes = $routes->import('admin_routing.yml', '/', 'yaml');
   50  
   51:         // we should get back a RouteCollectionBuilder
   52:         $this->assertInstanceOf('Symfony\Component\Routing\RouteCollectionBuilder', $importedRoutes);
   53  
   54          // get the collection back so we can look at it
   55:         $addedCollection = $importedRoutes->build();
   56:         $route = $addedCollection->get('one_test_route');
   57:         $this->assertSame($originalRoute, $route);
   58          // should return file_resource.yml, which is in the original collection
   59          $this->assertCount(1, $addedCollection->getResources());
   60  
   61:         // make sure the routes were imported into the top-level builder
   62:         $this->assertCount(1, $routes->build());
   63      }
   64  
   ..
   68      public function testImportWithoutLoaderThrowsException()
   69      {
   70:         $collectionBuilder = new RouteCollectionBuilder();
   71          $collectionBuilder->import('routing.yml');
   72      }
   ..
   74      public function testAdd()
   75      {
   76:         $collectionBuilder = new RouteCollectionBuilder();
   77  
   78:         $addedRoute = $collectionBuilder->add('/checkout', 'AppBundle:Order:checkout');
   79:         $addedRoute2 = $collectionBuilder->add('/blogs', 'AppBundle:Blog:list', 'blog_list');
   80:         $this->assertInstanceOf('Symfony\Component\Routing\Route', $addedRoute);
   81:         $this->assertEquals('AppBundle:Order:checkout', $addedRoute->getDefault('_controller'));
   82  
   83          $finalCollection = $collectionBuilder->build();
   84:         $this->assertSame($addedRoute2, $finalCollection->get('blog_list'));
   85      }
   86  
   87      public function testFlushOrdering()
   88      {
   89:         $importedCollection = new RouteCollection();
   90:         $importedCollection->add('imported_route1', new Route('/imported/foo1'));
   91:         $importedCollection->add('imported_route2', new Route('/imported/foo2'));
   92  
   93          $loader = $this->getMockBuilder('Symfony\Component\Config\Loader\LoaderInterface')->getMock();
   ..
  101              ->will($this->returnValue($importedCollection));
  102  
  103:         $routes = new RouteCollectionBuilder($loader);
  104  
  105:         // 1) Add a route
  106:         $routes->add('/checkout', 'AppBundle:Order:checkout', 'checkout_route');
  107          // 2) Import from a file
  108:         $routes->mount('/', $routes->import('admin_routing.yml'));
  109:         // 3) Add another route
  110:         $routes->add('/', 'AppBundle:Default:homepage', 'homepage');
  111:         // 4) Add another route
  112:         $routes->add('/admin', 'AppBundle:Admin:dashboard', 'admin_dashboard');
  113  
  114          // set a default value
  115:         $routes->setDefault('_locale', 'fr');
  116  
  117:         $actualCollection = $routes->build();
  118  
  119          $this->assertCount(5, $actualCollection);
  120:         $actualRouteNames = array_keys($actualCollection->all());
  121          $this->assertEquals(array(
  122:             'checkout_route',
  123:             'imported_route1',
  124:             'imported_route2',
  125              'homepage',
  126              'admin_dashboard',
  127:         ), $actualRouteNames);
  128  
  129          // make sure the defaults were set
  130:         $checkoutRoute = $actualCollection->get('checkout_route');
  131:         $defaults = $checkoutRoute->getDefaults();
  132          $this->assertArrayHasKey('_locale', $defaults);
  133          $this->assertEquals('fr', $defaults['_locale']);
  134      }
  135  
  136:     public function testFlushSetsRouteNames()
  137      {
  138:         $collectionBuilder = new RouteCollectionBuilder();
  139  
  140:         // add a "named" route
  141          $collectionBuilder->add('/admin', 'AppBundle:Admin:dashboard', 'admin_dashboard');
  142:         // add an unnamed route
  143          $collectionBuilder->add('/blogs', 'AppBundle:Blog:list')
  144              ->setMethods(array('GET'));
  145  
  146:         // integer route names are allowed - they don't confuse things
  147          $collectionBuilder->add('/products', 'AppBundle:Product:list', 100);
  148  
  149          $actualCollection = $collectionBuilder->build();
  150:         $actualRouteNames = array_keys($actualCollection->all());
  151          $this->assertEquals(array(
  152              'admin_dashboard',
  153              'GET_blogs',
  154              '100',
  155:         ), $actualRouteNames);
  156      }
  157  
  158:     public function testFlushSetsDetailsOnChildrenRoutes()
  159      {
  160:         $routes = new RouteCollectionBuilder();
  161  
  162:         $routes->add('/blogs/{page}', 'listAction', 'blog_list')
  163:             // unique things for the route
  164              ->setDefault('page', 1)
  165              ->setRequirement('id', '\d+')
  ...
  174              ->setMethods(array('POST'));
  175  
  176:         // a simple route, nothing added to it
  177:         $routes->add('/blogs/{id}', 'editAction', 'blog_edit');
  178  
  179          // configure the collection itself
  180:         $routes
  181:             // things that will not override the child route
  182              ->setDefault('_format', 'json')
  183              ->setRequirement('_format', 'xml')
  ...
  188              ->setDefault('_locale', 'fr')
  189              ->setRequirement('_locale', 'fr|en')
  190:             ->setOption('niceRoute', true)
  191              ->setSchemes(array('http'))
  192              ->setMethods(array('GET', 'POST'));
  193  
  194:         $collection = $routes->build();
  195:         $actualListRoute = $collection->get('blog_list');
  196  
  197:         $this->assertEquals(1, $actualListRoute->getDefault('page'));
  198:         $this->assertEquals('\d+', $actualListRoute->getRequirement('id'));
  199:         $this->assertTrue($actualListRoute->getOption('expose'));
  200          // none of these should be overridden
  201:         $this->assertEquals('html', $actualListRoute->getDefault('_format'));
  202:         $this->assertEquals('json|xml', $actualListRoute->getRequirement('_format'));
  203:         $this->assertTrue($actualListRoute->getOption('fooBar'));
  204:         $this->assertEquals('example.com', $actualListRoute->getHost());
  205:         $this->assertEquals('request.isSecure()', $actualListRoute->getCondition());
  206:         $this->assertEquals(array('https'), $actualListRoute->getSchemes());
  207:         $this->assertEquals(array('POST'), $actualListRoute->getMethods());
  208          // inherited from the main collection
  209:         $this->assertEquals('fr', $actualListRoute->getDefault('_locale'));
  210:         $this->assertEquals('fr|en', $actualListRoute->getRequirement('_locale'));
  211:         $this->assertTrue($actualListRoute->getOption('niceRoute'));
  212  
  213:         $actualEditRoute = $collection->get('blog_edit');
  214          // inherited from the collection
  215:         $this->assertEquals('symfony.com', $actualEditRoute->getHost());
  216:         $this->assertEquals('request.query.get("page")==1', $actualEditRoute->getCondition());
  217:         $this->assertEquals(array('http'), $actualEditRoute->getSchemes());
  218:         $this->assertEquals(array('GET', 'POST'), $actualEditRoute->getMethods());
  219      }
  220  
  ...
  222       * @dataProvider providePrefixTests
  223       */
  224:     public function testFlushPrefixesPaths($collectionPrefix, $routePath, $expectedPath)
  225      {
  226:         $routes = new RouteCollectionBuilder();
  227  
  228:         $routes->add($routePath, 'someController', 'test_route');
  229  
  230:         $outerRoutes = new RouteCollectionBuilder();
  231:         $outerRoutes->mount($collectionPrefix, $routes);
  232  
  233:         $collection = $outerRoutes->build();
  234  
  235:         $this->assertEquals($expectedPath, $collection->get('test_route')->getPath());
  236      }
  237  
  ...
  255      {
  256          $loader = $this->getMockBuilder('Symfony\Component\Config\Loader\LoaderInterface')->getMock();
  257:         $routes = new RouteCollectionBuilder($loader);
  258  
  259:         $routes->add('homepage', 'MainController::homepageAction', 'homepage');
  260  
  261:         $adminRoutes = $routes->createBuilder();
  262:         $adminRoutes->add('/dashboard', 'AdminController::dashboardAction', 'admin_dashboard');
  263  
  264          // embedded collection under /admin
  265:         $adminBlogRoutes = $routes->createBuilder();
  266:         $adminBlogRoutes->add('/new', 'BlogController::newAction', 'admin_blog_new');
  267          // mount into admin, but before the parent collection has been mounted
  268:         $adminRoutes->mount('/blog', $adminBlogRoutes);
  269  
  270:         // now mount the /admin routes, above should all still be /blog/admin
  271:         $routes->mount('/admin', $adminRoutes);
  272:         // add a route after mounting
  273:         $adminRoutes->add('/users', 'AdminController::userAction', 'admin_users');
  274  
  275          // add another sub-collection after the mount
  276:         $otherAdminRoutes = $routes->createBuilder();
  277:         $otherAdminRoutes->add('/sales', 'StatsController::indexAction', 'admin_stats_sales');
  278:         $adminRoutes->mount('/stats', $otherAdminRoutes);
  279  
  280          // add a normal collection and see that it is also prefixed
  281:         $importedCollection = new RouteCollection();
  282:         $importedCollection->add('imported_route', new Route('/foo'));
  283          // make this loader able to do the import - keeps mocking simple
  284          $loader->expects($this->any())
  ...
  289              ->method('load')
  290              ->will($this->returnValue($importedCollection));
  291:         // import this from the /admin route builder
  292:         $adminRoutes->import('admin.yml', '/imported');
  293  
  294:         $collection = $routes->build();
  295:         $this->assertEquals('/admin/dashboard', $collection->get('admin_dashboard')->getPath(), 'Routes before mounting have the prefix');
  296:         $this->assertEquals('/admin/users', $collection->get('admin_users')->getPath(), 'Routes after mounting have the prefix');
  297          $this->assertEquals('/admin/blog/new', $collection->get('admin_blog_new')->getPath(), 'Sub-collections receive prefix even if mounted before parent prefix');
  298          $this->assertEquals('/admin/stats/sales', $collection->get('admin_stats_sales')->getPath(), 'Sub-collections receive prefix if mounted after parent prefix');
  299:         $this->assertEquals('/admin/imported/foo', $collection->get('imported_route')->getPath(), 'Normal RouteCollections are also prefixed properly');
  300      }
  301  
  302:     public function testAutomaticRouteNamesDoNotConflict()
  303      {
  304:         $routes = new RouteCollectionBuilder();
  305  
  306:         $adminRoutes = $routes->createBuilder();
  307:         // route 1
  308:         $adminRoutes->add('/dashboard', '');
  309  
  310:         $accountRoutes = $routes->createBuilder();
  311:         // route 2
  312:         $accountRoutes->add('/dashboard', '')
  313              ->setMethods(array('GET'));
  314:         // route 3
  315:         $accountRoutes->add('/dashboard', '')
  316              ->setMethods(array('POST'));
  317  
  318:         $routes->mount('/admin', $adminRoutes);
  319:         $routes->mount('/account', $accountRoutes);
  320  
  321:         $collection = $routes->build();
  322:         // there are 2 routes (i.e. with non-conflicting names)
  323          $this->assertCount(3, $collection->all());
  324      }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/RouteCollectionTest.php:
   13  
   14  use PHPUnit\Framework\TestCase;
   15: use Symfony\Component\Routing\RouteCollection;
   16: use Symfony\Component\Routing\Route;
   17  use Symfony\Component\Config\Resource\FileResource;
   18  
   19: class RouteCollectionTest extends TestCase
   20  {
   21:     public function testRoute()
   22      {
   23:         $collection = new RouteCollection();
   24:         $route = new Route('/foo');
   25:         $collection->add('foo', $route);
   26:         $this->assertEquals(array('foo' => $route), $collection->all(), '->add() adds a route');
   27:         $this->assertEquals($route, $collection->get('foo'), '->get() returns a route by name');
   28:         $this->assertNull($collection->get('bar'), '->get() returns null if a route does not exist');
   29      }
   30  
   31:     public function testOverriddenRoute()
   32      {
   33:         $collection = new RouteCollection();
   34:         $collection->add('foo', new Route('/foo'));
   35:         $collection->add('foo', new Route('/foo1'));
   36  
   37          $this->assertEquals('/foo1', $collection->get('foo')->getPath());
   38      }
   39  
   40:     public function testDeepOverriddenRoute()
   41      {
   42:         $collection = new RouteCollection();
   43:         $collection->add('foo', new Route('/foo'));
   44  
   45:         $collection1 = new RouteCollection();
   46:         $collection1->add('foo', new Route('/foo1'));
   47  
   48:         $collection2 = new RouteCollection();
   49:         $collection2->add('foo', new Route('/foo2'));
   50  
   51          $collection1->addCollection($collection2);
   ..
   58      public function testIterator()
   59      {
   60:         $collection = new RouteCollection();
   61:         $collection->add('foo', new Route('/foo'));
   62  
   63:         $collection1 = new RouteCollection();
   64:         $collection1->add('bar', $bar = new Route('/bar'));
   65:         $collection1->add('foo', $foo = new Route('/foo-new'));
   66          $collection->addCollection($collection1);
   67:         $collection->add('last', $last = new Route('/last'));
   68  
   69          $this->assertInstanceOf('\ArrayIterator', $collection->getIterator());
   ..
   73      public function testCount()
   74      {
   75:         $collection = new RouteCollection();
   76:         $collection->add('foo', new Route('/foo'));
   77  
   78:         $collection1 = new RouteCollection();
   79:         $collection1->add('bar', new Route('/bar'));
   80          $collection->addCollection($collection1);
   81  
   ..
   85      public function testAddCollection()
   86      {
   87:         $collection = new RouteCollection();
   88:         $collection->add('foo', new Route('/foo'));
   89  
   90:         $collection1 = new RouteCollection();
   91:         $collection1->add('bar', $bar = new Route('/bar'));
   92:         $collection1->add('foo', $foo = new Route('/foo-new'));
   93  
   94:         $collection2 = new RouteCollection();
   95:         $collection2->add('grandchild', $grandchild = new Route('/grandchild'));
   96  
   97          $collection1->addCollection($collection2);
   98          $collection->addCollection($collection1);
   99:         $collection->add('last', $last = new Route('/last'));
  100  
  101          $this->assertSame(array('bar' => $bar, 'foo' => $foo, 'grandchild' => $grandchild, 'last' => $last), $collection->all(),
  102:             '->addCollection() imports routes of another collection, overrides if necessary and adds them at the end');
  103      }
  104  
  105      public function testAddCollectionWithResources()
  106      {
  107:         $collection = new RouteCollection();
  108          $collection->addResource($foo = new FileResource(__DIR__.'/Fixtures/foo.xml'));
  109:         $collection1 = new RouteCollection();
  110          $collection1->addResource($foo1 = new FileResource(__DIR__.'/Fixtures/foo1.xml'));
  111          $collection->addCollection($collection1);
  ...
  115      public function testAddDefaultsAndRequirementsAndOptions()
  116      {
  117:         $collection = new RouteCollection();
  118:         $collection->add('foo', new Route('/{placeholder}'));
  119:         $collection1 = new RouteCollection();
  120:         $collection1->add('bar', new Route('/{placeholder}',
  121              array('_controller' => 'fixed', 'placeholder' => 'default'), array('placeholder' => '.+'), array('option' => 'value'))
  122          );
  ...
  124  
  125          $collection->addDefaults(array('placeholder' => 'new-default'));
  126:         $this->assertEquals(array('placeholder' => 'new-default'), $collection->get('foo')->getDefaults(), '->addDefaults() adds defaults to all routes');
  127          $this->assertEquals(array('_controller' => 'fixed', 'placeholder' => 'new-default'), $collection->get('bar')->getDefaults(),
  128:             '->addDefaults() adds defaults to all routes and overwrites existing ones');
  129  
  130          $collection->addRequirements(array('placeholder' => '\d+'));
  131:         $this->assertEquals(array('placeholder' => '\d+'), $collection->get('foo')->getRequirements(), '->addRequirements() adds requirements to all routes');
  132          $this->assertEquals(array('placeholder' => '\d+'), $collection->get('bar')->getRequirements(),
  133:             '->addRequirements() adds requirements to all routes and overwrites existing ones');
  134  
  135          $collection->addOptions(array('option' => 'new-value'));
  136          $this->assertEquals(
  137:             array('option' => 'new-value', 'compiler_class' => 'Symfony\\Component\\Routing\\RouteCompiler'),
  138:             $collection->get('bar')->getOptions(), '->addOptions() adds options to all routes and overwrites existing ones'
  139          );
  140      }
  ...
  142      public function testAddPrefix()
  143      {
  144:         $collection = new RouteCollection();
  145:         $collection->add('foo', $foo = new Route('/foo'));
  146:         $collection2 = new RouteCollection();
  147:         $collection2->add('bar', $bar = new Route('/bar'));
  148          $collection->addCollection($collection2);
  149          $collection->addPrefix(' / ');
  150          $this->assertSame('/foo', $collection->get('foo')->getPath(), '->addPrefix() trims the prefix and a single slash has no effect');
  151          $collection->addPrefix('/{admin}', array('admin' => 'admin'), array('admin' => '\d+'));
  152:         $this->assertEquals('/{admin}/foo', $collection->get('foo')->getPath(), '->addPrefix() adds a prefix to all routes');
  153:         $this->assertEquals('/{admin}/bar', $collection->get('bar')->getPath(), '->addPrefix() adds a prefix to all routes');
  154:         $this->assertEquals(array('admin' => 'admin'), $collection->get('foo')->getDefaults(), '->addPrefix() adds defaults to all routes');
  155:         $this->assertEquals(array('admin' => 'admin'), $collection->get('bar')->getDefaults(), '->addPrefix() adds defaults to all routes');
  156:         $this->assertEquals(array('admin' => '\d+'), $collection->get('foo')->getRequirements(), '->addPrefix() adds requirements to all routes');
  157:         $this->assertEquals(array('admin' => '\d+'), $collection->get('bar')->getRequirements(), '->addPrefix() adds requirements to all routes');
  158          $collection->addPrefix('0');
  159          $this->assertEquals('/0/{admin}/foo', $collection->get('foo')->getPath(), '->addPrefix() ensures a prefix must start with a slash and must not end with a slash');
  160          $collection->addPrefix('/ /');
  161          $this->assertSame('/ /0/{admin}/foo', $collection->get('foo')->getPath(), '->addPrefix() can handle spaces if desired');
  162:         $this->assertSame('/ /0/{admin}/bar', $collection->get('bar')->getPath(), 'the route pattern of an added collection is in synch with the added prefix');
  163      }
  164  
  165      public function testAddPrefixOverridesDefaultsAndRequirements()
  166      {
  167:         $collection = new RouteCollection();
  168:         $collection->add('foo', $foo = new Route('/foo.{_format}'));
  169:         $collection->add('bar', $bar = new Route('/bar.{_format}', array(), array('_format' => 'json')));
  170          $collection->addPrefix('/admin', array(), array('_format' => 'html'));
  171  
  ...
  176      public function testResource()
  177      {
  178:         $collection = new RouteCollection();
  179          $collection->addResource($foo = new FileResource(__DIR__.'/Fixtures/foo.xml'));
  180          $collection->addResource($bar = new FileResource(__DIR__.'/Fixtures/bar.xml'));
  ...
  185      }
  186  
  187:     public function testUniqueRouteWithGivenName()
  188      {
  189:         $collection1 = new RouteCollection();
  190:         $collection1->add('foo', new Route('/old'));
  191:         $collection2 = new RouteCollection();
  192:         $collection3 = new RouteCollection();
  193:         $collection3->add('foo', $new = new Route('/new'));
  194  
  195          $collection2->addCollection($collection3);
  196          $collection1->addCollection($collection2);
  197  
  198:         $this->assertSame($new, $collection1->get('foo'), '->get() returns new route that overrode previous one');
  199          // size of 1 because collection1 contains /new but not /old anymore
  200:         $this->assertCount(1, $collection1->getIterator(), '->addCollection() removes previous routes when adding new routes with the same name');
  201      }
  202  
  203      public function testGet()
  204      {
  205:         $collection1 = new RouteCollection();
  206:         $collection1->add('a', $a = new Route('/a'));
  207:         $collection2 = new RouteCollection();
  208:         $collection2->add('b', $b = new Route('/b'));
  209          $collection1->addCollection($collection2);
  210:         $collection1->add('$péß^a|', $c = new Route('/special'));
  211  
  212:         $this->assertSame($b, $collection1->get('b'), '->get() returns correct route in child collection');
  213          $this->assertSame($c, $collection1->get('$péß^a|'), '->get() can handle special characters');
  214:         $this->assertNull($collection2->get('a'), '->get() does not return the route defined in parent collection');
  215:         $this->assertNull($collection1->get('non-existent'), '->get() returns null when route does not exist');
  216:         $this->assertNull($collection1->get(0), '->get() does not disclose internal child RouteCollection');
  217      }
  218  
  219      public function testRemove()
  220      {
  221:         $collection = new RouteCollection();
  222:         $collection->add('foo', $foo = new Route('/foo'));
  223  
  224:         $collection1 = new RouteCollection();
  225:         $collection1->add('bar', $bar = new Route('/bar'));
  226          $collection->addCollection($collection1);
  227:         $collection->add('last', $last = new Route('/last'));
  228  
  229          $collection->remove('foo');
  230:         $this->assertSame(array('bar' => $bar, 'last' => $last), $collection->all(), '->remove() can remove a single route');
  231          $collection->remove(array('bar', 'last'));
  232:         $this->assertSame(array(), $collection->all(), '->remove() accepts an array and can remove multiple routes at once');
  233      }
  234  
  235      public function testSetHost()
  236      {
  237:         $collection = new RouteCollection();
  238:         $routea = new Route('/a');
  239:         $routeb = new Route('/b', array(), array(), array(), '{locale}.example.net');
  240:         $collection->add('a', $routea);
  241:         $collection->add('b', $routeb);
  242  
  243          $collection->setHost('{locale}.example.com');
  244  
  245:         $this->assertEquals('{locale}.example.com', $routea->getHost());
  246:         $this->assertEquals('{locale}.example.com', $routeb->getHost());
  247      }
  248  
  249      public function testSetCondition()
  250      {
  251:         $collection = new RouteCollection();
  252:         $routea = new Route('/a');
  253:         $routeb = new Route('/b', array(), array(), array(), '{locale}.example.net', array(), array(), 'context.getMethod() == "GET"');
  254:         $collection->add('a', $routea);
  255:         $collection->add('b', $routeb);
  256  
  257          $collection->setCondition('context.getMethod() == "POST"');
  258  
  259:         $this->assertEquals('context.getMethod() == "POST"', $routea->getCondition());
  260:         $this->assertEquals('context.getMethod() == "POST"', $routeb->getCondition());
  261      }
  262  
  263      public function testClone()
  264      {
  265:         $collection = new RouteCollection();
  266:         $collection->add('a', new Route('/a'));
  267:         $collection->add('b', new Route('/b', array('placeholder' => 'default'), array('placeholder' => '.+')));
  268  
  269          $clonedCollection = clone $collection;
  ...
  278      public function testSetSchemes()
  279      {
  280:         $collection = new RouteCollection();
  281:         $routea = new Route('/a', array(), array(), array(), '', 'http');
  282:         $routeb = new Route('/b');
  283:         $collection->add('a', $routea);
  284:         $collection->add('b', $routeb);
  285  
  286          $collection->setSchemes(array('http', 'https'));
  287  
  288:         $this->assertEquals(array('http', 'https'), $routea->getSchemes());
  289:         $this->assertEquals(array('http', 'https'), $routeb->getSchemes());
  290      }
  291  
  292      public function testSetMethods()
  293      {
  294:         $collection = new RouteCollection();
  295:         $routea = new Route('/a', array(), array(), array(), '', array(), array('GET', 'POST'));
  296:         $routeb = new Route('/b');
  297:         $collection->add('a', $routea);
  298:         $collection->add('b', $routeb);
  299  
  300          $collection->setMethods('PUT');
  301  
  302:         $this->assertEquals(array('PUT'), $routea->getMethods());
  303:         $this->assertEquals(array('PUT'), $routeb->getMethods());
  304      }
  305  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/RouteCompilerTest.php:
   13  
   14  use PHPUnit\Framework\TestCase;
   15: use Symfony\Component\Routing\Route;
   16: use Symfony\Component\Routing\RouteCompiler;
   17  
   18: class RouteCompilerTest extends TestCase
   19  {
   20      /**
   ..
   23      public function testCompile($name, $arguments, $prefix, $regex, $variables, $tokens)
   24      {
   25:         $r = new \ReflectionClass('Symfony\\Component\\Routing\\Route');
   26:         $route = $r->newInstanceArgs($arguments);
   27  
   28:         $compiled = $route->compile();
   29          $this->assertEquals($prefix, $compiled->getStaticPrefix(), $name.' (static prefix)');
   30          $this->assertEquals($regex, $compiled->getRegex(), $name.' (regex)');
   ..
   37          return array(
   38              array(
   39:                 'Static route',
   40                  array('/foo'),
   41                  '/foo', '#^/foo$#s', array(), array(
   ..
   45  
   46              array(
   47:                 'Route with a variable',
   48                  array('/foo/{bar}'),
   49                  '/foo', '#^/foo/(?P<bar>[^/]++)$#s', array('bar'), array(
   ..
   54  
   55              array(
   56:                 'Route with a variable that has a default value',
   57                  array('/foo/{bar}', array('bar' => 'bar')),
   58                  '/foo', '#^/foo(?:/(?P<bar>[^/]++))?$#s', array('bar'), array(
   ..
   63  
   64              array(
   65:                 'Route with several variables',
   66                  array('/foo/{bar}/{foobar}'),
   67                  '/foo', '#^/foo/(?P<bar>[^/]++)/(?P<foobar>[^/]++)$#s', array('bar', 'foobar'), array(
   ..
   73  
   74              array(
   75:                 'Route with several variables that have default values',
   76                  array('/foo/{bar}/{foobar}', array('bar' => 'bar', 'foobar' => '')),
   77                  '/foo', '#^/foo(?:/(?P<bar>[^/]++)(?:/(?P<foobar>[^/]++))?)?$#s', array('bar', 'foobar'), array(
   ..
   83  
   84              array(
   85:                 'Route with several variables but some of them have no default values',
   86                  array('/foo/{bar}/{foobar}', array('bar' => 'bar')),
   87                  '/foo', '#^/foo/(?P<bar>[^/]++)/(?P<foobar>[^/]++)$#s', array('bar', 'foobar'), array(
   ..
   93  
   94              array(
   95:                 'Route with an optional variable as the first segment',
   96                  array('/{bar}', array('bar' => 'bar')),
   97                  '', '#^/(?P<bar>[^/]++)?$#s', array('bar'), array(
   ..
  101  
  102              array(
  103:                 'Route with a requirement of 0',
  104                  array('/{bar}', array('bar' => null), array('bar' => '0')),
  105                  '', '#^/(?P<bar>0)?$#s', array('bar'), array(
  ...
  109  
  110              array(
  111:                 'Route with an optional variable as the first segment with requirements',
  112                  array('/{bar}', array('bar' => 'bar'), array('bar' => '(foo|bar)')),
  113                  '', '#^/(?P<bar>(foo|bar))?$#s', array('bar'), array(
  ...
  117  
  118              array(
  119:                 'Route with only optional variables',
  120                  array('/{foo}/{bar}', array('foo' => 'foo', 'bar' => 'bar')),
  121                  '', '#^/(?P<foo>[^/]++)?(?:/(?P<bar>[^/]++))?$#s', array('foo', 'bar'), array(
  ...
  126  
  127              array(
  128:                 'Route with a variable in last position',
  129                  array('/foo-{bar}'),
  130                  '/foo-', '#^/foo\-(?P<bar>[^/]++)$#s', array('bar'), array(
  ...
  135  
  136              array(
  137:                 'Route with nested placeholders',
  138                  array('/{static{var}static}'),
  139                  '/{static', '#^/\{static(?P<var>[^/]+)static\}$#s', array('var'), array(
  ...
  145  
  146              array(
  147:                 'Route without separator between variables',
  148                  array('/{w}{x}{y}{z}.{_format}', array('z' => 'default-z', '_format' => 'html'), array('y' => '(y|Y)')),
  149                  '', '#^/(?P<w>[^/\.]+)(?P<x>[^/\.]+)(?P<y>(y|Y))(?:(?P<z>[^/\.]++)(?:\.(?P<_format>[^/]++))?)?$#s', array('w', 'x', 'y', 'z', '_format'), array(
  ...
  157  
  158              array(
  159:                 'Route with a format',
  160                  array('/foo/{bar}.{_format}'),
  161                  '/foo', '#^/foo/(?P<bar>[^/\.]++)\.(?P<_format>[^/]++)$#s', array('bar', '_format'), array(
  ...
  167  
  168              array(
  169:                 'Static non UTF-8 route',
  170                  array("/fo\xE9"),
  171                  "/fo\xE9", "#^/fo\xE9$#s", array(), array(
  ...
  175  
  176              array(
  177:                 'Route with an explicit UTF-8 requirement',
  178                  array('/{bar}', array('bar' => null), array('bar' => '.'), array('utf8' => true)),
  179                  '', '#^/(?P<bar>.)?$#su', array('bar'), array(
  ...
  187       * @group legacy
  188       * @dataProvider provideCompileImplicitUtf8Data
  189:      * @expectedDeprecation Using UTF-8 route %s without setting the "utf8" option is deprecated %s.
  190       */
  191      public function testCompileImplicitUtf8Data($name, $arguments, $prefix, $regex, $variables, $tokens, $deprecationType)
  192      {
  193:         $r = new \ReflectionClass('Symfony\\Component\\Routing\\Route');
  194:         $route = $r->newInstanceArgs($arguments);
  195  
  196:         $compiled = $route->compile();
  197          $this->assertEquals($prefix, $compiled->getStaticPrefix(), $name.' (static prefix)');
  198          $this->assertEquals($regex, $compiled->getRegex(), $name.' (regex)');
  ...
  205          return array(
  206              array(
  207:                 'Static UTF-8 route',
  208                  array('/foé'),
  209                  '/foé', '#^/foé$#su', array(), array(
  ...
  214  
  215              array(
  216:                 'Route with an implicit UTF-8 requirement',
  217                  array('/{bar}', array('bar' => null), array('bar' => 'é')),
  218                  '', '#^/(?P<bar>é)?$#su', array('bar'), array(
  ...
  223  
  224              array(
  225:                 'Route with a UTF-8 class requirement',
  226                  array('/{bar}', array('bar' => null), array('bar' => '\pM')),
  227                  '', '#^/(?P<bar>\pM)?$#su', array('bar'), array(
  ...
  232  
  233              array(
  234:                 'Route with a UTF-8 separator',
  235:                 array('/foo/{bar}§{_format}', array(), array(), array('compiler_class' => Utf8RouteCompiler::class)),
  236                  '/foo', '#^/foo/(?P<bar>[^/§]++)§(?P<_format>[^/]++)$#su', array('bar', '_format'), array(
  237                      array('variable', '§', '[^/]++', '_format', true),
  ...
  247       * @expectedException \LogicException
  248       */
  249:     public function testRouteWithSameVariableTwice()
  250      {
  251:         $route = new Route('/{name}/{name}');
  252  
  253:         $compiled = $route->compile();
  254      }
  255  
  ...
  257       * @expectedException \LogicException
  258       */
  259:     public function testRouteCharsetMismatch()
  260      {
  261:         $route = new Route("/\xE9/{bar}", array(), array('bar' => '.'), array('utf8' => true));
  262  
  263:         $compiled = $route->compile();
  264      }
  265  
  ...
  269      public function testRequirementCharsetMismatch()
  270      {
  271:         $route = new Route('/foo/{bar}', array(), array('bar' => "\xE9"), array('utf8' => true));
  272  
  273:         $compiled = $route->compile();
  274      }
  275  
  ...
  277       * @expectedException \InvalidArgumentException
  278       */
  279:     public function testRouteWithFragmentAsPathParameter()
  280      {
  281:         $route = new Route('/{_fragment}');
  282  
  283:         $compiled = $route->compile();
  284      }
  285  
  ...
  288       * @expectedException \DomainException
  289       */
  290:     public function testRouteWithVariableNameStartingWithADigit($name)
  291      {
  292:         $route = new Route('/{'.$name.'}');
  293:         $route->compile();
  294      }
  295  
  ...
  308      public function testCompileWithHost($name, $arguments, $prefix, $regex, $variables, $pathVariables, $tokens, $hostRegex, $hostVariables, $hostTokens)
  309      {
  310:         $r = new \ReflectionClass('Symfony\\Component\\Routing\\Route');
  311:         $route = $r->newInstanceArgs($arguments);
  312  
  313:         $compiled = $route->compile();
  314          $this->assertEquals($prefix, $compiled->getStaticPrefix(), $name.' (static prefix)');
  315          $this->assertEquals($regex, str_replace(array("\n", ' '), '', $compiled->getRegex()), $name.' (regex)');
  ...
  326          return array(
  327              array(
  328:                 'Route with host pattern',
  329                  array('/hello', array(), array(), array(), 'www.example.com'),
  330                  '/hello', '#^/hello$#s', array(), array(), array(
  ...
  336              ),
  337              array(
  338:                 'Route with host pattern and some variables',
  339                  array('/hello/{name}', array(), array(), array(), 'www.example.{tld}'),
  340                  '/hello', '#^/hello/(?P<name>[^/]++)$#s', array('tld', 'name'), array('name'), array(
  ...
  348              ),
  349              array(
  350:                 'Route with variable at beginning of host',
  351                  array('/hello', array(), array(), array(), '{locale}.example.{tld}'),
  352                  '/hello', '#^/hello$#s', array('locale', 'tld'), array(), array(
  ...
  360              ),
  361              array(
  362:                 'Route with host variables that has a default value',
  363                  array('/hello', array('locale' => 'a', 'tld' => 'b'), array(), array(), '{locale}.example.{tld}'),
  364                  '/hello', '#^/hello$#s', array('locale', 'tld'), array(), array(
  ...
  377       * @expectedException \DomainException
  378       */
  379:     public function testRouteWithTooLongVariableName()
  380      {
  381:         $route = new Route(sprintf('/{%s}', str_repeat('a', RouteCompiler::VARIABLE_MAXIMUM_LENGTH + 1)));
  382:         $route->compile();
  383      }
  384  }
  385  
  386: class Utf8RouteCompiler extends RouteCompiler
  387  {
  388      const SEPARATORS = '/§';

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/RouteTest.php:
   13  
   14  use PHPUnit\Framework\TestCase;
   15: use Symfony\Component\Routing\Route;
   16  
   17: class RouteTest extends TestCase
   18  {
   19      public function testConstructor()
   20      {
   21:         $route = new Route('/{foo}', array('foo' => 'bar'), array('foo' => '\d+'), array('foo' => 'bar'), '{locale}.example.com');
   22:         $this->assertEquals('/{foo}', $route->getPath(), '__construct() takes a path as its first argument');
   23:         $this->assertEquals(array('foo' => 'bar'), $route->getDefaults(), '__construct() takes defaults as its second argument');
   24:         $this->assertEquals(array('foo' => '\d+'), $route->getRequirements(), '__construct() takes requirements as its third argument');
   25:         $this->assertEquals('bar', $route->getOption('foo'), '__construct() takes options as its fourth argument');
   26:         $this->assertEquals('{locale}.example.com', $route->getHost(), '__construct() takes a host pattern as its fifth argument');
   27  
   28:         $route = new Route('/', array(), array(), array(), '', array('Https'), array('POST', 'put'), 'context.getMethod() == "GET"');
   29:         $this->assertEquals(array('https'), $route->getSchemes(), '__construct() takes schemes as its sixth argument and lowercases it');
   30:         $this->assertEquals(array('POST', 'PUT'), $route->getMethods(), '__construct() takes methods as its seventh argument and uppercases it');
   31:         $this->assertEquals('context.getMethod() == "GET"', $route->getCondition(), '__construct() takes a condition as its eight argument');
   32  
   33:         $route = new Route('/', array(), array(), array(), '', 'Https', 'Post');
   34:         $this->assertEquals(array('https'), $route->getSchemes(), '__construct() takes a single scheme as its sixth argument');
   35:         $this->assertEquals(array('POST'), $route->getMethods(), '__construct() takes a single method as its seventh argument');
   36      }
   37  
   38      public function testPath()
   39      {
   40:         $route = new Route('/{foo}');
   41:         $route->setPath('/{bar}');
   42:         $this->assertEquals('/{bar}', $route->getPath(), '->setPath() sets the path');
   43:         $route->setPath('');
   44:         $this->assertEquals('/', $route->getPath(), '->setPath() adds a / at the beginning of the path if needed');
   45:         $route->setPath('bar');
   46:         $this->assertEquals('/bar', $route->getPath(), '->setPath() adds a / at the beginning of the path if needed');
   47:         $this->assertEquals($route, $route->setPath(''), '->setPath() implements a fluent interface');
   48:         $route->setPath('//path');
   49:         $this->assertEquals('/path', $route->getPath(), '->setPath() does not allow two slashes "//" at the beginning of the path as it would be confused with a network path when generating the path from the route');
   50      }
   51  
   52      public function testOptions()
   53      {
   54:         $route = new Route('/{foo}');
   55:         $route->setOptions(array('foo' => 'bar'));
   56          $this->assertEquals(array_merge(array(
   57:         'compiler_class' => 'Symfony\\Component\\Routing\\RouteCompiler',
   58:         ), array('foo' => 'bar')), $route->getOptions(), '->setOptions() sets the options');
   59:         $this->assertEquals($route, $route->setOptions(array()), '->setOptions() implements a fluent interface');
   60  
   61:         $route->setOptions(array('foo' => 'foo'));
   62:         $route->addOptions(array('bar' => 'bar'));
   63:         $this->assertEquals($route, $route->addOptions(array()), '->addOptions() implements a fluent interface');
   64:         $this->assertEquals(array('foo' => 'foo', 'bar' => 'bar', 'compiler_class' => 'Symfony\\Component\\Routing\\RouteCompiler'), $route->getOptions(), '->addDefaults() keep previous defaults');
   65      }
   66  
   67      public function testOption()
   68      {
   69:         $route = new Route('/{foo}');
   70:         $this->assertFalse($route->hasOption('foo'), '->hasOption() return false if option is not set');
   71:         $this->assertEquals($route, $route->setOption('foo', 'bar'), '->setOption() implements a fluent interface');
   72:         $this->assertEquals('bar', $route->getOption('foo'), '->setOption() sets the option');
   73:         $this->assertTrue($route->hasOption('foo'), '->hasOption() return true if option is set');
   74      }
   75  
   76      public function testDefaults()
   77      {
   78:         $route = new Route('/{foo}');
   79:         $route->setDefaults(array('foo' => 'bar'));
   80:         $this->assertEquals(array('foo' => 'bar'), $route->getDefaults(), '->setDefaults() sets the defaults');
   81:         $this->assertEquals($route, $route->setDefaults(array()), '->setDefaults() implements a fluent interface');
   82  
   83:         $route->setDefault('foo', 'bar');
   84:         $this->assertEquals('bar', $route->getDefault('foo'), '->setDefault() sets a default value');
   85  
   86:         $route->setDefault('foo2', 'bar2');
   87:         $this->assertEquals('bar2', $route->getDefault('foo2'), '->getDefault() return the default value');
   88:         $this->assertNull($route->getDefault('not_defined'), '->getDefault() return null if default value is not set');
   89  
   90:         $route->setDefault('_controller', $closure = function () { return 'Hello'; });
   91:         $this->assertEquals($closure, $route->getDefault('_controller'), '->setDefault() sets a default value');
   92  
   93:         $route->setDefaults(array('foo' => 'foo'));
   94:         $route->addDefaults(array('bar' => 'bar'));
   95:         $this->assertEquals($route, $route->addDefaults(array()), '->addDefaults() implements a fluent interface');
   96:         $this->assertEquals(array('foo' => 'foo', 'bar' => 'bar'), $route->getDefaults(), '->addDefaults() keep previous defaults');
   97      }
   98  
   99      public function testRequirements()
  100      {
  101:         $route = new Route('/{foo}');
  102:         $route->setRequirements(array('foo' => '\d+'));
  103:         $this->assertEquals(array('foo' => '\d+'), $route->getRequirements(), '->setRequirements() sets the requirements');
  104:         $this->assertEquals('\d+', $route->getRequirement('foo'), '->getRequirement() returns a requirement');
  105:         $this->assertNull($route->getRequirement('bar'), '->getRequirement() returns null if a requirement is not defined');
  106:         $route->setRequirements(array('foo' => '^\d+$'));
  107:         $this->assertEquals('\d+', $route->getRequirement('foo'), '->getRequirement() removes ^ and $ from the path');
  108:         $this->assertEquals($route, $route->setRequirements(array()), '->setRequirements() implements a fluent interface');
  109  
  110:         $route->setRequirements(array('foo' => '\d+'));
  111:         $route->addRequirements(array('bar' => '\d+'));
  112:         $this->assertEquals($route, $route->addRequirements(array()), '->addRequirements() implements a fluent interface');
  113:         $this->assertEquals(array('foo' => '\d+', 'bar' => '\d+'), $route->getRequirements(), '->addRequirement() keep previous requirements');
  114      }
  115  
  116      public function testRequirement()
  117      {
  118:         $route = new Route('/{foo}');
  119:         $this->assertFalse($route->hasRequirement('foo'), '->hasRequirement() return false if requirement is not set');
  120:         $route->setRequirement('foo', '^\d+$');
  121:         $this->assertEquals('\d+', $route->getRequirement('foo'), '->setRequirement() removes ^ and $ from the path');
  122:         $this->assertTrue($route->hasRequirement('foo'), '->hasRequirement() return true if requirement is set');
  123      }
  124  
  ...
  129      public function testSetInvalidRequirement($req)
  130      {
  131:         $route = new Route('/{foo}');
  132:         $route->setRequirement('foo', $req);
  133      }
  134  
  ...
  146      public function testHost()
  147      {
  148:         $route = new Route('/');
  149:         $route->setHost('{locale}.example.net');
  150:         $this->assertEquals('{locale}.example.net', $route->getHost(), '->setHost() sets the host pattern');
  151      }
  152  
  153      public function testScheme()
  154      {
  155:         $route = new Route('/');
  156:         $this->assertEquals(array(), $route->getSchemes(), 'schemes is initialized with array()');
  157:         $this->assertFalse($route->hasScheme('http'));
  158:         $route->setSchemes('hTTp');
  159:         $this->assertEquals(array('http'), $route->getSchemes(), '->setSchemes() accepts a single scheme string and lowercases it');
  160:         $this->assertTrue($route->hasScheme('htTp'));
  161:         $this->assertFalse($route->hasScheme('httpS'));
  162:         $route->setSchemes(array('HttpS', 'hTTp'));
  163:         $this->assertEquals(array('https', 'http'), $route->getSchemes(), '->setSchemes() accepts an array of schemes and lowercases them');
  164:         $this->assertTrue($route->hasScheme('htTp'));
  165:         $this->assertTrue($route->hasScheme('httpS'));
  166      }
  167  
  168      public function testMethod()
  169      {
  170:         $route = new Route('/');
  171:         $this->assertEquals(array(), $route->getMethods(), 'methods is initialized with array()');
  172:         $route->setMethods('gEt');
  173:         $this->assertEquals(array('GET'), $route->getMethods(), '->setMethods() accepts a single method string and uppercases it');
  174:         $route->setMethods(array('gEt', 'PosT'));
  175:         $this->assertEquals(array('GET', 'POST'), $route->getMethods(), '->setMethods() accepts an array of methods and uppercases them');
  176      }
  177  
  178      public function testCondition()
  179      {
  180:         $route = new Route('/');
  181:         $this->assertSame('', $route->getCondition());
  182:         $route->setCondition('context.getMethod() == "GET"');
  183:         $this->assertSame('context.getMethod() == "GET"', $route->getCondition());
  184      }
  185  
  186      public function testCompile()
  187      {
  188:         $route = new Route('/{foo}');
  189:         $this->assertInstanceOf('Symfony\Component\Routing\CompiledRoute', $compiled = $route->compile(), '->compile() returns a compiled route');
  190:         $this->assertSame($compiled, $route->compile(), '->compile() only compiled the route once if unchanged');
  191:         $route->setRequirement('foo', '.*');
  192:         $this->assertNotSame($compiled, $route->compile(), '->compile() recompiles if the route was modified');
  193      }
  194  
  195      public function testSerialize()
  196      {
  197:         $route = new Route('/prefix/{foo}', array('foo' => 'default'), array('foo' => '\d+'));
  198  
  199:         $serialized = serialize($route);
  200          $unserialized = unserialize($serialized);
  201  
  202:         $this->assertEquals($route, $unserialized);
  203:         $this->assertNotSame($route, $unserialized);
  204      }
  205  
  ...
  210      public function testSerializeWhenCompiled()
  211      {
  212:         $route = new Route('/prefix/{foo}', array('foo' => 'default'), array('foo' => '\d+'));
  213:         $route->setHost('{locale}.example.net');
  214:         $route->compile();
  215  
  216:         $serialized = serialize($route);
  217          $unserialized = unserialize($serialized);
  218  
  219:         $this->assertEquals($route, $unserialized);
  220:         $this->assertNotSame($route, $unserialized);
  221      }
  222  
  223      /**
  224:      * Tests that unserialization does not fail when the compiled Route is of a
  225:      * class other than CompiledRoute, such as a subclass of it.
  226       */
  227      public function testSerializeWhenCompiledWithClass()
  228      {
  229:         $route = new Route('/', array(), array(), array('compiler_class' => '\Symfony\Component\Routing\Tests\Fixtures\CustomRouteCompiler'));
  230:         $this->assertInstanceOf('\Symfony\Component\Routing\Tests\Fixtures\CustomCompiledRoute', $route->compile(), '->compile() returned a proper route');
  231  
  232:         $serialized = serialize($route);
  233          try {
  234              $unserialized = unserialize($serialized);
  235:             $this->assertInstanceOf('\Symfony\Component\Routing\Tests\Fixtures\CustomCompiledRoute', $unserialized->compile(), 'the unserialized route compiled successfully');
  236          } catch (\Exception $e) {
  237:             $this->fail('unserializing a route which uses a custom compiled route class');
  238          }
  239      }
  240  
  241      /**
  242:      * Tests that the serialized representation of a route in one symfony version
  243:      * also works in later symfony versions, i.e. the unserialized route is in the
  244:      * same state as another, semantically equivalent, route.
  245       */
  246      public function testSerializedRepresentationKeepsWorking()
  247      {
  248:         $serialized = 'C:31:"Symfony\Component\Routing\Route":934:{a:8:{s:4:"path";s:13:"/prefix/{foo}";s:4:"host";s:20:"{locale}.example.net";s:8:"defaults";a:1:{s:3:"foo";s:7:"default";}s:12:"requirements";a:1:{s:3:"foo";s:3:"\d+";}s:7:"options";a:1:{s:14:"compiler_class";s:39:"Symfony\Component\Routing\RouteCompiler";}s:7:"schemes";a:0:{}s:7:"methods";a:0:{}s:8:"compiled";C:39:"Symfony\Component\Routing\CompiledRoute":569:{a:8:{s:4:"vars";a:2:{i:0;s:6:"locale";i:1;s:3:"foo";}s:11:"path_prefix";s:7:"/prefix";s:10:"path_regex";s:30:"#^/prefix(?:/(?P<foo>\d+))?$#s";s:11:"path_tokens";a:2:{i:0;a:4:{i:0;s:8:"variable";i:1;s:1:"/";i:2;s:3:"\d+";i:3;s:3:"foo";}i:1;a:2:{i:0;s:4:"text";i:1;s:7:"/prefix";}}s:9:"path_vars";a:1:{i:0;s:3:"foo";}s:10:"host_regex";s:39:"#^(?P<locale>[^\.]++)\.example\.net$#si";s:11:"host_tokens";a:2:{i:0;a:2:{i:0;s:4:"text";i:1;s:12:".example.net";}i:1;a:4:{i:0;s:8:"variable";i:1;s:0:"";i:2;s:7:"[^\.]++";i:3;s:6:"locale";}}s:9:"host_vars";a:1:{i:0;s:6:"locale";}}}}}';
  249          $unserialized = unserialize($serialized);
  250  
  251:         $route = new Route('/prefix/{foo}', array('foo' => 'default'), array('foo' => '\d+'));
  252:         $route->setHost('{locale}.example.net');
  253:         $route->compile();
  254  
  255:         $this->assertEquals($route, $unserialized);
  256:         $this->assertNotSame($route, $unserialized);
  257      }
  258  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/Tests/RouterTest.php:
   13  
   14  use PHPUnit\Framework\TestCase;
   15: use Symfony\Component\Routing\Router;
   16  use Symfony\Component\HttpFoundation\Request;
   17  
   18: class RouterTest extends TestCase
   19  {
   20:     private $router = null;
   21  
   22      private $loader = null;
   ..
   25      {
   26          $this->loader = $this->getMockBuilder('Symfony\Component\Config\Loader\LoaderInterface')->getMock();
   27:         $this->router = new Router($this->loader, 'routing.yml');
   28      }
   29  
   30      public function testSetOptionsWithSupportedOptions()
   31      {
   32:         $this->router->setOptions(array(
   33              'cache_dir' => './cache',
   34              'debug' => true,
   ..
   36          ));
   37  
   38:         $this->assertSame('./cache', $this->router->getOption('cache_dir'));
   39:         $this->assertTrue($this->router->getOption('debug'));
   40:         $this->assertSame('ResourceType', $this->router->getOption('resource_type'));
   41      }
   42  
   43      /**
   44       * @expectedException \InvalidArgumentException
   45:      * @expectedExceptionMessage The Router does not support the following options: "option_foo", "option_bar"
   46       */
   47      public function testSetOptionsWithUnsupportedOptions()
   48      {
   49:         $this->router->setOptions(array(
   50              'cache_dir' => './cache',
   51              'option_foo' => true,
   ..
   57      public function testSetOptionWithSupportedOption()
   58      {
   59:         $this->router->setOption('cache_dir', './cache');
   60  
   61:         $this->assertSame('./cache', $this->router->getOption('cache_dir'));
   62      }
   63  
   64      /**
   65       * @expectedException \InvalidArgumentException
   66:      * @expectedExceptionMessage The Router does not support the "option_foo" option
   67       */
   68      public function testSetOptionWithUnsupportedOption()
   69      {
   70:         $this->router->setOption('option_foo', true);
   71      }
   72  
   73      /**
   74       * @expectedException \InvalidArgumentException
   75:      * @expectedExceptionMessage The Router does not support the "option_foo" option
   76       */
   77      public function testGetOptionWithUnsupportedOption()
   78      {
   79:         $this->router->getOption('option_foo', true);
   80      }
   81  
   82:     public function testThatRouteCollectionIsLoaded()
   83      {
   84:         $this->router->setOption('resource_type', 'ResourceType');
   85  
   86:         $routeCollection = $this->getMockBuilder('Symfony\Component\Routing\RouteCollection')->getMock();
   87  
   88          $this->loader->expects($this->once())
   89              ->method('load')->with('routing.yml', 'ResourceType')
   90:             ->will($this->returnValue($routeCollection));
   91  
   92:         $this->assertSame($routeCollection, $this->router->getRouteCollection());
   93      }
   94  
   ..
   98      public function testMatcherIsCreatedIfCacheIsNotConfigured($option)
   99      {
  100:         $this->router->setOption($option, null);
  101  
  102          $this->loader->expects($this->once())
  103              ->method('load')->with('routing.yml', null)
  104:             ->will($this->returnValue($this->getMockBuilder('Symfony\Component\Routing\RouteCollection')->getMock()));
  105  
  106:         $this->assertInstanceOf('Symfony\\Component\\Routing\\Matcher\\UrlMatcher', $this->router->getMatcher());
  107      }
  108  
  ...
  120      public function testGeneratorIsCreatedIfCacheIsNotConfigured($option)
  121      {
  122:         $this->router->setOption($option, null);
  123  
  124          $this->loader->expects($this->once())
  125              ->method('load')->with('routing.yml', null)
  126:             ->will($this->returnValue($this->getMockBuilder('Symfony\Component\Routing\RouteCollection')->getMock()));
  127  
  128:         $this->assertInstanceOf('Symfony\\Component\\Routing\\Generator\\UrlGenerator', $this->router->getGenerator());
  129      }
  130  
  ...
  142          $matcher->expects($this->once())->method('match');
  143  
  144:         $p = new \ReflectionProperty($this->router, 'matcher');
  145          $p->setAccessible(true);
  146:         $p->setValue($this->router, $matcher);
  147  
  148:         $this->router->matchRequest(Request::create('/'));
  149      }
  150  
  ...
  154          $matcher->expects($this->once())->method('matchRequest');
  155  
  156:         $p = new \ReflectionProperty($this->router, 'matcher');
  157          $p->setAccessible(true);
  158:         $p->setValue($this->router, $matcher);
  159  
  160:         $this->router->matchRequest(Request::create('/'));
  161      }
  162  }

/home/dila/Videos/HOWKEMASTER/vendor/symfony/routing/composer.json:
    3      "type": "library",
    4      "description": "Symfony Routing Component",
    5:     "keywords": ["routing", "router", "URL", "URI"],
    6      "homepage": "https://symfony.com",
    7      "license": "MIT",
    .
   36      "suggest": {
   37          "symfony/http-foundation": "For using a Symfony Request object",
   38:         "symfony/config": "For using the all-in-one router or any loader",
   39          "symfony/yaml": "For using the YAML loader",
   40          "symfony/expression-language": "For using expression matching",
   41          "doctrine/annotations": "For using the annotation loader",
   42:         "symfony/dependency-injection": "For loading routes from a service"
   43      },
   44      "autoload": {

4238 matches across 219 files
